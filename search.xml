<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title><![CDATA[类型转换注意点]]></title>
      <url>http://fengqingxiuyi.xyz/Android/Wiki/%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E6%B3%A8%E6%84%8F%E7%82%B9.html</url>
      <content type="html"><![CDATA[注：本文所属Android-Wiki，本文主要介绍一些关于类型转换的注意点。 Object转换为Boolean: Object.booleanVaule() String转换为Boolean: Boolean.parseBoolean(String); String转换为Color: Color.parseColor(String);]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Dialog使用注意点]]></title>
      <url>http://fengqingxiuyi.xyz/Android/View/Dialog/Dialog%E4%BD%BF%E7%94%A8%E6%B3%A8%E6%84%8F%E7%82%B9.html</url>
      <content type="html"><![CDATA[注：本文所属Android-View-Dialog，用于记录在使用Dialog过程中遇到的一些坑，当然页包括DialogFragment，本文持续更新… New&amp;Showdialog new的时候只创建了构造方法，show的时候才创建了view。 赋值内部定义 123456789101112131415161718192021222324252627public class InviteConfirmDialog extends BaseDialogFragment &#123; private TextView inviteShopName; String shopName; @Override public int getContentView() &#123; return R.layout.invite_confirm_dialog; &#125; @Override public void initView(View view) &#123; inviteShopName = (TextView) findViewById(R.id.invite_shop_name); inviteShopName.setText(shopName); &#125; public void setInfo(String shopName) &#123; this.shopName = shopName; if (null != inviteShopName) &#123; inviteShopName.setText(shopName); &#125; &#125;&#125; 外部调用 1inviteConfirmDialog.setInfo(inviteShopInfo.shop.name); 问：为什么在上述代码中inviteShopName设置文本设置了两次？ 解答：因为在外部调用的时候，dialog show的时机不确定，所以存在两种情况： 情况一：dialog先显示再赋值 因为dialog在调用了show方法之后，会先调用initView方法，这个时候initView方法中的setText方法是无用的；然后之后再赋值，就可以正确显示了。 情况二：dialog先赋值再显示 因为dialog在调用了show方法之后，才会调用initView方法，所以先赋值的话inviteShopName == null，所以只是把值保存在成员变量之中；等到show的时候调用initView方法，再在initView方法中调用setText方法即可正确赋值。 使用场景：外部灵活调用。]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[mapping文件查看]]></title>
      <url>http://fengqingxiuyi.xyz/Android/Android%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/mapping%E6%96%87%E4%BB%B6%E6%9F%A5%E7%9C%8B.html</url>
      <content type="html"><![CDATA[注：本文所属Android-Android开发工具，用于介绍自己在使用mapping文件定位错误的心得。 错误日志从手机中的crash文件夹中获得 或者 从友盟后台获得，此处属于前者。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849SUPPORTED_64_BIT_ABIS=[Ljava.lang.String;@d28f72dversionCode=7BOARD=MSM8974BOOTLOADER=unknownTYPE=userID=MMB29MTIME=1471425647000BRAND=XiaomiTAG=BuildSERIAL=5396ac39HARDWARE=qcomSUPPORTED_ABIS=[Ljava.lang.String;@f8f2462CPU_ABI=armeabi-v7aRADIO=unknownIS_DEBUGGABLE=falseMANUFACTURER=XiaomiSUPPORTED_32_BIT_ABIS=[Ljava.lang.String;@e0c7a44TAGS=release-keysCPU_ABI2=armeabiUNKNOWN=unknownUSER=builderFINGERPRINT=Xiaomi/cancro_wc_lte/cancro:6.0.1/MMB29M/V8.0.2.0.MXDCNDG:user/release-keysHOST=c3-miui-ota-bd32.bjPRODUCT=cancro_wc_lteversionName=1.3.0DISPLAY=MMB29MMODEL=MI 4LTEDEVICE=cancrojava.lang.NullPointerException: key == null || value == null at android.util.LruCache.put(LruCache.java:166) at com.showjoy.b.d.a.a(SourceFile:77) at com.showjoy.b.d.a.a(SourceFile:152) at com.showjoy.shop.common.user.b.e(SourceFile:122) at com.showjoy.shop.common.user.b.a(SourceFile:206) at com.showjoy.shop.module.login.account.b.a(SourceFile:152) at com.showjoy.shop.module.login.account.a.a(SourceFile:27) at com.showjoy.shop.common.base.b.b(SourceFile:73) at com.showjoy.shop.common.base.b$1.a(SourceFile:40) at com.showjoy.shop.common.base.b$1.a(SourceFile:32) at com.showjoy.network.base.c$1.a(SourceFile:160) at com.showjoy.network.base.d.b(SourceFile:131) at com.android.volley.d$a.run(SourceFile:99) at android.os.Handler.handleCallback(Handler.java:739) at android.os.Handler.dispatchMessage(Handler.java:95) at android.os.Looper.loop(Looper.java:148) at android.app.ActivityThread.main(ActivityThread.java:5438) at java.lang.reflect.Method.invoke(Native Method) at com.android.internal.os.ZygoteInit$MethodAndArgsCaller.run(ZygoteInit.java:739) at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:629) 因为代码被混淆，所以我们无法直观知道出错位置，必须依靠mapping文件进行查找。 mapping文件位置此处以ShopAndroid-release-1.3.0-test为例。 查找错误位置心得首先需要找到错误出现的入口，比如（错误任务栈信息第5行）： 1at com.showjoy.shop.common.user.b.e(SourceFile:122) 打开文件后，搜索com.showjoy.shop.common.user.b，找到以下相关信息： 12345678910111213141516171819202122232425262728293031com.showjoy.shop.common.user.UserDataManager -&gt; com.showjoy.shop.common.user.b: com.showjoy.shop.common.user.entities.UserResult userResult -&gt; a 26:27:void setBuyer(boolean) -&gt; a 30:30:boolean isLogin() -&gt; a 34:35:void setLogin(boolean) -&gt; b 38:38:boolean hasShop() -&gt; b 42:43:void setShopOpened(boolean) -&gt; c 46:46:int getShopId() -&gt; c 50:51:void setShopId(int) -&gt; a 54:54:int getUserId() -&gt; d 58:59:void setUserId(int) -&gt; b 62:62:boolean isBindWeixin() -&gt; e 66:67:void bindWeixin(boolean) -&gt; d 75:75:java.lang.String getUserEd() -&gt; f 79:80:void setUserEd(java.lang.String) -&gt; a 83:83:java.lang.String getPhone() -&gt; g 87:88:void setPhone(java.lang.String) -&gt; b 91:91:java.lang.String getNick() -&gt; h 95:96:void setNick(java.lang.String) -&gt; c 104:105:void setShopName(java.lang.String) -&gt; d 113:113:java.lang.String getShopPortrait() -&gt; i 122:123:void setPortrait(java.lang.String) -&gt; e 131:131:java.lang.String getPortrait() -&gt; j 140:141:void setShopPortrait(java.lang.String) -&gt; f 149:149:java.lang.String getShopName() -&gt; k 158:159:void setPaid(boolean) -&gt; e 176:177:void setPosition(int) -&gt; c 189:209:void saveShopInfo(com.showjoy.shop.common.user.entities.ShopInfo) -&gt; a 217:224:com.showjoy.shop.common.user.entities.UserResult getUser() -&gt; l 233:235:void setUser(com.showjoy.shop.common.user.entities.UserResult) -&gt; a 238:257:void logOut() -&gt; m 然后继续查找e方法，发现有好几个，不过没关系，入口错误信息还括出了出现错误信息的位置，即122行，继续查找e方法对应的其实是setPortrait方法。最后在进入工程查看源码就可以了，如果还是没有发现关键位置，可以继续向下查找。]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[SourceTree使用注意]]></title>
      <url>http://fengqingxiuyi.xyz/Android/Android%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/SourceTree%E4%BD%BF%E7%94%A8%E6%B3%A8%E6%84%8F.html</url>
      <content type="html"><![CDATA[注：本文所属Android-Android开发工具，用于记录使用SourceTree管理Git过程中遇到的坑，持续更新… Tag标记子模块 更新版本 后，需要在sourceTree中选中对应的条目右击添加Tag进行标记，并push；如果标记位置出错，可以在正确的条目处右击添加同名的Tag，就会提示你是否需要迁移Tag。 代码改动较多时代码改动较多时需要严格按照此流程执行：从develop拉个新的功能分支开发，开发自测通过后，将develop合并到新分支中，测试通过后再合并到develop中。]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[AndroidStudio开发注意点]]></title>
      <url>http://fengqingxiuyi.xyz/Android/Android%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/AndroidStudio%E5%BC%80%E5%8F%91%E6%B3%A8%E6%84%8F%E7%82%B9.html</url>
      <content type="html"><![CDATA[注：本文所属Android-Android开发工具，用于记录在使用AndroidStudio开发过程中遇到的一些坑，持续更新… AS反编译失败，显示Compiled Code插件：jd-intellij-0.6.zip 问题：安装了上述插件后，不能查看jar包中的源码，方法内部显示 /* Compiled Code */。 例子：/Volumes/MAIN/qingfeng/Workspace/CharityShopAndroid/shopandroid_detail/build/intermediates/exploded-aar/com.showjoy.analytics/analytics/1.0.6/jars/classes.jar 解决：经过一番思考，发现是因为装了插件jd-intellij-0.6.zip，导致和AS的反编译插件冲突了，所以看不到源码了，所以解决办法就是卸载插件。]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Sublime Text 3折腾记录]]></title>
      <url>http://fengqingxiuyi.xyz/%E5%9F%BA%E6%9C%AC%E5%B7%A5%E5%85%B7/Sublime/Sublime%20Text%203%E6%8A%98%E8%85%BE%E8%AE%B0%E5%BD%95.html</url>
      <content type="html"><![CDATA[注：本文所属基本工具-Sublime，本文介绍Sublime的LICENSE／重置／安装Package Control的方法。 LICENSE提供网上流传已久的注册码，自我感觉是通用的，不过还是说明一下自己的版本：Build 3114 1234567891011121314151617181920212223242526272829—– BEGIN LICENSE —–Anthony SansoneSingle User LicenseEA7E-87856328B9A648 42B99D8A F2E3E9E0 16DE076EE218B3DC F3606379 C33C1526 E8B58964B2CB3F63 BDF901BE D31424D2 082891B5F7058694 55FA46D8 EFC11878 0868F093B17CAFE7 63A78881 86B78E38 0F146238BAE22DBB D4EC71A1 0EC2E701 C7F9C6485CF29CA3 1CB14285 19A46991 E9A9867614FD4777 2D8A0AB6 A444EE0D CA009B54—— END LICENSE ——或者—– BEGIN LICENSE —–Alexey PlutalovSingle User LicenseEA7E-8607763DC19CC1 134CDF23 504DC871 2DE5CE55585DC8A6 253BB0D9 637C87A2 D8D0BA85AAE574AD BA7D6DA9 2B9773F2 324C5DEF17830A4E FBCF9D1D 182406E9 F883EA87E585BBA1 2538C270 E2E857C2 194283CA7234FF9E D0392F93 1D16E021 F191491763909E12 203C0169 3F08FFC8 86D06EA873DDAEF0 AC559F30 A6A67947 B60104C6—— END LICENSE —— 重置网址：http://www.sublimetext.com/docs/3/revert.html 内容： 123456789101112131415161718192021SUBLIME TEXT 3 DOCUMENTATIONReverting to a Freshly Installed StateSublime Text can be reverted to a freshly installed state by removing your data folder. Depending on your operating system, this folder is located in:OS X: ~/Library/Application Support/Sublime Text 3Windows: %APPDATA%\Sublime Text 3Linux: ~/.config/sublime-text-3To revert to a freshly installed state, you can:Exit Sublime TextMove the data folder to a backup locationStart Sublime TextWhen restarted, a fresh data folder will be created, just as it was the first time you ran Sublime Text. Keep in mind that this will also remove all of your settings and packages. The backup copy of your data folder can be used to retrieve configuration, or custom packages that can not be reinstalled.OS XOn OS X, the ~/Library folder is hidden by default. To navigate there, select the Go ▸ Go to Folder menu item in Finder, and type in ~/Library.鼠标点击Finder后，按快捷键control+shift+g，在出现的弹框中输入正确的完整路径即可直接到达WindowsIn Windows, cache files are stored in a separate location, %LOCALAPPDATA%\Sublime Text 3, to improve performance with roaming profiles. 安装Package Control自动安装使用快捷键control+`或通过菜单选项View &gt; Show Console进入控制台Console（再进行一次同样的操作，可以退出控制台Console）。 复制其中一个命令，粘贴到控制台中，回车运行，如果失败就换另一个，如果都失败，请选择手动安装方式。 12345import urllib.request,os,hashlib; h = &apos;7183a2d3e96f11eeadd761d777e62404e330c659d4bb41d3bdf022e94cab3cd0&apos;; pf = &apos;Package Control.sublime-package&apos;; ipp = sublime.installed_packages_path(); urllib.request.install_opener( urllib.request.build_opener( urllib.request.ProxyHandler()) ); by = urllib.request.urlopen( &apos;http://sublime.wbond.net/&apos; + pf.replace(&apos; &apos;, &apos;%20&apos;)).read(); dh = hashlib.sha256(by).hexdigest(); print(&apos;Error validating download (got %s instead of %s), please try manual install&apos; % (dh, h)) if dh != h else open(os.path.join( ipp, pf), &apos;wb&apos; ).write(by)或者import urllib.request,os;pf=&apos;Package Control.sublime-package&apos;;ipp=sublime.installed_packages_path();urllib.request.install_opener(urllib.request.build_opener(urllib.request.ProxyHandler()));open(os.path.join(ipp,pf),&apos;wb&apos;).write(urllib.request.urlopen(&apos;http://sublime.wbond.net/&apos;+pf.replace(&apos; &apos;,&apos;%20&apos;)).read()) 手动安装 打开网址：https://sublime.wbond.net/Package%20Control.sublime-package，会自动下载名为Package%20Control.sublime-package的文件。 打开Sublime Text 3，选择菜单Preferences-&gt;Browse Packages… 打开安装目录 此时会进入到一个叫做Packages的目录下，点击进入上一层目录Sublime Text 3，在此目录下有一个文件夹叫做Installed Packages，把刚才下载的文件放到这里就可以了。 重启sublime text3，观察Preferences菜单最下边是否有Package Settings 和Package Control两个选项，如果有，则代表安装成功了。 此时使用快捷键control+shift+p，输入ip，选择Package Control: Install Package，回车，等一会，之后想安装什么插件，在里面搜索名字就可以了。 注意点： 需要注意的一点是，经常会出现网络联不通的情况，不要着急，这个很正常，如果出现，隔一会再弄，一般都会好的。]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[tinypng的使用]]></title>
      <url>http://fengqingxiuyi.xyz/%E5%9F%BA%E6%9C%AC%E5%B7%A5%E5%85%B7/%E5%9B%BE%E7%89%87%E5%8E%8B%E7%BC%A9/tinypng/tinypng%E7%9A%84%E4%BD%BF%E7%94%A8.html</url>
      <content type="html"><![CDATA[注：本文所属基本工具-图片压缩-tinypng，本文介绍一个在使用tinypng过程中的小技巧。 类型：在线压缩png图片，当然也支持jpg图片的压缩。 网址：https://tinypng.com/ 压缩方式： 普通压缩方式：根据页面的提示 Drop 或 Open 压缩技巧：首先执行 普通压缩方式 一次，然后如果想要持续压缩，不需要将图片下载下来，再执行 普通压缩方式 ，只需要 鼠标悬浮在含有下划线的download字样上，变成手势模样，垂直向下拖拽1厘米即可再次压缩，具体使用看图：]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[抽离模块注意点]]></title>
      <url>http://fengqingxiuyi.xyz/ShowJoy/%E6%A8%A1%E5%9D%97/%E6%8A%BD%E7%A6%BB%E6%A8%A1%E5%9D%97%E6%B3%A8%E6%84%8F%E7%82%B9.html</url>
      <content type="html"><![CDATA[注：本文所属ShowJoy-模块，本文讲述在将主模块或者是子模块的抽离流程，注意点持续更新… 注意点1模块抽离，除了要删除不需要的文件外，最重要的是不要更改【java文件root路径】，一旦修改了，一定要记得修改Androidmanifest.xml中引用的Activity等基本组件的路径 例如： Guide模块 包名：com.showjoy.shop.guidejava文件root路径：com.showjoy.shop.module.guide —————我是分割线————— 主模块 包名：com.showjoy.shopAndroidmanifest.xml中GuideActivity的引用路径为：.module.guide.GuideActivity]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[模块版本更新流程]]></title>
      <url>http://fengqingxiuyi.xyz/ShowJoy/%E6%A8%A1%E5%9D%97/%E6%A8%A1%E5%9D%97%E7%89%88%E6%9C%AC%E6%9B%B4%E6%96%B0%E6%B5%81%E7%A8%8B.html</url>
      <content type="html"><![CDATA[注：本文所属ShowJoy-模块，本文讲述在将主模块或者是子模块的版本更新流程，案例持续更新… 案例1工程中包含主模块、子模块A、子模块B，其中主模块依赖子模块A和子模块B，子模块A也依赖子模块B。现在子模块B发现了Bug，需要解决Bug并更新版本。 注意点当子模块B更新版本后，提交到Gitlab，并使用Jenkins成功构建后，我们不需要更新 子模块A 中 子模块B 的版本，只需要更新 主模块 中 子模块B 的版本，如果出现版本冲突，比如说现在 主模块 依赖 子模块A ，主模块 又依赖了 新子模块B 的版本，只需要把不必要的版本依赖 剔除 即可 主要原理工程 Build 后，一个模块只会存在一个版本，否则就会出现版本依赖冲突！！！ 案例2工程中包含主模块、子模块A、子模块B，其中主模块依赖子模块A和子模块B，子模块B又依赖子模块A。此时子模块A改变了内容，需要版本更新，同时也涉及到了子模块B中的某些改动。 注意点此时当子模块A更新版本后，同时需要更改子模块B依赖的子模块A的版本，同时也需要更新子模块B的版本，并进行项目构建。 主要原理如果不更改子模块B依赖的子模块A的版本，那么子模块B将编译不过。]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Iterable和Iterator的区别]]></title>
      <url>http://fengqingxiuyi.xyz/Python/Iterable%E5%92%8CIterator%E7%9A%84%E5%8C%BA%E5%88%AB.html</url>
      <content type="html"><![CDATA[注：本文所属Python，本文转载自教程廖雪峰-Python教程-迭代器 我们已经知道，可以直接作用于for循环的数据类型有以下几种：一类是集合数据类型，如list、tuple、dict、set、str等；一类是generator，包括生成器和带yield的generator function。这些可以直接作用于for&lt;/code&gt;循环的对象统称为可迭代对象：Iterable。可以使用isinstance()判断一个对象是否是Iterable对象：&gt;&gt;&gt; from collections import Iterable&gt;&gt;&gt; isinstance([], Iterable)True&gt;&gt;&gt; isinstance({}, Iterable)True&gt;&gt;&gt; isinstance(&#39;abc&#39;, Iterable)True&gt;&gt;&gt; isinstance((x for x in range(10)), Iterable)True&gt;&gt;&gt; isinstance(100, Iterable)False而生成器不但可以作用于for循环，还可以被next()函数不断调用并返回下一个值，直到最后抛出StopIteration错误表示无法继续返回下一个值了。可以被next()函数调用并不断返回下一个值的对象称为迭代器：Iterator。可以使用isinstance()判断一个对象是否是Iterator对象：&gt;&gt;&gt; from collections import Iterator&gt;&gt;&gt; isinstance((x for x in range(10)), Iterator)True&gt;&gt;&gt; isinstance([], Iterator)False&gt;&gt;&gt; isinstance({}, Iterator)False&gt;&gt;&gt; isinstance(&#39;abc&#39;, Iterator)False生成器都是Iterator对象，但list、dict、str虽然是Iterable，却不是Iterator。把list、dict、str等Iterable变成Iterator可以使用iter()函数：&gt;&gt;&gt; isinstance(iter([]), Iterator)True&gt;&gt;&gt; isinstance(iter(&#39;abc&#39;), Iterator)True你可能会问，为什么list、dict、str等数据类型不是Iterator？这是因为Python的Iterator对象表示的是一个数据流，Iterator对象可以被next()函数调用并不断返回下一个数据，直到没有数据时抛出StopIteration错误。可以把这个数据流看做是一个有序序列，但我们却不能提前知道序列的长度，只能不断通过next()函数实现按需计算下一个数据，所以Iterator的计算是惰性的，只有在需要返回下一个数据时它才会计算。Iterator甚至可以表示一个无限大的数据流，例如全体自然数。而使用list是永远不可能存储全体自然数的。小结凡是可作用于for循环的对象都是Iterable类型；凡是可作用于next()函数的对象都是Iterator类型，它们表示一个惰性计算的序列；集合数据类型如list、dict、str等是Iterable但不是Iterator，不过可以通过iter()函数获得一个Iterator对象。Python的for循环本质上就是通过不断调用next()函数实现的，例如：for x in [1, 2, 3, 4, 5]: pass实际上完全等价于：# 首先获得Iterator对象:it = iter([1, 2, 3, 4, 5])# 循环:while True: try: # 获得下一个值: x = next(it) except StopIteration: # 遇到StopIteration就退出循环 break参考源码do_iter.py]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[ShowJoy开发记录]]></title>
      <url>http://fengqingxiuyi.xyz/ShowJoy/ShowJoy%E5%BC%80%E5%8F%91%E8%AE%B0%E5%BD%95.html</url>
      <content type="html"><![CDATA[注：本文所属ShowJoy，本文主要介绍自己在尚妆网公司开发过程中遇到的值得注重的部分，本文持续更新… 未编写部分的地方都使用了 // TODO 来进行占位。 主要包括：常用命令、注意事项、杂七杂八。 常用命令Gradle命令输入位置：AndroidStudio-Terminal gradle –stop标题中的命令错误：应该为gradle --stop，注意是两个-符号！！！ 作用：可以快速停止 gradle 启动的进程。 gradle shopandroid:dependencies &gt; dependencies.txt解释shopandroid：想要查找依赖关系的模块名（ModuleName） dependencies.txt：要将输出的依赖关系保存的文件位置，包括文件名，如果只写文件名，表示保存在当前目录下的 该文件 中。 作用生成shopandroid模块的依赖关系，并保存在当前文件夹下的dependencies.txt中。 例子1234$ gradle shopandroid:dependencies &gt; dependencies.txt$ pwd/Volumes/MAIN/qingfeng/Workspace/ShopAndroid$ 说明dependencies.txt文件的保存位置是：/Volumes/MAIN/qingfeng/Workspace/ShopAndroid/dependencies.txt Adbadb shell dumpsys activity | grep mFocusedActivity作用：获取真机显示页面的Activity的名称。 adb logcat -d &gt; logcat.txt作用：保存打印的logcat信息到当前目录下的logcat.txt文件中。 adb pull sdcard/shop-crash作用：将SD卡根目录下的shop-crash文件夹导出到当前目录中，当然也可以导出文件。 例子：导出手机中的shop-crash文件：打开终端后，首先进入电脑桌面目录，即cd /Desktop，然后使用上述命令回车即可。 Linuxfind使用格式：find [指定查找目录] [查找规则] [查找完后执行的action] 相关网址： linux下find（文件查找）命令的用法总结 Linux find 用法示例 find . -name “._*” |xargs rm -rf作用：快速删除当前目录下包含以._开头的所有文件 解释： 第一个.符号代表的是当前路径，所以该位置参数的意义是路径名； -name符号代表的是根据文件名精确查找，如果想要忽略大小写，可以改为-iname； &quot;._*&quot;符号代表的是找到所有以._开头的文件，*符号是通配符，所以该位置参数的意义是要寻找的文件的过滤规则； rm -rf符号代表的是强制删除。 注意事项混淆文件位置以 CharityShopAndroid 项目为例：混淆文件仅在主模块（charityshopandroid）的根目录下，如果是debug状态下，使用的混淆文件是debug_proguard-rules.pro；如果是release状态下，使用的混淆文件是proguard-rules.pro。 mapping.txt在友盟中查看错误日志时，因为混淆了，所以我们需要找到对应版本的mapping文件来解读，但是有时候由于在版本迭代过程中更改内容不是特别多，所以重新切出对应版本的release分支，这样会导致我们在Jenkins查找指定版本的mapping文件时，无法立刻找到。对于此问题，我们需要做以下操作： 在Gitlab上找到指定版本对应的release分支，并记住推送到服务器的时间； 在Jenkins中找到该release分支项目中，在构建历史中根据之前记住的服务器时间来查找。 实际案例：ShopAndroid项目的1.3.0-1.3.5版本都是在release/1.3.0分支上构建的。 Gitlab地址：http://git.showjoy.net/shopandroid/shopandroid/commits/release/1.3.0 Jenkins地址：https://wireless-build.showjoy.net/view/达人店/job/ShopAndroid-release-1.3.0/ Instant Run因为 Instant Run 不支持混淆，所以在调试运行的时候，生成APK内包含的方法数就很有很大几率超过65536。 这个时候可以在 AndroidStudio 的设置页面关闭 Instant Run ，即不勾选enable，再调试运行，就会混淆代码，从而减少方法数。 如果即使混淆了，方法数还是超过65536，这个时候，就需要dex分包处理了。 修改子模块流程 子模块新拉分支A 子模块依赖改为本地模块 编写代码，自测成功 上传代码到分支A 告诉评审人员 分支A名称 进行评审 评审有问题，回到第3步 评审通过后，将代码合并到master分支，而不是拉取（合并的方法是，先合并master代码到分支A, 自测成功。再将分支A的代码合并到master） 修改master分支的版本，Jenkins项目构建，打tag并push 开发自测流程以“图片压缩支持webp”为例，项目开发完成之后，需要测试压缩成webp格式的图片 和 原先的图片 在 大小和体验上有没有向好的方向转化：如果有的话，告诉评审人员，通过后提交并合并到master；如果没有的话，告诉评审人员，通过的话直接Revert就行了。 Gradle - Compile例子比较下面两个语句块的不同 1compile ('com.showjoy.shop:common:1.3.4') 123compile ('com.showjoy.shop:common:1.3.4') &#123; transitive false&#125; 简要解释 com.showjoy.shop：即groupId：是项目或者组织的唯一标志，并且配置时生成的路径也是由此生成，如com.showjoy.shop生成的相对路径为：/com/showjoy/shop； common：即artifactId：项目的通用名称； 1.3.4：即version：项目的版本。 上述解释内容都是配置在maven仓库的pom配置文件中的，此模块配置文件地址：http://192.168.0.62:8081/repository/maven-releases/com/showjoy/shop/common/1.3.4/common-1.3.4.pom，因为是内网才可以访问的，这里我就展示一下主要部分： 1234567891011121314151617181920212223242526272829303132333435&lt;?xml version="1.0"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.showjoy.shop&lt;/groupId&gt; &lt;artifactId&gt;common&lt;/artifactId&gt; &lt;version&gt;1.3.4&lt;/version&gt; &lt;packaging&gt;aar&lt;/packaging&gt; &lt;name&gt;shopandroid_common&lt;/name&gt; &lt;description&gt;Uploads all artifacts belonging to configuration ':shopandroid_common:archives'&lt;/description&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;com.showjoy.android&lt;/groupId&gt; &lt;artifactId&gt;storage&lt;/artifactId&gt; &lt;version&gt;1.0.8&lt;/version&gt; &lt;scope&gt;compile&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.showjoy.network&lt;/groupId&gt; &lt;artifactId&gt;library&lt;/artifactId&gt; &lt;version&gt;1.1.14&lt;/version&gt; &lt;scope&gt;compile&lt;/scope&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;artifactId&gt;support-annotations&lt;/artifactId&gt; &lt;groupId&gt;com.android.support&lt;/groupId&gt; &lt;/exclusion&gt; &lt;exclusion&gt; &lt;artifactId&gt;utils-log&lt;/artifactId&gt; &lt;groupId&gt;com.showjoy.android&lt;/groupId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt; ... &lt;/dependencies&gt;&lt;/project&gt; 备注：exclusions是可选的，在上述文件中可知：storage模块没有排除任何依赖；library模块排除了support-annotations模块和utils-log模块。 字段详细解释可以查看该网址：http://zyl.iteye.com/blog/41754 字段详细解释：// TODO 解答前者：当我们依赖了common模块的时候，还会传递依赖common所依赖的模块。 后者：当我们依赖了common模块的时候，不会传递依赖common所依赖的所有模块。 疑问如果我们并不想要排除所有的common所依赖的模块，只想要依赖排除某个或者某几个common所依赖的模块，又该如何呢？ 解答12345compile ('com.showjoy.shop:common:1.3.4') &#123; exclude group: 'com.showjoy.shop', module: 'viewgroup' exclude group: 'com.showjoy.shop', module: 'share' ...&#125; 如上所示： 如果想要排除common依赖的viewgroup模块，只需要写这么一句话就行了：exclude group: ‘com.showjoy.shop’, module: ‘viewgroup’； 如果还想要排除share，也可以依样画葫芦，注意填写正确的groupId和moduleName。 为什么要排除依赖我们从上往下看： 对于某一个模块，一个项目只允许存在一个版本； 一个项目可能依赖很多个模块，每个模块可能依赖相同的子模块，但是版本号可能不同； 如果不管不顾，就会有版本冲突，因为第1点，所以需要排除依赖，最终只留下一个版本。 杂七杂八KPI中要求的输出文档位置：http://git.showjoy.net/showjoywireless/showjoywireless_doc/tree/master/android]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[输入法的显示与隐藏]]></title>
      <url>http://fengqingxiuyi.xyz/Android/Wiki/%E8%BE%93%E5%85%A5%E6%B3%95%E7%9A%84%E6%98%BE%E7%A4%BA%E4%B8%8E%E9%9A%90%E8%97%8F.html</url>
      <content type="html"><![CDATA[注：本文所属Android-Wiki，本文主要介绍关于输入法的显示与隐藏相关方法与判断方式。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253import android.content.Context;import android.view.inputmethod.InputMethodManager;import android.widget.EditText;/** * Created by qingfeng on 16/9/19. */public class InputMethodUtils &#123; /** * 切换软键盘的状态 * 如当前为收起变为弹出,若当前为弹出变为收起 */ public static void toggleInput(EditText edittext) &#123; InputMethodManager inputMethodManager = (InputMethodManager) edittext.getContext().getSystemService(Context.INPUT_METHOD_SERVICE); inputMethodManager.toggleSoftInput(0, InputMethodManager.HIDE_NOT_ALWAYS); &#125; /** * 强制隐藏输入法键盘 */ public static void hideInput(EditText edittext) &#123; InputMethodManager inputMethodManager = (InputMethodManager) edittext.getContext().getSystemService(Context.INPUT_METHOD_SERVICE); if (inputMethodManager.isActive()) &#123; inputMethodManager.hideSoftInputFromWindow(edittext.getWindowToken(), 0); &#125; &#125; /** * 强制显示输入法键盘 */ public static void showInput(EditText edittext) &#123; InputMethodManager inputMethodManager = (InputMethodManager) edittext.getContext().getSystemService(Context.INPUT_METHOD_SERVICE); inputMethodManager.showSoftInput(edittext, InputMethodManager.SHOW_FORCED); &#125; /** * 输入法是否显示 */ public static boolean isShow(EditText edittext) &#123; boolean bool = false; InputMethodManager inputMethodManager = (InputMethodManager) edittext.getContext().getSystemService(Context.INPUT_METHOD_SERVICE); if (inputMethodManager.isActive()) &#123; bool = true; &#125; return bool; &#125;&#125;]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[复制粘贴文本的三种类型]]></title>
      <url>http://fengqingxiuyi.xyz/Android/Wiki/%E5%A4%8D%E5%88%B6%E7%B2%98%E8%B4%B4%E6%96%87%E6%9C%AC%E7%9A%84%E4%B8%89%E7%A7%8D%E7%B1%BB%E5%9E%8B.html</url>
      <content type="html"><![CDATA[注：本文所属Android-Wiki，本文主要介绍复制粘贴文本的三种类型：text／Uri／Intent。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182import android.content.ClipData;import android.content.ClipDescription;import android.content.ClipboardManager;import android.content.Context;import android.content.Intent;import android.net.Uri;/** * Created by qingfeng on 16/9/8. */public class SHTextUtils &#123; /** * 复制 -&gt; 类型一: text */ public static void copy(Context context, String text) &#123; ClipboardManager clipboard = (ClipboardManager) context.getSystemService(Context.CLIPBOARD_SERVICE); ClipData textCd = ClipData.newPlainText("text", text); clipboard.setPrimaryClip(textCd); &#125; /** * 粘贴 -&gt; 类型一: text */ public static CharSequence pasteText(Context context) &#123; ClipboardManager clipboard = (ClipboardManager) context.getSystemService(Context.CLIPBOARD_SERVICE); if (clipboard.getPrimaryClipDescription().hasMimeType(ClipDescription.MIMETYPE_TEXT_PLAIN)) &#123; ClipData cdText = clipboard.getPrimaryClip(); // 此处是 text ClipData.Item item = cdText.getItemAt(0); return item.getText(); &#125; return null; &#125; /** * 复制 -&gt; 类型二: Uri */ public static void copy(Context context, Uri uri) &#123; ClipboardManager clipboard = (ClipboardManager) context.getSystemService(Context.CLIPBOARD_SERVICE); ClipData clipUri = ClipData.newUri(context.getContentResolver(), "Uri", uri); clipboard.setPrimaryClip(clipUri); &#125; /** * 粘贴 -&gt; 类型二: Uri */ public static Uri pasteUri(Context context) &#123; ClipboardManager clipboard = (ClipboardManager) context.getSystemService(Context.CLIPBOARD_SERVICE); if (clipboard.getPrimaryClipDescription().hasMimeType(ClipDescription.MIMETYPE_TEXT_URILIST)) &#123; ClipData cdUri = clipboard.getPrimaryClip(); // 此处是 Uri ClipData.Item item = cdUri.getItemAt(0); return item.getUri(); &#125; return null; &#125; /** * 复制 -&gt; 类型三: Intent */ public static void copy(Context context, Intent intent) &#123; ClipboardManager clipboard = (ClipboardManager) context.getSystemService(Context.CLIPBOARD_SERVICE); ClipData clipIntent = ClipData.newIntent("Intent", intent); clipboard.setPrimaryClip(clipIntent); &#125; /** * 粘贴 -&gt; 类型三: Intent */ public static Intent pasteIntent(Context context) &#123; ClipboardManager clipboard = (ClipboardManager) context.getSystemService(Context.CLIPBOARD_SERVICE); if (clipboard.getPrimaryClipDescription().hasMimeType(ClipDescription.MIMETYPE_TEXT_INTENT)) &#123; ClipData cdIntent = clipboard.getPrimaryClip(); // 此处是 Intent ClipData.Item item = cdIntent.getItemAt(0); return item.getIntent(); &#125; return null; &#125;&#125;]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[摄像头是否可用]]></title>
      <url>http://fengqingxiuyi.xyz/Android/Wiki/%E6%91%84%E5%83%8F%E5%A4%B4%E6%98%AF%E5%90%A6%E5%8F%AF%E7%94%A8.html</url>
      <content type="html"><![CDATA[注：本文所属Android-Wiki，本文主要介绍如何判断摄像头是否可用，并兼容处理MX5的某些bug。 123456789101112131415161718192021222324252627282930313233import android.hardware.Camera;/** * Created by qingfeng on 16/9/19. */public class CameraUtils &#123; /** * 判断摄像头是否可用 * * @return */ public static boolean isCameraCanUse() &#123; boolean canUse = true; Camera mCamera = null; try &#123; mCamera = Camera.open(); // setParameters 是针对魅族MX5 做的。MX5 通过Camera.open() 拿到的Camera // 对象不为null Camera.Parameters mParameters = mCamera.getParameters(); mCamera.setParameters(mParameters); &#125; catch (Exception e) &#123; canUse = false; &#125; if (mCamera != null) &#123; mCamera.release(); &#125; return canUse; &#125;&#125;]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[文件的基本操作]]></title>
      <url>http://fengqingxiuyi.xyz/Android/Wiki/%E6%96%87%E4%BB%B6%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C.html</url>
      <content type="html"><![CDATA[注：本文所属Android-Wiki，本文主要封装了一些文件操作的基本方法，包括创建、删除、获取文件大小等。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140import android.content.Context;import android.graphics.Bitmap;import android.os.Environment;import android.util.Log;import java.io.File;import java.io.FileOutputStream;import java.io.IOException;/** * 主要封装了一些文件操作的基本方法，包括创建、删除、获取文件大小等。 * * Created by qingfeng on 16/9/9. */public class FileUtils &#123; private static final String TAG = "FileUtils"; /** * 检查是否存在SD卡 * * @return */ public static boolean hasSdcard() &#123; String state = Environment.getExternalStorageState(); if (state.equals(Environment.MEDIA_MOUNTED)) &#123; return true; &#125; else &#123; return false; &#125; &#125; /** * 创建目录 * * @param context * @param dirName 文件夹名称 * @return */ public static File createFileDir(Context context, String dirName) &#123; String filePath; // 如SD卡已存在，则存储；反之存在data目录下 if (hasSdcard()) &#123; // SD卡路径 filePath = Environment.getExternalStorageDirectory() + File.separator + dirName; &#125; else &#123; filePath = context.getCacheDir().getPath() + File.separator + dirName; &#125; File destDir = new File(filePath); if (!destDir.exists()) &#123; boolean isCreate = destDir.mkdirs(); Log.i(TAG, filePath + " has created. " + isCreate); &#125; return destDir; &#125; /** * 删除文件（若为目录，则递归删除子目录和文件） * * @param file * @param delThisPath true代表删除参数指定file，false代表保留参数指定file */ public static void delFile(File file, boolean delThisPath) &#123; if (!file.exists()) &#123; return; &#125; if (file.isDirectory()) &#123; File[] subFiles = file.listFiles(); if (subFiles != null) &#123; int num = subFiles.length; // 删除子目录和文件 for (int i = 0; i &lt; num; i++) &#123; delFile(subFiles[i], true); &#125; &#125; &#125; if (delThisPath) &#123; file.delete(); &#125; &#125; /** * 获取文件大小，单位为byte（若为目录，则包括所有子目录和文件） * * @param file * @return */ public static long getFileSize(File file) &#123; long size = 0; if (file.exists()) &#123; if (file.isDirectory()) &#123; File[] subFiles = file.listFiles(); if (subFiles != null) &#123; int num = subFiles.length; for (int i = 0; i &lt; num; i++) &#123; size += getFileSize(subFiles[i]); &#125; &#125; &#125; else &#123; size += file.length(); &#125; &#125; return size; &#125; /** * 保存Bitmap到指定目录 * * @param dir 目录 * @param fileName 文件名 * @param bitmap * @throws IOException */ public static void saveBitmap(File dir, String fileName, Bitmap bitmap) &#123; if (bitmap == null) &#123; return; &#125; File file = new File(dir, fileName); try &#123; file.createNewFile(); FileOutputStream fos = new FileOutputStream(file); bitmap.compress(Bitmap.CompressFormat.JPEG, 100, fos); fos.flush(); fos.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; /** * 判断某目录下文件是否存在 * * @param dir 目录 * @param fileName 文件名 * @return */ public static boolean isFileExists(File dir, String fileName) &#123; return new File(dir, fileName).exists(); &#125;&#125;]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[scrollbarStyle详解]]></title>
      <url>http://fengqingxiuyi.xyz/Android/View/ScrollView/scrollbarStyle%E8%AF%A6%E8%A7%A3.html</url>
      <content type="html"><![CDATA[注：本文所属Android-View-ScrollView，对于scrollbarStyle的属性值进行详细解释。 android:scrollbarStyle属性及滚动条和分割线覆盖问题 android:scrollbarStyle可以定义滚动条的样式和位置，可选值有insideOverlay、insideInset、outsideOverlay、outsideInset四种。 其中inside和outside分别表示是否在view的padding区域内，overlay和inset表示覆盖在view上或是插在view后面，所以四种值分别表示： insideOverlay：默认值，表示在padding区域内并且覆盖在view上 insideInset：表示在padding区域内并且插入在view后面 outsideOverlay：表示在padding区域外并且覆盖在view上，推荐这个 outsideInset：表示在padding区域外并且插入在view后面 分别对应效果如下图：]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[设置滚动条样式]]></title>
      <url>http://fengqingxiuyi.xyz/Android/View/ScrollView/%E8%AE%BE%E7%BD%AE%E6%BB%9A%E5%8A%A8%E6%9D%A1%E6%A0%B7%E5%BC%8F.html</url>
      <content type="html"><![CDATA[注：本文所属Android-View-ScrollView，用于介绍如何设置滚动条的大小／方向／位置／颜色。 1234567891011&lt;ScrollView android:layout_width="match_parent" android:layout_height="wrap_content" android:layout_marginBottom="30dp" android:layout_marginTop="10dp" android:fadeScrollbars="false" android:paddingLeft="46dp" android:paddingRight="46dp" android:scrollbarSize="2dp" android:scrollbarStyle="outsideOverlay" android:scrollbarThumbVertical="@color/white"/&gt; scrollbarSize: 设置滚动条大小，垂直时指宽度，水平时指高度 scrollbarStyle: 设置滚动条位置，详见scrollbarStyle详解 scrollbarThumbVertical: 设置滚动条颜色]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[永久显示滚动条]]></title>
      <url>http://fengqingxiuyi.xyz/Android/View/ScrollView/%E6%B0%B8%E4%B9%85%E6%98%BE%E7%A4%BA%E6%BB%9A%E5%8A%A8%E6%9D%A1.html</url>
      <content type="html"><![CDATA[注：本文所属Android-View-ScrollView，在xml布局文件中设置如何永久显示滚动条。 1234567891011&lt;ScrollView android:layout_width="match_parent" android:layout_height="wrap_content" android:layout_marginBottom="30dp" android:layout_marginTop="10dp" android:fadeScrollbars="false" android:paddingLeft="46dp" android:paddingRight="46dp" android:scrollbarSize="2dp" android:scrollbarStyle="outsideOverlay" android:scrollbarThumbVertical="@color/white"/&gt; android:fadeScrollbars=”false”: 永久显示滚动条]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[自定义View开源项目]]></title>
      <url>http://fengqingxiuyi.xyz/Android/View/%E8%87%AA%E5%AE%9A%E4%B9%89View/%E8%87%AA%E5%AE%9A%E4%B9%89View%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE.html</url>
      <content type="html"><![CDATA[注：本文所属Android-View-自定义View，用于记录一些自己用过的View类的开源项目。 GridView with Header and Footer项目地址：https://github.com/liaohuqiu/android-GridViewWithHeaderAndFooter 项目简介：即标题所示含义，使GridView支持addHeader和addFooter 遇到问题：业务要求，支持文字长按出现ActionMode，即 全选、复制、剪切…弹框，我以TextView的形式，配置属性android:textIsSelectable=&quot;true&quot;，将其添加到Header之后，长按无反应；然后以EditText的形式，将其添加到Header之后，长按仍无反应；最后发现是焦点抢占的缘故，不过没有成功解决。 Android单点触控技术项目地址：http://blog.csdn.net/xiaanming/article/details/42833893 项目简介：Android单点触控技术，对图片进行平移，缩放，旋转操作 项目优点：注释详细，解读方便；支持多种选项配置；支持其他选项的自定义配置（如：控制图标的显示、边框的显示等）。 项目不足之处：很难支持View是否旋转，暂未实现；很难支持View是否滑出显示区域，暂未实现。]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[外网无法编译]]></title>
      <url>http://fengqingxiuyi.xyz/Android/Android%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/Gradle/%E5%A4%96%E7%BD%91%E6%97%A0%E6%B3%95%E7%BC%96%E8%AF%91.html</url>
      <content type="html"><![CDATA[注：本文所属Android-Android开发工具-Gradle，用于解决从公司回家办公时，一直处于build中的问题。 大部分情况下，我们开发项目都是在公司中完成的，但是总会有需要在家里开发的时候。这个时候，如果你们公司的项目需要连接公司专有的maven仓库等链接地址，那么久可能会遇到无法编译的问题，具体表现为：一直处于编译中，无法正常停止。然后我们就可以配置选项来解决这个问题，具体看下图： 如果你也是因为这个原因导致这样的问题的话，那就幸运了！如果不是，那我只能Good Luck！]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[微信分享-错误锦集]]></title>
      <url>http://fengqingxiuyi.xyz/Android/%E5%BE%AE%E4%BF%A1/%E5%88%86%E4%BA%AB/%E5%BE%AE%E4%BF%A1%E5%88%86%E4%BA%AB-%E9%94%99%E8%AF%AF%E9%94%A6%E9%9B%86.html</url>
      <content type="html"><![CDATA[注：本文所属Android-微信-分享，本文主要介绍自己在使用微信SDK过程遇到的一些坑，本文持续更新… 微信分享-分享链接12345678910111213141516171819WXWebpageObject webpage = new WXWebpageObject();webpage.webpageUrl = result.link;WXMediaMessage msg = new WXMediaMessage(webpage);msg.title = result.title;msg.description = result.desc;msg.thumbData = thumbData;SendMessageToWX.Req req = new SendMessageToWX.Req();req.transaction = buildTransaction("webpage");req.message = msg;if (share2WX) &#123; req.scene = SendMessageToWX.Req.WXSceneSession; // 分享到微信&#125; else &#123; req.scene = SendMessageToWX.Req.WXSceneTimeline; // 分享到朋友圈&#125;IWXAPI msgApi = getApi(context, APP_ID);msgApi.sendReq(req); 注意：sendReq方法是有返回值的，返回值类型为boolean，如果返回false，则表明分享失败，返回true，则表明分享成功。 案例：达人店1.0.2.2版本 分享店铺-分享到微信好友 经常调不出微信页面，导致分享失败，但是 商品详情页-分享商品 正常。 分析：经过对比发现，只有 thumbData 即 图片 有 大小 的差异，经过Logcat发现 前者 分享图片是用户头像，浏览器打开显示图片大小约为700k，后者 分享图片是商品图，浏览器打开显示图片大小约为150k，所以可以得出分享到微信是图片大小限制的。注意：浏览器打开显示图片的大小并非为thumbData的大小。 解决：通过 谷歌 百度 得知 thumbData 不能大于 32k，我们只要以此压缩图片就行了。 相关链接：官方FAQ：https://open.weixin.qq.com/cgi-bin/showdocument?action=dir_list&amp;t=resource/res_list&amp;verify=1&amp;id=open1419318060&amp;token=&amp;lang=zh_CN 解决微信分享图片，网址失效的Bug – 不完美解决：http://blog.csdn.net/h3c4lenovo/article/details/10103057]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[保存图片到相册]]></title>
      <url>http://fengqingxiuyi.xyz/Android/%E5%9B%BE%E7%89%87/%E7%9B%B8%E5%86%8C/%E4%BF%9D%E5%AD%98%E5%9B%BE%E7%89%87%E5%88%B0%E7%9B%B8%E5%86%8C.html</url>
      <content type="html"><![CDATA[注：本文所属Android-图片-相册，本文主要介绍保存图片到相册的几种方式。 序本文讲述如何保存图片到相册： 其本质上并没有把图片保存到相册中，实际上是保存在SD卡下自定义的文件夹中，目的只是让QQ和微信在选择照片的时候立刻显示，注：其实QQ和微信也是这样做的。 另外：这里参数只接受File类型，对于Bitmap类型，可以自行转化，如下代码： 123456789101112131415161718192021File file = new File(parentDir, fileName);FileOutputStream fos = null;try &#123; fos = new FileOutputStream(file); bmp.compress(Bitmap.CompressFormat.JPEG, 100, fos); fos.flush();&#125; catch (IOException e) &#123; LogUtils.e(e);&#125; finally &#123; // 回收bitmap bmp.recycle(); if (null != fos) &#123; try &#123; fos.close(); &#125; catch (IOException e1) &#123; e1.printStackTrace(); &#125; &#125;&#125; 保存方式方式1-扫描文件通知相册更新12345// 通知相册更新Intent intent = new Intent(Intent.ACTION_MEDIA_SCANNER_SCAN_FILE);Uri uri = Uri.fromFile(file);intent.setData(uri);context.sendBroadcast(intent); 方式1-错误操作1234567MediaStore.Images.Media.insertImage(context.getContentResolver(), file.getAbsolutePath(), "name", "description");// 通知相册更新Intent intent = new Intent(Intent.ACTION_MEDIA_SCANNER_SCAN_FILE);Uri uri = Uri.fromFile(file);intent.setData(uri);context.sendBroadcast(intent); 对比 方式1 和 错误方式 ，我们可以发现其实就是多了一行insertImage的代码，然后就不能被QQ和微信立刻识别了，好伤心~~ 这里我稍微研究了一下，然而没有发现本质原因，不过做了以下猜测，有兴趣的可以自行研究源码。 因为在使用ACTION_MEDIA_SCANNER_SCAN_FILE方式通知相册更新时，也需要执行类似insertImage方法内部的某些操作，可能和ContentProvider相关的数据库有关，所以如果你先执行了insertImage方法，那么它在接收到这个ACTION_MEDIA_SCANNER_SCAN_FILE广播的时候，做了如下判断：如果已经执行了insertImage方法，那么return;，所以不会执行再通知相册更新了。 方式2-完整操作123456789101112// 插入file数据到相册ContentValues values = new ContentValues(9);values.put(MediaStore.Images.Media.TITLE, "Camera");values.put(MediaStore.Images.Media.DISPLAY_NAME, filename);values.put(MediaStore.Images.Media.DATE_TAKEN, System.currentTimeMillis());values.put(MediaStore.Images.Media.MIME_TYPE, "image/jpeg");values.put(MediaStore.Images.Media.ORIENTATION, 0);values.put(MediaStore.Images.Media.DATA, file.getAbsolutePath());values.put(MediaStore.Images.Media.SIZE, file.length());Uri uri = context.getContentResolver().insert(MediaStore.Images.Media.EXTERNAL_CONTENT_URI, values);// 通知相册更新context.sendBroadcast(new Intent("com.android.camera.NEW_PICTURE", uri)); 方式2-简单操作1234567// 插入file数据到相册ContentValues values = new ContentValues();values.put(MediaStore.Images.Media.DATA, file.getAbsolutePath());values.put(MediaStore.Images.Media.MIME_TYPE, "image/jpeg");Uri uri = context.getContentResolver().insert(MediaStore.Images.Media.EXTERNAL_CONTENT_URI, values);// 通知相册更新context.sendBroadcast(new Intent("com.android.camera.NEW_PICTURE", uri)); 总结对于Google和百度出来的Android保存图片到相册表示无奈，90%以上都是一样的，这个时候如果我们还是依靠搜索，消耗的成本是很大的，如果你能够从源码入手，可能就会给你提供一些思路，例如：上述所说的方式2就是从insertImage方法中得出的，源码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657/** * Insert an image and create a thumbnail for it. * * @param cr The content resolver to use * @param source The stream to use for the image * @param title The name of the image * @param description The description of the image * @return The URL to the newly created image, or &lt;code&gt;null&lt;/code&gt; if the image failed to be stored * for any reason. */public static final String insertImage(ContentResolver cr, Bitmap source, String title, String description) &#123; ContentValues values = new ContentValues(); values.put(Images.Media.TITLE, title); values.put(Images.Media.DESCRIPTION, description); values.put(Images.Media.MIME_TYPE, "image/jpeg"); Uri url = null; String stringUrl = null; /* value to be returned */ try &#123; url = cr.insert(EXTERNAL_CONTENT_URI, values); if (source != null) &#123; OutputStream imageOut = cr.openOutputStream(url); try &#123; source.compress(Bitmap.CompressFormat.JPEG, 50, imageOut); &#125; finally &#123; imageOut.close(); &#125; long id = ContentUris.parseId(url); // Wait until MINI_KIND thumbnail is generated. Bitmap miniThumb = Images.Thumbnails.getThumbnail(cr, id, Images.Thumbnails.MINI_KIND, null); // This is for backward compatibility. Bitmap microThumb = StoreThumbnail(cr, miniThumb, id, 50F, 50F, Images.Thumbnails.MICRO_KIND); &#125; else &#123; Log.e(TAG, "Failed to create thumbnail, removing original"); cr.delete(url, null, null); url = null; &#125; &#125; catch (Exception e) &#123; Log.e(TAG, "Failed to insert image", e); if (url != null) &#123; cr.delete(url, null, null); url = null; &#125; &#125; if (url != null) &#123; stringUrl = url.toString(); &#125; return stringUrl;&#125;]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[adb无线连接]]></title>
      <url>http://fengqingxiuyi.xyz/Android/Wiki/adb%E6%97%A0%E7%BA%BF%E8%BF%9E%E6%8E%A5.html</url>
      <content type="html"><![CDATA[注：本文所属Android-Wiki，用于实现adb无线连接。 序文中所述的5555为自定义的端口号，可自行配置，注意需要在各个地方保持统一。 情况1.如果已经可以用usb连接adb，那么可以通过以下命令切换到无线连接方式。 12adb tcpip 5555 # 5555为一个自定义的端口，只要与下一行命令的端口保持统一即可adb connect 192.168.0.101:5555 # 192.168.0.101为手机无线网络的ip地址 通过下面的命令可以切换回usb方式。 1adb usb 2.如果无法通过usb方式连接，比如因为没有驱动或没有数据线，那么可以在设备上执行以下命令，切换到无线连接方式。注意此方式需要root权限。 123setprop service.adb.tcp.port 5555stop adbdstart adbd 通过以下命令切换回usb方式。 123setprop service.adb.tcp.port -1stop adbdstart adbd 3.有一些第三方工具，把第二种方法做成了app，只要点一个按钮，就可以完成切换。比如adbWireless。此工具同样需要root权限。]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[模块封装流程]]></title>
      <url>http://fengqingxiuyi.xyz/ShowJoy/%E6%A8%A1%E5%9D%97/%E6%A8%A1%E5%9D%97%E5%B0%81%E8%A3%85%E6%B5%81%E7%A8%8B.html</url>
      <content type="html"><![CDATA[注：本文所属ShowJoy-模块，本文讲述在将主模块或者是子模块的封装流程。 1、打开http://git.showjoy.net/页面，点击右边Projects选项卡下的绿色按钮&quot;+ New project&quot;，如果没有该按钮需要申请权限。 2、点击&quot;+ New project&quot;按钮后会进入http://git.showjoy.net/projects/new页面，填写必要的Project name（如：test），可选的Description，选择正确的Namespace（如：qingfeng），最后点击&quot;Create project&quot;按钮。 3、点击&quot;Create project&quot;按钮后会进入http://git.showjoy.net/qingfeng/test页面，该页面会告诉你如何配置git参数，创建仓库以及代码的提交与推送。 这里我个人觉得http://git.showjoy.net/qingfeng/test页面描述的不够清晰，所以再简要描述一下操作流程： 3.1、安装git，可以查看这篇文章廖雪峰 git教程 3.2、打开终端，cd到Android Studio中某个已经存在的想要将某个（某些）模块push到远程仓库的工程根目录下，然后再cd到某个想要push到远程仓库的模块目录下。 3.3、输入以下命令，初始化git： 1git init 3.4、输入以下命令，查看git配置文件 1git config --list 3.4.1、配置user.name和user.email 如果没有配置user.name和user.email，或者想要修改这两个参数的，都可以执行以下命令： 12git config --global user.name "your name"git config --global user.email "your email" 3.4.2、配置remote.origin.url 如果没有remote.origin.url，可以使用以下命令，将本地仓库和远程仓库进行关联： 1git remote add origin git@git.showjoy.net:qingfeng/test.git 注意：git@git.showjoy.net:qingfeng/test.git在http://git.showjoy.net/qingfeng/test页面右上角 如果想要修改remote.origin.url的值，可以使用以下命令，重新赋值： 123456git remte origin set-url newUrl或git remote rm origingit remote add origin newUrl或直接修改config文件 3.5、输入以下命令，将本地已经存在的文件添加到git，并推送到远程仓库： 123git add .git commit -m 'first commit'git push -u origin master 3.6、为该模块添加README.md文件： 1234touch README.mdgit add README.mdgit commit -m '新增说明文档'git push -u origin master 3.7、全部正确执行后，就可以在Android Studio中正常开发了！ 因为我们的模块最终是要给其他模块提供坐标依赖（compile）的，所以需要在Jenkins上进行模块的构建，在模块构建之前我们需要配置一些参数： 4.1、工程参数配置 build.gradle文件： 1234567891011121314151617181920212223242526272829// Top-level build file where you can add configuration options common to all sub-projects/modules.buildscript &#123; repositories &#123; jcenter() &#125; dependencies &#123; classpath 'com.android.tools.build:gradle:2.1.2' // NOTE: Do not place your application dependencies here; they belong // in the individual module build.gradle files //支持java8的lambda classpath 'me.tatarka:gradle-retrolambda:3.2.5' classpath 'com.getkeepsafe.dexcount:dexcount-gradle-plugin:0.5.5' &#125;&#125;allprojects &#123; repositories &#123; //新增公司的maven库 maven &#123;url 'http://192.168.0.62:8081/repository/maven-snapshots/'&#125; maven &#123;url 'http://192.168.0.62:8081/repository/maven-releases/'&#125; jcenter() &#125;&#125;task clean(type: Delete) &#123; delete rootProject.buildDir&#125; gradle.properties文件： 123456789101112131415161718192021222324252627# Project-wide Gradle settings.# IDE (e.g. Android Studio) users:# Gradle settings configured through the IDE *will override*# any settings specified in this file.# For more details on how to configure your build environment visit# http://www.gradle.org/docs/current/userguide/build_environment.html# Specifies the JVM arguments used for the daemon process.# The setting is particularly useful for tweaking memory settings.# Default value: -Xmx10248m -XX:MaxPermSize=256m# org.gradle.jvmargs=-Xmx2048m -XX:MaxPermSize=512m -XX:+HeapDumpOnOutOfMemoryError -Dfile.encoding=UTF-8# When configured, Gradle will run in incubating parallel mode.# This option should only be used with decoupled projects. More details, visit# http://www.gradle.org/docs/current/userguide/multi_project_builds.html#sec:decoupled_projects# org.gradle.parallel=truesystemProp.minSdkVersion=14org.gradle.jvmargs=-XX\:MaxPermSize\=512msystemProp.targetSdkVersion=21org.gradle.daemon=truesystemProp.compileSdkVersion=23org.gradle.parallel=trueandroid.useDeprecatedNdk=truesystemProp.buildToolsVersion=23.0.2org.gradle.configureondemand=true 4.2、模块参数配置 build.gradle文件： 1234567891011121314151617181920apply plugin: 'com.android.library'dependencies &#123; compile fileTree(dir: 'libs', include: ['*.jar']) compile 'com.android.support:appcompat-v7:23.4.0' compile 'io.reactivex:rxjava:1.1.6' compile 'io.reactivex:rxandroid:1.1.0'&#125;version='1.0.2'description = 'showjoy compress library'ext.pom_packaging = 'aar'ext.pom_groupId = 'com.showjoy.image'ext.pom_artifactId = 'compress'ext.pom_name = 'showjoy_compress'ext.pom_snapshot = falseapply from :'http://git.showjoy.net/android/mvn-repo/raw/master/library.gradle' 5、根据业务需要更新模块代码，并执行commit和push等操作即可，完成模块的制作后，我们就可以在Jenkins上进行项目构建了，具体可以参考这篇文章：Jenkins项目构建过程详解]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[yield浅析]]></title>
      <url>http://fengqingxiuyi.xyz/Python/yield%E6%B5%85%E6%9E%90.html</url>
      <content type="html"><![CDATA[注：本文所属Python，本文对于IBM中廖雪峰老师的yield使用浅析一文做一下个人心得。 相关文档官方文档-Yield expressions廖雪峰-Python yield 使用浅析 个人理解转载自：Python教程中用户逝去的9211 Created at 8-3 17:43, Last updated at 8-3 17:43的评论。 注：以下讲的next()都是object的前后双下划线next方法 1yield &lt;expression&gt; 解释器在遇到这个语句时，先计算expression，然后将结果返回给上一个调用者。而在第二次调用next()时，会从yield的下个语句开始执行。 而讲到send()和next()的区别： 12345678910def consumer(): r = 'here' for i in xrange(3): yield r r = '200 OK'+ str(i)c = consumer()n1 = c.next()n2 = c.next()n3 = c.next() 对于普通的生成器，第一个next 调用，相当于启动生成器，会从生成器的第一行代码开始执行，直到第一次执行完yield语句（第4行），然后跳出生成器函数。然后第二个next 调用，从yield语句的下一句语句执行（第5行），然后重新运行到yield语句，执行后跳出，后面的以此类推。 123456789101112131415161718192021def consumer(): r = 'here' while True: n1 = yield r if not n1: return print('[CONSUMER] Consuming %s...' % n1) r = '200 OK'+str(n1)def produce(c): aa = c.send(None) n = 0 while n &lt; 5: n = n + 1 print('[PRODUCER] Producing %s...' % n) r1 = c.send(n) print('[PRODUCER] Consumer return: %s' % r1) c.close()c = consumer()produce(c) send(msg)和next()在一定程度上是类似的，区别是send()可以传递yield表达式的值进去，而next()不能，只能传递None进去。我们可以看做next()和send(None)是一致的。注意：第一次调用时，使用next()或send(None),不能使用send发送一个非None的值，否则会报错，因为没有python yield语句来接收这个值。第一次执行send(None)(11行)，启动生成器，第一行代码执行到yield后，跳出生成器函数，此时，n1一直没有定义。下面运行到c.send(1)，进入生成器函数，从第4行开始执行，先把1赋值给n1,但是并不执行yield语句部分。下面继续从yield的下一语句继续执行，然后重新运行到yield语句，执行后，跳出生成器。 综上，send和next 相比，多了一次赋值的动作，其他的流程是相同的。]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Gradle命令]]></title>
      <url>http://fengqingxiuyi.xyz/%E5%91%BD%E4%BB%A4/Gradle%E5%91%BD%E4%BB%A4.html</url>
      <content type="html"><![CDATA[注：本文所属命令，本文介绍官方文档中常用的Gradle命令和自己使用过程中经常需要用到的命令，本文仅用作记录，持续更新… 序所有命令都在AndroidStudio的Terminal中执行，Terminal默认打开位置为当前Project的根目录 官方文档Gradle User Guide不仅包含了Gradle的安装与命令行的使用，更有其他各种知识的介绍，它的一级目录如下所示： 123456789101112131415I. About GradleII. Working with existing buildsIII. Writing Gradle build scriptsIV. Extending the buildV. Building JVM projectsVI. The Software model - Next generation Gradle buildsVII. AppendixList of Examples 常用命令Listing projectsRunning gradle projects gives you a list of the sub-projects of the selected project, displayed in a hierarchy. Here is an example: 123456789101112$ gradle -q projects------------------------------------------------------------Root project------------------------------------------------------------Root project 'projectReports'+--- Project ':api' - The shared API for the application\--- Project ':webapp' - The Web application implementationTo see a list of the tasks of a project, run gradle &lt;project-path&gt;:tasksFor example, try running gradle :api:tasks Listing project dependenciesRunning gradle dependencies gives you a list of the dependencies of the selected project, broken down by configuration. For each configuration, the direct and transitive dependencies of that configuration are shown in a tree. Below is an example of this report: 123456789101112131415161718192021222324252627282930$ gradle -q dependencies api:dependencies webapp:dependencies------------------------------------------------------------Root project------------------------------------------------------------No configurations------------------------------------------------------------Project :api - The shared API for the application------------------------------------------------------------compile\--- org.codehaus.groovy:groovy-all:2.4.7testCompile\--- junit:junit:4.12 \--- org.hamcrest:hamcrest-core:1.3------------------------------------------------------------Project :webapp - The Web application implementation------------------------------------------------------------compile+--- project :api| \--- org.codehaus.groovy:groovy-all:2.4.7\--- commons-io:commons-io:1.2testCompileNo dependencies Filtering dependency report by configuration123456789$ gradle -q api:dependencies --configuration testCompile------------------------------------------------------------Project :api - The shared API for the application------------------------------------------------------------testCompile\--- junit:junit:4.12 \--- org.hamcrest:hamcrest-core:1.3 Listing project propertiesRunning gradle properties gives you a list of the properties of the selected project. This is a snippet from the output: 1234567891011121314$ gradle -q api:properties------------------------------------------------------------Project :api - The shared API for the application------------------------------------------------------------allprojects: [project ':api']ant: org.gradle.api.internal.project.DefaultAntBuilder@12345antBuilderFactory: org.gradle.api.internal.project.DefaultAntBuilderFactory@12345artifacts: org.gradle.api.internal.artifacts.dsl.DefaultArtifactHandler_Decorated@12345asDynamicObject: DynamicObject for project ':api'baseClassLoaderScope: org.gradle.api.internal.initialization.DefaultClassLoaderScope@12345buildDir: /home/user/gradle/samples/userguide/tutorial/projectReports/api/buildbuildFile: /home/user/gradle/samples/userguide/tutorial/projectReports/api/build.gradle 打包命令1$ gradle assembleRelease 注意：使用以上命令打包时，如果未用签名文件，使用debug mode的debug签名，那只会在build/outputs/apk/下生成一个debug签名的apk；如果使用了签名文件，则会在build/outputs/apk/下生成未签名的apk和已经签名的apk。 将命令输出内容写入文件本人未全部测试，根据测试的一部分+猜测，所有的gradle命令输出内容均可以由以下方式写入文件中 12345$ gradle 具体命令 &gt; 输出文件路径例如：gradle app:dependencies &gt; dependencies.txt]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Android存储路径总结]]></title>
      <url>http://fengqingxiuyi.xyz/Android/Wiki/Android%E5%AD%98%E5%82%A8%E8%B7%AF%E5%BE%84%E6%80%BB%E7%BB%93.html</url>
      <content type="html"><![CDATA[注：本文所属Android-Wiki，用于记录Android下获取存储路径方法对应的真实地址。 本文所有路径均在 MI 4LTE 下获得！！！ Context获取路径无API限制1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465/** 内部储存的cache目录 * Returns the absolute path to the application specific cache directory * on the filesystem. These files will be ones that get deleted first when the * device runs low on storage. * There is no guarantee when these files will be deleted. */public abstract File getCacheDir(): /data/user/0/包名/cache/** 内部储存的files目录 Returns the absolute path to the directory on the filesystem where * files created with &#123;@link #openFileOutput&#125; are stored. */public abstract File getFilesDir(): /data/user/0/包名/files/** 内部储存的app_dir目录 * Retrieve, creating if needed, a new directory in which the application * can place its own custom data files. You can use the returned File * object to create and access files in this directory. Note that files * created through a File object will only be accessible by your own * application; you can only set the mode of the entire directory, not * of individual files. */public abstract File getDir(String name, int mode): /data/user/0/包名/app_dir/** 外部存储的obb目录 * Return the primary external storage directory where this application's OBB * files (if there are any) can be found. Note if the application does not have * any OBB files, this directory may not exist. */public abstract File getObbDir(): /storage/emulated/0/Android/obb/包名/** 外部存储的cache目录 * Returns the absolute path to the directory on the primary external filesystem * (that is somewhere on &#123;@link android.os.Environment#getExternalStorageDirectory() * Environment.getExternalStorageDirectory()&#125; where the application can * place cache files it owns. These files are internal to the application, and * not typically visible to the user as media. */@Nullablepublic abstract File getExternalCacheDir(): /storage/emulated/0/Android/data/包名/cache/** 外部存储的files目录 * Returns the absolute path to the directory on the primary external filesystem * (that is somewhere on &#123;@link android.os.Environment#getExternalStorageDirectory() * Environment.getExternalStorageDirectory()&#125;) where the application can * place persistent files it owns. These files are internal to the * applications, and not typically visible to the user as media. */@Nullablepublic abstract File getExternalFilesDir(@Nullable String type): /storage/emulated/0/Android/data/包名/files/getExternalFilesDir/*** Returns the absolute path on the filesystem where a file created with* &#123;@link #openFileOutput&#125; is stored.** @param name The name of the file for which you would like to get* its path.** @return An absolute path to the given file.** @see #openFileOutput* @see #getFilesDir* @see #getDir*/public abstract File getFileStreamPath(String name): /data/user/0/包名/files/name API需要大于19注意：API19之后支持，即需要如下判断 1if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.KITKAT) &#123;...&#125; 1234567891011121314151617181920212223/** 外部存储的obb目录数组 * Returns absolute paths to application-specific directories on all * external storage devices where the application's OBB files (if there are * any) can be found. Note if the application does not have any OBB files, * these directories may not exist. */public abstract File[] getObbDirs(): /storage/emulated/0/Android/obb/包名/** 外部存储的cache目录数组 * Returns absolute paths to application-specific directories on all * external storage devices where the application can place cache files it * owns. These files are internal to the application, and not typically * visible to the user as media. */public abstract File[] getExternalCacheDirs(): /storage/emulated/0/Android/data/包名/cache/** 外部存储的files目录数组 * Returns absolute paths to application-specific directories on all * external storage devices where the application can place persistent files * it owns. These files are internal to the application, and not typically * visible to the user as media. */public abstract File[] getExternalFilesDirs(String type): /storage/emulated/0/Android/data/包名/files/getExternalFilesDirs API需要大于21注意：API21之后支持，即需要如下判断 1if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.KITKAT) &#123;...&#125; 123456789101112131415161718192021222324/** 内部存储的code_cache目录 * Returns the absolute path to the application specific cache directory on * the filesystem designed for storing cached code. The system will delete * any files stored in this location both when your specific application is * upgraded, and when the entire platform is upgraded. */public abstract Filno_backupe getCodeCacheDir(): /data/user/0/包名/code_cache/** 内部存储的no_backup目录 * Returns the absolute path to the directory on the filesystem similar to * &#123;@link #getFilesDir()&#125;. The difference is that files placed under this * directory will be excluded from automatic backup to remote storage. See * &#123;@link android.app.backup.BackupAgent BackupAgent&#125; for a full discussion * of the automatic backup mechanism in Android. */public abstract File getNoBackupFilesDir(): /data/user/0/包名/no_backup/** 外部存储的cache目录 * Returns absolute paths to application-specific directories on all * external storage devices where the application can place cache files it * owns. These files are internal to the application, and not typically * visible to the user as media. */public abstract File[] getExternalCacheDirs(): /storage/emulated/0/Android/data/包名/cache Environment获取路径123456789101112131415161718192021222324252627282930313233/** data根目录 * Return the user data directory. */File getDataDirectory(): /data/** cache根目录 * Return the download/cache content directory. */File getDownloadCacheDirectory(): /cache/** system根目录 * Return root of the "system" partition holding the core Android OS. * Always present and mounted read-only. */File getRootDirectory(): /system/** 外部存储根目录 * Return the primary external storage directory. This directory may not * currently be accessible if it has been mounted by the user on their * computer, has been removed from the device, or some other problem has * happened. You can determine its current state with * &#123;@link #getExternalStorageState()&#125;. */File getExternalStorageDirectory(): /storage/emulated/0/** 外部存储根目录下的type目录 * Get a top-level public external storage directory for placing files of * a particular type. This is where the user will typically place and * manage their own files, so you should be careful about what you put here * to ensure you don't erase their files or get in the way of their own * organization. */File getExternalStoragePublicDirectory(String type): /storage/emulated/0/getExternalStoragePublicDirectory]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Android Lint工作原理剖析]]></title>
      <url>http://fengqingxiuyi.xyz/Android/Lint/Android%20Lint%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90.html</url>
      <content type="html"><![CDATA[注：本文所属Android-Lint，转载自：Android Lint工作原理剖析 官方对自定义Lint的支持Android Lint是Android SDK提供的一项静态代码分析工具，对于提高代码质量具有重要作用。到目前为止，Android SDK自带的Lint检查项目达到了253项，我们在开发过程中经常见到的提示信息比如“Id被重复定义”“HandlerLeak风险”其实都是由Lint检查实现的。 Android Studio 2.0 Stable版本已经于2016年4月7日正式发布。除了Instant Run让人眼前一亮，更让人惊喜的是，官方已经悄然把自定义Lint的检查与IDE整合起来了。在此之前，自定义Lint规则只能通过在终端中执行gradle任务来运行，然后生成报告文件。Android Studio 2.0中整合自定义Lint检查的效果如图： 图中红线提示的错误是我自定义的Lint规则检查的结果，大意是Activity使用的布局文件应该以“activity_”为前缀进行命名。 关于Lint的一些基本知识，以及自定义Lint如何实现，可以参考我之前的文章：浅谈Android自定义Lint规则的实现 （一）浅谈Android自定义Lint规则的实现 （二） 从Android Studio的“偏好”设置窗口中，用户可以设置IDE整合的Lint检查功能的细节，如图： 虽然这个设置选项在旧版的Android Studio中也能看到，但实际上在旧版中是不起作用的。 除了在Editor中能够以红色下划线标注自定义检查项目外，使用Android Studio的 “Analyze” –&gt; “Inspect Code”现在也会检查自定义Lint规则中定义的项目了。Android Studio 2.0的这一功能整合真是太棒了，大大提高了自定义Lint的实用性。 Lint工作流程探究介绍完Android Studio 2.0的新特性，现在进入正题，我们来探究一下Lint检查的工作原理，包括系统默认的Lint检查项目以及用户自定义的Lint检查项目。本文以终端运行gradle的lint任务为例进行分析。其中自定义lint的使用方式是把自定义lint以aar的形式提供给app进行引用，具体实现方式可以参考浅谈Android自定义Lint规则的实现 （一） 。 当我们在终端执行“gradle lint”任务后，会加载com.android.build.gradle.tasks.Lint类，它的源码位于Lint.groovy文件中。Lint类的lint（）方法会首先被执行，这也是整个lint检查流程开始运转的起点。这部分代码如下： @SuppressWarnings(“GroovyUnusedDeclaration”)@TaskActionpublic void lint() &#123; def modelProject = createAndroidProject(project) if (getVariantName() != null &amp;&amp; !getVariantName().isEmpty()) &#123; for (Variant variant : modelProject.getVariants()) &#123; if (variant.getName().equals(getVariantName())) &#123; lintSingleVariant(modelProject, variant); &#125; &#125; &#125; else &#123; lintAllVariants(modelProject); &#125;&#125; 这里会根据getVariantName()的执行结果，选择去调用lintSingleVariant（）还是lintAllVariants（）。而观察lintSingleVariant（）和lintAllVariants（）的源码，发现这两个方法最终都要调用runLint（）方法，这个runLint（）方法很重要，代码片段如下： /* Runs lint on the given variant and returns the set of warnings /private List&lt;Warning&gt; runLint( @NonNull AndroidProject modelProject, @NonNull Variant variant, boolean report) &#123; IssueRegistry registry = createIssueRegistry() LintCliFlags flags = new LintCliFlags() LintGradleClient client = new LintGradleClient(registry, flags, project, modelProject, mSdkHome, variant, getBuildTools()) //……….这里省略部分代码……. warnings = client.run(registry) //………&#125; 这个方法的第一句话是创建了一个IssueRegistry，而了解自定义Lint的用户一定对这个类不会陌生，在之前的文章中我们提到过，Android内建的Lint检查项目都是定义在BuiltinIssueRegistry类中，而BuiltinIssueRegistry就是派生自IssueRegistry，我们要实现的自定义Lint检查规则实际上也就是实现自定义的IssueRegistry子类。IssueRegistry类的完整名称是com.android.tools.lint.client.api.IssueRegistry，它是一个Java类。自此，lint从一个gradle task开始与lint api包中的java类产生交互了。 createIssueRegistry()方法很简单，只有一句话： private static BuiltinIssueRegistry createIssueRegistry() &#123; return new LintGradleIssueRegistry() &#125; 继续跟踪LintGradleIssueRegistry类： public static class LintGradleIssueRegistry extends BuiltinIssueRegistry &#123; private boolean mInitialized; public LintGradleIssueRegistry() &#123; &#125; @NonNull @Override public List&lt;Issue&gt; getIssues() &#123; List&lt;Issue&gt; issues = super.getIssues(); if (!mInitialized) &#123; mInitialized = true; for (Issue issue : issues) &#123; if (issue.getImplementation().getDetectorClass() == GradleDetector.class) &#123; issue.setImplementation(GroovyGradleDetector.IMPLEMENTATION); &#125; &#125; &#125; return issues; &#125;&#125; 这里的BuiltinIssueRegistry我们刚才也提到了，用户平时在执行gradle lint时默认会执行200多项检查，这些默认检查项目都是Android SDK通过BuiltinIssueRegistry定义的。 继续执行上面的run（）方法，new出来的LintGradleClient实际上是com.android.tools.lint.LintCliClient的子类，这个类的作用是提供执行lint任务的环境信息（比如控制台、IDE的信息），执行IssueRegistry中定义的各种ISSUE检查，以及以多种形式输出lint报告等。 继续执行run（）方法，也就是warnings = client.run(registry)。看到这里终于知道BuiltinIssueRegistry中定义的200多项ISSUE是如何被gradle的lint任务引入检查了。 到这里为止，对groovy文件的分析就结束了，由于LintGradleClient是继承自java类LintCliClient，后续真正的lint检查工作都通过client.run(registry)这句话转交给java实现的LintCliClient类来完成。 读到这里有人会问，client.run(registry)中的参数registry是派生自BuiltinIssueRegistry，那么lint检查的项目也就是BuiltinIssueRegistry中定义的那200多项默认检查项目。那么我们自定义的lint规则中的ISSUE又是如何被引入lint检查的呢？不要急，下面会有分析。 LintCliClient类的run（）方法的主要代码如下： //LintCliClient.run（)部分代码public int run(@NonNull IssueRegistry registry, @NonNull List&lt;File&gt; files) throws IOException &#123; //………… mDriver = new LintDriver(registry, this); //………… mDriver.analyze(createLintRequest(files)); Collections.sort(mWarnings); boolean hasConsoleOutput = false; for (Reporter reporter : mFlags.getReporters()) &#123; reporter.write(mErrorCount, mWarningCount, mWarnings); if (reporter instanceof TextReporter &amp;&amp; ((TextReporter)reporter).isWriteToConsole()) &#123; hasConsoleOutput = true; &#125; &#125; if (!mFlags.isQuiet() &amp;&amp; !hasConsoleOutput) &#123; System.out.println(String.format( “Lint found %1$d errors and %2$d warnings”, mErrorCount, mWarningCount)); &#125; return mFlags.isSetExitCode() ? (mHasErrors ? ERRNO_ERRORS : ERRNO_SUCCESS) : ERRNO_SUCCESS;&#125; 不要被run（）这个方法名迷惑了，以为LintCliClient是一个线程类。其实LintCliClient只是一个普通类，不是Runnable类，这里的方法也叫run（）仅仅是一个巧合。这里的run（）方法中首先new了一个LintDriver对象，其实它才是真正用来对project和file进行lint分析的类，也就是通过mDriver.analyze（）来进行lint分析。 LintDriver的analyze()方法精简后的代码如下： //LintDriver.analyze()部分源码private void analyze() &#123; //………… Collection&lt;Project&gt; projects; projects = mRequest.getProjects(); if (projects == null) &#123; projects = computeProjects(mRequest.getFiles()); &#125; //………… registerCustomDetectors(projects); if (mScope == null) &#123; mScope = Scope.infer(projects); &#125; fireEvent(EventType.STARTING, null); for (Project project : projects) &#123; mPhase = 1; Project main = mRequest.getMainProject(project); // The set of available detectors varies between projects computeDetectors(project); if (mApplicableDetectors.isEmpty()) &#123; // No detectors enabled in this project: skip it continue; &#125; checkProject(project, main); if (mCanceled) &#123; break; &#125; runExtraPhases(project, main); &#125; fireEvent(mCanceled ? EventType.CANCELED : EventType.COMPLETED, null);&#125; 这里的projects变量中保存的就是等待进行Lint检查的工程项目，它是我们最开始在终端中执行gradle lint任务时指定的。比如在本例中，projects中保存的就是“Project [dir=/Users/netease/AndroidStudioProjects/HTLint/app]”这个项目。 继续往下执行，走到registerCustomDetectors(projects)这句话，看到这个方法名你是不是发现了什么？别急，我们先看看registerCustomDetectors（）方法的源码： private void registerCustomDetectors(Collection&lt;Project&gt; projects) &#123; // Look at the various projects, and if any of them provide a custom // lint jar, “add” them (this will replace the issue registry with // a CompositeIssueRegistry containing the original issue registry // plus JarFileIssueRegistry instances for each lint jar Set&lt;File&gt; jarFiles = Sets.newHashSet(); for (Project project : projects) &#123; jarFiles.addAll(mClient.findRuleJars(project)); for (Project library : project.getAllLibraries()) &#123; jarFiles.addAll(mClient.findRuleJars(library)); &#125; &#125; jarFiles.addAll(mClient.findGlobalRuleJars()); if (!jarFiles.isEmpty()) &#123; List&lt;IssueRegistry&gt; registries = Lists.newArrayListWithExpectedSize(jarFiles.size()); registries.add(mRegistry); for (File jarFile : jarFiles) &#123; try &#123; IssueRegistry registry = JarFileIssueRegistry.get(mClient, jarFile); if (myCustomIssues == null) &#123; myCustomIssues = Sets.newHashSet(); &#125; myCustomIssues.addAll(registry.getIssues()); registries.add(registry); &#125; catch (Throwable e) &#123; mClient.log(e, “Could not load custom rule jar file %1$s”, jarFile); &#125; &#125; if (registries.size() &gt; 1) &#123; // the first item is mRegistry itself mRegistry = new CompositeIssueRegistry(registries); &#125; &#125;&#125; 对于projects中的每一项project，都通过mClient.findRuleJars(project)方法来寻找该project中的RuleJars，那么findRuleJars（）是如何实现的呢？它返回的RuleJars又是什么呢？ 由于在LintDriver的构造函数中，mClient被初始化为一个LintClientWrapper对象，而LintClientWrapper类的findRuleJars（）方法内部只有一句话: return mDelegate.findRuleJars(project) 所以上面的mClient.findRuleJars(project)实际上是被委托给了LintGradleClient.java来实现。LintGradleClient类又在它的createLintRequest（）方法中调用了LintGradleProject的静态方法create()，其中有这样一个片段： public static Pair&lt;LintGradleProject, List&lt;File&gt;&gt; create( @NonNull LintGradleClient client, @NonNull AndroidProject project, @NonNull Variant variant, @NonNull org.gradle.api.Project gradleProject) &#123; //………… List&lt;File&gt; customRules = Lists.newArrayList(); File appLintJar = new File(gradleProject.getBuildDir(), “lint” + separatorChar + “lint.jar”); if (appLintJar.exists()) &#123; customRules.add(appLintJar); &#125; //…………&#125; 这段代码会寻找当前项目的构建目录下是否引用了一个名为lint.jar文件，如果有就把它加入customRules列表中。我们在《浅谈Android自定义Lint规则的实现》中提到过通过aar包装lint.jar文件，然后让需要自定义lint检查的android项目添加对aar的依赖，这也是本文的例子使用的引入自定义lint规则的方法。原来我们添加的依赖中的lint.jar文件是在这里被找出来的。 继续回去看registerCustomDetectors（）方法后续的代码执行，也就是这一段： for (Project library : project.getAllLibraries()) &#123; jarFiles.addAll(mClient.findRuleJars(library));&#125; 这段代码会对当前工程依赖的所有库文件进行检查，如果这些库文件有对名为lint.jar文件的引用，则把它们引用的lint.jar文件也加入到jarFiles集合中。如此一来，不管是项目直接依赖的lint.jar文件，还是间接通过其他库引入的lint.jar文件，就都被放入jarFiles集合中了。 继续往下执行registerCustomDetectors（）中的代码，走到了： jarFiles.addAll(mClient.findGlobalRuleJars()); 这里的findGlobalRuleJars()方法实际是由LintClient实现的： //com.android.tools.lint.client.api.LintClient类public List&lt;File&gt; findGlobalRuleJars() &#123; // Look for additional detectors registered by the user, via // (1) an environment variable (useful for build servers etc), and // (2) via jar files in the .android/lint directory List&lt;File&gt; files = null; try &#123; String androidHome = AndroidLocation.getFolder(); File lint = new File(androidHome + File.separator + “lint”); //$NON-NLS-1$ if (lint.exists()) &#123; File[] list = lint.listFiles(); if (list != null) &#123; for (File jarFile : list) &#123; if (endsWith(jarFile.getName(), DOT_JAR)) &#123; if (files == null) &#123; files = new ArrayList&lt;File&gt;(); &#125; files.add(jarFile); &#125; &#125; &#125; &#125; &#125; catch (AndroidLocation.AndroidLocationException e) &#123; // Ignore – no android dir, so no rules to load. &#125; String lintClassPath = System.getenv(“ANDROID_LINT_JARS”); //$NON-NLS-1$ if (lintClassPath != null &amp;&amp; !lintClassPath.isEmpty()) &#123; String[] paths = lintClassPath.split(File.pathSeparator); for (String path : paths) &#123; File jarFile = new File(path); if (jarFile.exists()) &#123; if (files == null) &#123; files = new ArrayList&lt;File&gt;(); &#125; else if (files.contains(jarFile)) &#123; continue; &#125; files.add(jarFile); &#125; &#125; &#125; return files != null ? files : Collections.&lt;File&gt;emptyList();&#125; 这段代码逻辑也很简单，就是在环境变量指定的路径和“.android/lint”路径下分别寻找是否存在自定义lint规则的jar文件。如果有，就把它们返回并加入jarFiles集合中。现在，不管是通过引入依赖库的方式，还是在系统指定路径或环境变量指定路径下放置lint.jar的方式（这2种方式在《浅谈Android自定义Lint规则的实现》中都有介绍）引入的lint.jar文件都已经被找出来放到jarFiles集合中了。 继续往下执行registerCustomDetectors（）中的代码，这一行： registries.add(mRegistry); 会把最开始生成的LintGradleIssueRegistry（实际就是系统默认的Lint检查项目BuiltinIssueRegistry的子类）缓存到列表registries中。 然后紧接着的for循环会针对jarFiles中的每一项指定lint规则的jarFile，获取jarFile中包含的IssueRegistry，把这些IssueRegistry也都缓存到列表registries中，并把IssueRegistry中包含的所有ISSUE都缓存到集合myCustomIssues中。也就是这段代码（再贴一遍😓）： if (!jarFiles.isEmpty()) &#123; //………… for (File jarFile : jarFiles) &#123; //………… myCustomIssues.addAll(registry.getIssues()); registries.add(registry); &#125; if (registries.size() &gt; 1) &#123; // the first item is mRegistry itself mRegistry = new CompositeIssueRegistry(registries); &#125;&#125; 然后通过创建一个CompositeIssueRegistry对象，把所有lint检查的IssueRegistry对象（不论是系统默认的检查项目还是用户实现的自定义检查项目）都包装到CompositeIssueRegistry中。这样，在后面真正进行ISSUE检查工作时，就可以直接使用CompositeIssueRegistry对象中返回的ISSUE列表了，因为它包含了系统自带的和用户自定义的所有ISSUE。 到了这里，registerCustomDetectors(projects)方法就执行完了（你不会忘了我们其实是因为跟踪LintDriver的analyze()方法所以才会有上面这么多balabala吧o(╯□╰)o ），让我们继续回到LintDriver的analyze()方法中往下看，也就是这一段： //LintDriver.analyze()部分源码if (mScope == null) &#123; mScope = Scope.infer(projects);&#125;fireEvent(EventType.STARTING, null);for (Project project : projects) &#123; mPhase = 1; Project main = mRequest.getMainProject(project); // The set of available detectors varies between projects computeDetectors(project); if (mApplicableDetectors.isEmpty()) &#123; // No detectors enabled in this project: skip it continue; &#125; checkProject(project, main); if (mCanceled) &#123; break; &#125; runExtraPhases(project, main);&#125;fireEvent(mCanceled ? EventType.CANCELED : EventType.COMPLETED, null); 首先会在mScope字段中缓存当前要做Lint检查的工程都需要对哪些Scope进行检查，比如需不需要检查Java源代码（Scope.JAVA_FILE）、Java字节码（Scope.CLASS_FILE）、资源文件（Scope.RESOURCE_FILE）等等。 fireEvent(EventType.STARTING, null)会回调所有已经注册过的LintListener，通知它们Lint检查开始了。LintListener是一个interface，可以对Lint检查的各个阶段进行响应。 接着一个for循环分别对projects中的每个project进行检查，由于每个project对lint的配置都不同，比如用户通过配置当前project目录下的lint.xml文件关闭了某些检查项目，或者更改了某些ISSUE的严重等级等。所以这里使用了computeDetectors(project)来获取当前检查的project的lint配置信息： private void computeDetectors(@NonNull Project project) &#123; //………………. Configuration configuration = project.getConfiguration(this); mScopeDetectors = new EnumMap&lt;Scope, List&lt;Detector&gt;&gt;(Scope.class); mApplicableDetectors = mRegistry.createDetectors(mClient, configuration, mScope, mScopeDetectors); validateScopeList();&#125; 这里获取到的configuration中包含了当前正接受lint检查的project的基本信息，以及lint属性配置文件的信息，debug截图如下： 然后这个configuration中的信息就被作为参数传给了mRegistry.createDetectors（）方法，来获知需要使用哪些Detector来检查当前project，而这里的mRegistry对象其实是一个CompositeIssueRegistry对象，也就是把android sdk自带的lint检查项目和用户自定义实现的lint检查项目都包含在内了。这里的createDetectors（）是没有被CompositeIssueRegistry重写，直接继承父类IssueRegistry的方法，主要代码如下： final List&lt;? extends Detector&gt; createDetectors( @NonNull LintClient client, @NonNull Configuration configuration, @NonNull EnumSet&lt;Scope&gt; scope, @Nullable Map&lt;Scope, List&lt;Detector&gt;&gt; scopeToDetectors) &#123; List&lt;Issue&gt; issues = getIssuesForScope(scope); //…………….. Set&lt;Class&lt;? extends Detector&gt;&gt; detectorClasses = new HashSet&lt;Class&lt;? extends Detector&gt;&gt;(); for (Issue issue : issues) &#123; Implementation implementation = issue.getImplementation(); Class&lt;? extends Detector&gt; detectorClass = implementation.getDetectorClass(); EnumSet&lt;Scope&gt; issueScope = implementation.getScope(); if (!detectorClasses.contains(detectorClass)) &#123; if (!configuration.isEnabled(issue)) &#123; continue; &#125; //…………….. detectorClasses.add(detectorClass); &#125; &#125; List&lt;Detector&gt; detectors = new ArrayList&lt;Detector&gt;(detectorClasses.size()); for (Class&lt;? extends Detector&gt; clz : detectorClasses) &#123; Detector detector = clz.newInstance(); detectors.add(detector); //……………. &#125; return detectors;&#125; 逻辑很简单，先获取CompositeIssueRegistry对象中所有的ISSUE，也就是默认的200多项检查加上用户自己实现的检查项目，然后分别对这些ISSUE进行判断：如果集合detectorClasses中还没有包含当前ISSUE对应的lint探测器实现类detectorClass，并且当前project的配置文件没有禁用这个issue，那么就把探测器实现类detectorClass加入集合detectorClasses中。当所有issue都通过这个循环检查完毕后，把这些测器实现类都实例化成对象detector，加入列表detectors，最后把detectors返回给调用者，这样上一级调用者就获得了当前project可以用的所有Detector的实例了。 回到上一级调用者，继续往下执行LintDriver.analyze()剩下的代码，终于完成了所有的前期准备工作，来到了checkProject(project, main)这一句，这个方法才是真正使用前面所有工作提供的信息，开始正式对project的文件、字节码等进行lint检查了。而checkProject（）方法中又调用了一个最核心的方法runFileDetectors()来进行lint检查工作，大致结构如下： //LintDriver.runFileDetectors()部分源码private void runFileDetectors(@NonNull Project project, @Nullable Project main) &#123; // Look up manifest information (but not for library projects) if (project.isAndroidProject()) &#123; for (File manifestFile : project.getManifestFiles()) &#123; //…………….. fireEvent(EventType.SCANNING_FILE, context); v.visitFile(context, manifestFile); &#125; if (mScope.contains(Scope.ALL_RESOURCE_FILES) || mScope.contains(Scope.RESOURCE_FILE) || mScope.contains(Scope.RESOURCE_FOLDER) || mScope.contains(Scope.BINARY_RESOURCE_FILE)) &#123; if (……) &#123; checkIndividualResources(project, main, xmlDetectors, dirChecks, binaryChecks, files); &#125; else &#123; checkResFolder(project, main, res, xmlDetectors, dirChecks, binaryChecks); &#125; &#125; //…………….. &#125; if (mScope.contains(Scope.JAVA_FILE) || mScope.contains(Scope.ALL_JAVA_FILES)) &#123; if (……) &#123; checkIndividualJavaFiles(project, main, checks, files); &#125; else &#123; //…………….. checkJava(project, main, sourceFolders, checks); &#125; &#125; //…………….. if (mScope.contains(Scope.CLASS_FILE) || mScope.contains(Scope.ALL_CLASS_FILES) || mScope.contains(Scope.JAVA_LIBRARIES)) &#123; checkClasses(project, main); &#125; if (mScope.contains(Scope.GRADLE_FILE)) &#123; checkBuildScripts(project, main); &#125; if (mScope.contains(Scope.OTHER)) &#123; List&lt;Detector&gt; checks = mScopeDetectors.get(Scope.OTHER); if (checks != null) &#123; OtherFileVisitor visitor = new OtherFileVisitor(checks); visitor.scan(this, project, main); &#125; &#125; if (project == main &amp;&amp; mScope.contains(Scope.PROGUARD_FILE) &amp;&amp; project.isAndroidProject()) &#123; checkProGuard(project, main); &#125; if (project == main &amp;&amp; mScope.contains(Scope.PROPERTY_FILE)) &#123; checkProperties(project, main); &#125;&#125; 这段原始代码比较长，这里只截取了一个大致的框架。可以看到首先判断如果当前检查的是一个android项目，那么就检查它所有的Manifest文件，检查顺序为： The manifests should be provided such that the main manifest comes first, then any flavor versions, then any build types. 然后再检查所有的资源文件和文件夹。 到了这里，专门针对android项目的检查就完成了，接下来就是对所有类型项目都要进行的检查了，这段代码框架的结构很清晰的列出了检查顺序为：java源文件 –&gt; java字节码 –&gt; GRADLE文件 –&gt; 其他文件 –&gt; ProGuard文件 –&gt; PROPERTY文件。这与http://tools.android.com/tips/lint/writing-a-lint-check上关于lint检查顺序的描述是一致的： OK，对所有project的所有issue都已经检查完成了，现在让我们回到LintCliClient.run()的执行（别怪我一下跳的太远，实在是计算机就是这样执行的啊o(╯□╰)o，代码再贴一遍…）： //LintCliClient.run（)部分代码public int run(@NonNull IssueRegistry registry, @NonNull List&lt;File&gt; files) throws IOException &#123; //………… mDriver = new LintDriver(registry, this); //………… mDriver.analyze(createLintRequest(files)); Collections.sort(mWarnings); boolean hasConsoleOutput = false; for (Reporter reporter : mFlags.getReporters()) &#123; reporter.write(mErrorCount, mWarningCount, mWarnings); if (reporter instanceof TextReporter &amp;&amp; ((TextReporter)reporter).isWriteToConsole()) &#123; hasConsoleOutput = true; &#125; &#125; if (!mFlags.isQuiet() &amp;&amp; !hasConsoleOutput) &#123; System.out.println(String.format( “Lint found %1$d errors and %2$d warnings”, mErrorCount, mWarningCount)); &#125; return mFlags.isSetExitCode() ? (mHasErrors ? ERRNO_ERRORS : ERRNO_SUCCESS) : ERRNO_SUCCESS;&#125; 我们前面这么长的篇幅其实都是在分析这里的mDriver.analyze(createLintRequest(files))方法，它会把lint检查出来的警告和错误信息保存在列表mWarnings中，然后用这句Collections.sort(mWarnings)对所有警告进行排序。剩下的工作当然就是把这些警告信息输出啦，输出成为我们平常见到的html报告、或者控制台报告、或者其他形式。输出报告的工作是由这段代码完成的： for (Reporter reporter : mFlags.getReporters()) &#123; reporter.write(mErrorCount, mWarningCount, mWarnings); if (reporter instanceof TextReporter &amp;&amp; ((TextReporter)reporter).isWriteToConsole()) &#123; hasConsoleOutput = true; &#125;&#125; 到此为止，Lint的工作流程就分析完了。 如何debug Lint源码在终端执行gradle的lint任务默认是无法debug的，也就是说你在系统定义的200多项Issue或者你自定义的Issue中打的断点都不起作用。如果需要调试，可以用下面的方法： 1、在gradle.properties文件中加上下面这句话： org.gradle.jvmargs=&apos;-agentlib:jdwp=transport=dt_socket,server=y,suspend=n,address=5005&apos; 2、创建一个Remote类型的debug配置文件： 3、在终端中以daemon模式启动gradle lint任务 然后快速点击debug按钮（注意此时要切换到刚才创建的Debug Lint的配置文件上），如图： 现在Lint源码（包括Android SDK中的和用户自定义的Lint规则）中的断点就可以调试了。]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[浅谈Android自定义Lint规则的实现（二）]]></title>
      <url>http://fengqingxiuyi.xyz/Android/Lint/%E6%B5%85%E8%B0%88Android%E8%87%AA%E5%AE%9A%E4%B9%89Lint%E8%A7%84%E5%88%99%E7%9A%84%E5%AE%9E%E7%8E%B0%EF%BC%88%E4%BA%8C%EF%BC%89.html</url>
      <content type="html"><![CDATA[注：本文所属Android-Lint，转载自：浅谈Android自定义Lint规则的实现 （二） 上一篇文章针对Android自定义Lint规则的总体开发流程做了介绍，本文针对java源代码Lint检测方法做细节介绍。由于网上关于自定义Lint规则的文章比较有限，且对于lombok.ast库的相关细节几乎没有文档可用，所以本文内容主要是根据自身开发经验做的总结，难免会有疏漏或错误，还请各位大神批评指正。 检测Java源代码针对Java源代码做Lint检测，我们需要让自定义的XXXDetector类继承com.android.tools.lint.detector.api.Detector类，并实现com.android.tools.lint.detector.api.Detector.JavaScanner接口，同时在该XXXDetector对应的Issue中定义检测的范围为com.android.tools.lint.detector.api.Scope.JAVA_FILE_SCOPE，如图： 其实我们查看Detector类的源码会发现，JavaScanner是在Detector中定义的内部接口，JavaScanner接口中定义的10个方法，都以完全相同的签名在Detector中重新定义了一遍。所以，Detector相当于是JavaScanner接口的适配器，上图中我们自定义的ActivityFragmentLayoutNameDetector类可以根据需要只实现JavaScanner接口的部分方法，而不需要实现全部10个方法。作为7个Scanner（这7个Scanner在上一篇中有介绍，这里的JavaScanner就是其中一个）的外部类，Detector实际上是它们共同的适配器。 JavaScanner接口定义的10个方法如下图所示： 从上图可以看到，JavaScanner定义的很多方法都用到了Node类，还出现了ConstructorInvocation、MethodInvocation等类。那么这些类到底代表什么，我们如何在java源代码的分析中使用这些类呢？要搞清楚这个问题，我们首先要介绍一下Abstract Syntax Tree。 Abstract Syntax Tree是什么在计算机科学中，Abstract Syntax Tree（简称AST）是对程序设计语言写成的源代码的一种树型表示。树中的每一个节点（node）代表在源代码中存在的一个构建体。之说以说语法树是“抽象的”（Abstract）是因为它并没有把真实语法的所有细节都表达出来，比如成对匹配的括号就隐式的用树结构来表达，一条if-condition-then语句可能就用一个具有3个分支的节点来表达。 在Java和Android开发工作中，IDE工具带给我们的很多便利功能都是通过AST来实现的，比如Quick Fix、Quick Assist、修改一个变量名时自动把所有对该变量的引用都同步修改、以及在Android Studio中摁住⌘键的同时点击一个类名会跳转到那个类的定义文件等。 AST与XML文件的DOM模型类似，允许你通过修改树模型来把这些修改反映到Java源代码中。不过我们在自定义Lint使用AST的过程中一般不涉及修改节点。一个AST的例子如下图: 在查看Android Lint源码的过程中可以发现，它涉及到两套AST的实现API，一套是Ecj（Eclipse Java development tools）的，在包org.eclipse.jdt.internal.compiler.ast中；另一套是lombok.ast的。系统暴露给我们允许我们直接用来扩展Lint规则的是lombok.ast的AST API。JavaScanner定义的10个方法中的Node指的就是lombok.ast.Node，而ConstructorInvocation、MethodInvocation都是lombok.ast.Node的子类。 如果你对AST感兴趣，可以查看Eclipse网站的AST介绍文档。 JavaScanner接口方法的使用前面的图片显示了JavaScanner接口定义的10个方法，这些方法有些可以单独使用，有些需要配合使用，这里介绍常见的用法。 【1】getApplicableNodeTypes（）需要与createJavaVisitor（）配合使用。 getApplicableNodeTypes（）返回我们感兴趣的Node列表，然后在createJavaVisitor（）返回的AstVisitor中去处理这些Node。比如，我们想对java源代码中的if、try、for语句进行检测，就可以这样实现getApplicableNodeTypes（）： @Overridepublic List&lt;Class&lt;? extends Node&gt;&gt; getApplicableNodeTypes() &#123; return Arrays.asList(Try.class, If.class, For.class);&#125; 其中的Try、If、For都是lombok.ast.Node的子类。 然后定义一个AstVisitor的子类，并在createJavaVisitor（）中返回它的一个实例，那么在java源码中出现的try、if、for语句对应的node就会触发ForIfTryBlockVisitor中对应的回调函数： @Overridepublic AstVisitor createJavaVisitor(@NonNull JavaContext context) &#123; return new ForIfTryBlockVisitor(context);&#125; private class ForIfTryBlockVisitor extends ForwardingAstVisitor &#123; private final JavaContext mContext; public ForIfTryBlockVisitor(JavaContext context) &#123; mContext = context; &#125; @Override public boolean visitTry(Try node) &#123; //… 在这里对try语句做你需要的检查 return super.visitTry(node); &#125; @Override public boolean visitFor(For node) &#123; //… 在这里对for语句做你需要的检查 return super.visitFor(node); &#125; @Override public boolean visitIf(If node) &#123; //… 在这里对if语句做你需要的检查 return super.visitIf(node); &#125;&#125; 【2】getApplicableMethodNames()需要与void visitMethod(JavaContext context, AstVisitor visitor, MethodInvocation node)配合使用，此时createJavaVisitor（）根据实际需求可有可无。 这里getApplicableMethodNames()用来返回你感兴趣的那些方法调用列表，这些方法调用对应的node每一次出现都会触发visitMethod(JavaContext context, AstVisitor visitor, MethodInvocation node)方法被回调。 例如，我想针对java源代码中所有调用setContentView（）和inflate（）的代码进行检查，可以这样定义getApplicableMethodNames（）： @Overridepublic List&lt;String&gt; getApplicableMethodNames() &#123; return Arrays.asList(“setContentView”, “inflate”);&#125; 然后在visitMethod方法中做具体处理： @Overridepublic void visitMethod(@NonNull JavaContext context, AstVisitor visitor, @NonNull MethodInvocation node) &#123; String methodName = node.astName().astValue(); if (methodName.equals(“setContentView”)) &#123; //在这里做针对setContentView（）调用的具体检查 &#125; else if (methodName.equals(“inflate”)) &#123; //在这里做针对inflate（）调用的具体检查 &#125;&#125; 【3】getApplicableConstructorTypes（）需要与visitConstructor(JavaContext context, AstVisitor visitor,ConstructorInvocation node,ResolvedMethod constructor)配合使用，此时createJavaVisitor（）根据实际需求可有可无。 这里getApplicableConstructorTypes（）用来返回你感兴趣的构造方法的列表，系统会在符合条件的构造方法的每一次出现都回调一次visitConstructor方法，而传入的node参数就是对应的调用构造函数在AST中的节点。 @Overridepublic List&lt;String&gt; getApplicableConstructorTypes() &#123; return Arrays.asList(“com.ljfxyj2008.BlankFragment”);&#125;@Overridepublic void visitConstructor(@NonNull JavaContext context, AstVisitor visitor, @NonNull ConstructorInvocation node, @NonNull JavaParser.ResolvedMethod constructor) &#123; //在这里做针对构造函数调用语句的具体检查 System.out.println(“===visitConstructor node = “ + node + “\nlocation = “ + context.getLocation(node).getStart().getLine());&#125; 【4】appliesToResourceRefs（）需要与visitResourceReference(JavaContext context,AstVisitor visitor,Node node,String type,String name,boolean isFramework)配合使用，用来对感兴趣的资源文件引用的代码进行检查，比如引用了R.layout.main或者R.string.app_name的代码。 这两个方法的实现步骤与前面的几对类似，就不再贴代码了。 在上面介绍的JavaScanner的所有相关API中，最重要的就是createJavaVisitor（）以及该方法返回的AstVisitor。事实上，我们完全可以只利用createJavaVisitor（）方法以及对应的AstVisitor，就完成对java源代码的所有检查工作。之所以Lint系统为JavaScanner接口定义了10个方法，仅仅是为了使得对常见的一些处理需求实现起来更加简洁和高效。 lombok.ast API中重要的类既然Lint分析是处理AST中的节点，那么最重要最常用的类当然就是lombok.ast.Node了。lombok.ast.Node实际上是一个接口，定义了对于AST节点的一系列通用操作，有多个抽象子类/接口都实现/继承了它。而在这些抽象子类/接口中我们最常用到的是AbstractNode。AbstractNode是实现了lombok.ast.Node接口的抽象类，它有为数众多的子类，这些子类直接与各种语句直接对应，如图： 可以看到常用的case、break、continue、for、if等语句都直接被映射为这里具体的Node子类，而类构造器的声明与调用（即用new关键字来生成一个新对象）也能在这里找到对应的类（即ConstructorDeclaration和ConstructorInvocation）。有了AbstractNode如此丰富的子类，我么对java源码的分析就方便了很多，对于自己想要分析的元素，先找到与它对应的AbstractNode子类，然后在定义自己的AstVisitor时去分析这个对应类即可。 下面给出一个简单的例子，目的是检查用户有没有使用new Message（）来获取新的android.os.Message对象，如果有这种调用，我们就抛出一个issue，提示用户应该使用效率更高的handler.obtainMessage或者Message.Obtain()来获取，代码如下： public class MessageObtainDetector extends Detector implements Detector.JavaScanner &#123; public static final Issue ISSUE = Issue.create(“MessageObtainNotUsed”, “You should not call new Message() directly.”, “You should not call new Message() directly. Instead, you should use handler.obtainMessage or Message.Obtain().”, Category.CORRECTNESS, 9, Severity.ERROR, new Implementation(MessageObtainDetector.class, Scope.JAVA_FILE_SCOPE)); @Override public List&lt;Class&lt;? extends Node&gt;&gt; getApplicableNodeTypes() &#123; return Collections.&lt;Class&lt;? extends Node&gt;&gt;singletonList(ConstructorInvocation.class); &#125; @Override public AstVisitor createJavaVisitor(@NonNull JavaContext context) &#123; return new MessageObtainVisitor(context); &#125; private class MessageObtainVisitor extends ForwardingAstVisitor &#123; private final JavaContext mContext; public MessageObtainVisitor(JavaContext context) &#123; mContext = context; &#125; @Override public boolean visitConstructorInvocation(ConstructorInvocation node) &#123; JavaParser.ResolvedNode resolvedType = mContext.resolve(node.astTypeReference()); JavaParser.ResolvedClass resolvedClass = (JavaParser.ResolvedClass) resolvedType; if (resolvedClass != null &amp;&amp; resolvedClass.isSubclassOf(“android.os.Message”, false))&#123; mContext.report(ISSUE, node, mContext.getLocation(node), “You should not call new Message() directly.”); return true; &#125; return super.visitConstructorInvocation(node); &#125; &#125;&#125; 这段代码结构非常简单，在getApplicableNodeTypes()方法中返回一个List表明我们只对ConstructorInvocation.class感兴趣，然后在createJavaVisitor（）中返回一个自定义的AstVisitor对象，也就是这里的MessageObtainVisitor。因为是检测对构造方法的调用，所以我们在MessageObtainVisitor的定义中只需要重写visitConstructorInvocation（）方法。事实上，即使我们把这里对getApplicableNodeTypes()重写的代码段删除，仍然可以达到检测new Message()的目的，因为只要在MessageObtainVisitor（）中重写了visitXXX（）就可以保证它被调用，但是我们重写getApplicableNodeTypes()可以确保效率更高。 认真看自定义类MessageObtainVisitor的visitConstructorInvocation（）方法体，可以看到这两行代码: JavaParser.ResolvedNode resolvedType = mContext.resolve(node.astTypeReference());JavaParser.ResolvedClass resolvedClass = (JavaParser.ResolvedClass) resolvedType; 这两行代码非常关键，它把lombok.ast中的类转换成了JavaParser中的类，如此一来我们就可以获取与此node对应的类、变量、方法或注解的详细信息。比如这里的node被转换为resolvedClass后，就可以获取与此类有关的类继承关系。 由于lombok.ast中各种回调函数（如getApplicableNodeTypes、visitConstructorInvocation等）的参数都是lombok.ast.Node类型，它们包含的都是与AST（抽象语法树）相关的结构性信息，而这些信息对于我们分析java源码的具体业务来说肯定是远远不够的，所以在合适的时机把node转换成JavaParser中各种合适的类型就非常重要。那么在lombok.ast的各种回调函数中传入的node能够被转换成哪些类型呢？看下图： 可以看到类型还是相当丰富的，足够我们对AST各种节点进行详细分析了。 相信细心的朋友应该发现了，上面MessageObtainDetector这个类的代码中是对ConstructorInvocation.class类型的节点进行了分析，而我们在JavaScanner接口方法的使用这一节的第3条介绍了getApplicableConstructorTypes（）和visitConstructor（）方法，它们看起来很类似啊？没错，对于MessageObtainDetector类中进行的构造方法调用检查，我们同样可以用getApplicableConstructorTypes（）和visitConstructor（）来实现，这样就不需要自己去定义一个MessageObtainVisitor了。我们在前面也提到过，JavaScanner中的定义的10个回调方法，其实大部分都是为了简化代码结构与提高执行效率，其实完全可以只用自定义的ForwardingAstVisitor来完成所有检测功能。 还有一组比较有用的类型转换方法上面没有提到： ClassDeclaration surroundingClass = JavaContext.findSurroundingClass(node);Node surroundingMethod = JavaContext.findSurroundingMethod(node); 用这组方法可以获取到此node外围包裹它的类或方法，这是JavaContext类提供的两个静态方法，可以将这两个方法与上面介绍的JavaParser中的ResolvedXXX类型配合使用。 小结使用Lint来分析java源代码，需要实现JavaScanner中合适的回调函数。这些回调函数大部分是为了使得对常见的一些处理需求实现起来更加简洁和高效，事实上我们完全可以只用自定义的AstVisitor来完成所有Lint检查工作，并在createJavaVisitor（）中返回这个自定义AstVisitor的实例。JavaScanner回调函数的node包含的都是与AST结构相关的信息，如果要对node对应的java类、方法等进行详细的业务分析，就需要把node转换成JavaParser中定义的合适类型。]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[浅谈Android自定义Lint规则的实现（一）]]></title>
      <url>http://fengqingxiuyi.xyz/Android/Lint/%E6%B5%85%E8%B0%88Android%E8%87%AA%E5%AE%9A%E4%B9%89Lint%E8%A7%84%E5%88%99%E7%9A%84%E5%AE%9E%E7%8E%B0%EF%BC%88%E4%B8%80%EF%BC%89.html</url>
      <content type="html"><![CDATA[注：本文所属Android-Lint，转载自：浅谈Android自定义Lint规则的实现 （一） 最近在做一个基于Android Lint的自定义静态代码检查功能库，这里做一个简单的总结。前半部分介绍SDK自带Android Lint的功能与配置使用方法，后半部分介绍扩展自定义Lint规则库的开发流程。 什么是Android LintAndroid Lint是一个静态代码分析工具，它能够对你的Android项目中潜在的bug、可优化的代码、安全性、性能、可用性、可访问性、国际化等进行检查。 在Android SDK Tools 16及更高的版本中，Lint工具会自动安装。通过它对Android工程源代码进行扫描和检查，可发现潜在的问题，以便程序员及早修正这个问题。Android Lint提供了命令行方式执行，还与IDE（如Android Studio）进行了集成，并提供了xml和html形式的输出报告。 看了上面的介绍可能大家依然很迷惑“这货到底有啥用”，其实我们平时在Android开发过程中一直在享受Lint带来的便利。比如，下面图中的警告和错误提示，相信大家应该很熟悉吧： 上面的例子分别是java文件与Manifest文件在接受Lint检查后给出的简要lint报告，是Lint与IDE集成后的一种表现形式。事实上，Android Lint目前能检查的项目已经多达220项，检查的范围涵盖了二进制资源文件、java源代码、class文件、gradle配置文件、xml文件、resource文件夹、其他文件等。除了图中这种与IDE结合的简洁报告形式以外，也提供更详细的html和xml形式的报告，让你对自己代码质量的提升空间有更全面的认识。 在Android Studio中，每一次编译程序时都会自动运行lint分析工具，也可以在需要lint分析的文件夹、包或文件上点击右键选择【Analyze】-&gt;【Inspect Code】。 生成的报告包含了检查过程中发现的问题，并把这些内容按照类别、优先级、严重程度进行了区分。 Lint工具的处理流程如下图所示： 图中各部分含义如下： Application source files： 构成你Android project的源文件，包含Java和XML文件，图标，以及ProGuard配置文件。 lint.xml： 配置文件，用来指定你想禁用哪些lint检查功能，以及自定义问题严重度(problem severity levels）。 lint Tool： 一个可以从命令行或Android Studio中运行的静态打码扫描工具。 lint Output： lint检查的结果，可以在命令行中通过lint查看，也可以在Android Studio的Event Log中查看。 Android Lint检查哪些内容Android Lint内置了很多lint规则，到现在为止是220项检查，总共可以分为以下几类： Correctness 正确性 Security 安全性 Performance 性能 Usability 可用性 Accessibility 可访问性 Internationalization 国际化 下面列举一些常见的lint会检测的代码问题： 缺少翻译（和未使用的翻译） 布局性能问题（老的layoutopt工具会用于查找所有这样的问题，和除此之外更多的问题） 未使用的资源 不一致的数组大小（当在多个配置中定义数组） 可访问性和国际化问题（硬编码字符串，缺少contentDescription等） 图标问题 （如丢失密度、 重复图标、 错误尺寸等） 可用性问题 （如不在文本字段上指定输入的类型） 清单错误 如果要查看lint工具支持的issue的完整列表和它们所对应的issue ID，可以使用lint –list命令。 配置Android Lint默认情况下，当你运行Lint扫描时，它会对Lint支持的所有issue进行检查。你也可以限制只让lint检查特定的issue，并为某些issue分配严重度（severity level）。比如，你可以禁止lint检查那些与你的项目无关的issue，并为lint配置一个更低的severity level来让它报告那些不是非常严重的issue。 你可以为lint检查配置不同的level： 全局（对整个project） 每个project module 每个production module 每个test module 每个open files 每个class hierarchy 每个Version Control System (VCS) scopes 在Android Studio中配置LintAndroid Studio允许你对lint每项检查单独启用或禁用，还可以对项目全局、特定文件夹、特定文件进行专门的lint配置。方法是在Android Studio中点击File &gt; Settings &gt; Project Settings菜单打开Editor-&gt;Inspections页面，里面有它支持的Profiles和Inspections列表，如图： 配置Lint文件你可以在lint.xml文件中指定你对lint检查的偏好设置。如果你要手动创建这个文件，就把它放在你的Android工程的根目录中。如果你是在Android Studio中配置lint偏好，那么lint.xml文件会自动创建并添加到你的Android工程中。 lint.xml文件的组成结构是，最外面是一对闭合的标签，里面包含一个或多个子元素。每一个被唯一的id属性来标识，整体结构如下： &lt;?xml version=”1.0” encoding=”UTF-8”?&gt;&lt;lint&gt; &lt;!– list of issues to configure –&gt;&lt;/lint&gt; 通过设置标签中的severity属性值，你可以对某个issue禁用lint检查，或者修改某个issue的严重程度（severity level）。 一个实例lint.xml文件如下所示： &lt;?xml version=”1.0” encoding=”UTF-8”?&gt;&lt;lint&gt; &lt;!– Disable the given check in this project –&gt; &lt;issue id=“IconMissingDensityFolder” severity=“ignore” /&gt; &lt;!– Ignore the ObsoleteLayoutParam issue in the specified files –&gt; &lt;issue id=“ObsoleteLayoutParam”&gt; &lt;ignore path=“res/layout/activation.xml” /&gt; &lt;ignore path=“res/layout-xlarge/activation.xml” /&gt; &lt;/issue&gt; &lt;!– Ignore the UselessLeaf issue in the specified file –&gt; &lt;issue id=“UselessLeaf”&gt; &lt;ignore path=“res/layout/main.xml” /&gt; &lt;/issue&gt; &lt;!– Change the severity of hardcoded strings to “error” –&gt; &lt;issue id=“HardcodedText” severity=“error” /&gt;&lt;/lint&gt; 在Java源文件或XML源文件中配置lint检查在Java中配置lint检查要对Android项目中某个Java类或方法禁用lint检查，只需要对那段代码添加@SuppressLint注解即可。下面的例子显示了如何对onCreate方法关闭NewApi这个issue的lint检查。lint工具仍然会对这个类的其他方法进行NewApi issue的检查。例子如下： @SuppressLint(“NewApi”)@Overridepublic void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.main); 下面的例子显示如何对FeedProvider类关闭ParserError issue的lint检查： @SuppressLint(“ParserError”)public class FeedProvider extends ContentProvider &#123; …&#125; 如果要在Java文件中禁用所有issue的lint检查，使用all关键字，比如： @SuppressLint(“all”) 在XML中配置lint检查如果要对XML文件中某一部分禁用lint检查，可以使用tools:ignore属性来标识。为了让这个属性能够被lint工具识别，必须把下面的命名空间加入你的XML中： namespace xmlns:tools=”http://schemas.android.com/tools“ 下面的例子显示了如何对XML布局文件中的元素禁用UnusedResources issue的lint检查。ignore属性会被该元素下的子元素继承，在这个例子中，子元素同样被禁用了lint检查。 &lt;LinearLayout xmlns:android=“http://schemas.android.com/apk/res/android“ xmlns:tools=“http://schemas.android.com/tools“ tools:ignore=“UnusedResources” &gt; &lt;TextView android:text=“@string/auto_update_prompt” /&gt;&lt;/LinearLayout&gt; 要禁用多个issue时，用逗号把它们分隔开，比如： tools:ignore=&quot;NewApi,StringFormatInvalid&quot; 要在某个XML元素中对所有issue都禁用lint检查，可以使用all关键字，比如： tools:ignore=&quot;all&quot; 自定义lint为什么需要自定义lint由于每个项目自身的需求，Android Lint默认的检查项目可能不能满足我们的需求。比如我们自己写了一个下拉刷新的库项目，可以让用户直接在xml布局文件中去使用它，但是我们希望用户必须在这个xml元素中定义一个pullmode属性，否则组件无法正常运行，我们希望lint能够对此进行检查，并在用户忘记添加此属性时给出明确的错误提示。再比如，我们的项目中使用了自己封装的日志库，能够方便的在release版本中关闭日志输出来防止app的效率下降，该日志库还能够把日志输出到指定的文件中方便事后分析，这时有一位新成员加入了我们的开发，他可能还是习惯性的用android.util.Log来打印日志，我们希望能够检测到本项目中所有使用了android.util.Log的代码，并发出警告。要满足这些自定义需求，我们就需要通过Android Lint的扩展机制自己定制lint规则。 自定义lint如何使用自定义lint是一个纯java项目，以jar的形式输出。有了包含lint规则的jar后，有两种使用方案： 方案一：把此jar拷贝到 ~/.android/lint/ 目录中（文件名任意）。此时，这些lint规则针对所有项目生效。 方案二：继续创建一个Android library项目，用来输出包含lint.jar的aar；然后，让目标项目依赖此aar即可使自定义lint规则生效。 由于方案一是全局生效的策略，无法单独针对目标项目，用处不大。在工程实践中，我们主要使用方案二。 AAR是Android Library的一种新的二进制分发格式，它把资源也一起打包，这样一来图片和布局资源文件也能够被同时分发。AAR格式文件能够包含一个可选的lint.jar文件，如果一个app依赖了一个包含lint.jar的aar文件，那么这个lint.jar中的规则就会在app的lint任务中被用来做lint检查。 自定义lint实现原理自定义lint规则是以jar形式存在的，主要通过继承两种类来实现扩展lint功能：①继承IssueRegistry：这是自定义Lint规则的主类或者叫注册类，有且仅有一个，用来注册这个自定义Lint项目中有哪些自定义的issue（issue就是需要lint检查出来并报告给用户的各种问题）需要被检测。②继承Detector并选择Detector中合适的XXXScanner接口来实现：在这里根据自身业务需求，实现各种自定义探测器（Detector),并定义各种issue，根据自身需求的不同这样的类可以有一个或多个。 事实上，Android系统默认的lint检查功能是通过BuiltinIssueRegistry类来定义的，在这个类的源码中可以看到定义的各种issue、detector，如图： com.android.tools.lint.detector.api.Detector提供了7种XXXScanner接口，根据自身需要选择合适的接口去实现，下面把这7个接口的信息列出： 1、JavaScanner功能：Specialized interface for detectors that scan Java source file parse trees 2、ClassScanner功能：Specialized interface for detectors that scan Java class files 3、BinaryResourceScanner功能：Specialized interface for detectors that scan binary resource files 4、ResourceFolderScanner功能：Specialized interface for detectors that scan resource folders (the folder directory itself, not the individual files within it） 5、XmlScanner功能：Specialized interface for detectors that scan XML files 6、GradleScanner功能：Specialized interface for detectors that scan Gradle files 7、OtherFileScanner功能：Specialized interface for detectors that scan other files 实现自定义Lint规则的过程，实际上就是实现detector的过程，每个detector能够定义1个或多个不同类型的issue。也就是说，一个detector能够检测多种issue，这些issue在逻辑上是有关联的，但这些issue可以拥有不同的严重程度、描述等，并能够独立地被抑制(suppress，即禁用对该issue的检查）。 自定义lint实战下面简单演示一下开发一个自定义Lint规则的完整流程。 【1】在Android Studio中，打开或新建一个工程，然后点击【File -&gt; New -&gt; New Module】，在弹出窗口中选择新建一个Java Library，如图： 我们这里把Java Library命名为ljflintrules。 【2】自定义lint规则需要继承一些特定的类，所以需要在ljflintrules的build.gradle中添加依赖: compile ‘com.android.tools.lint:lint-api:24.3.1’compile ‘com.android.tools.lint:lint-checks:24.3.1’ 【3】在ljflintrules中新建一个LoggerUsageDetector类，用来检测用户代码中是否使用了android.util.Log类，如果有，就报告一个issue，代码如下： public class LoggerUsageDetector extends Detector implements Detector.ClassScanner &#123; public static final Issue ISSUE = Issue.create(“LogUtilsNotUsed”, “You must use our LogUtils“, “Logging should be avoided in production for security and performance reasons. Therefore, we created a LogUtils that wraps all our calls to Logger and disable them for release flavor.”, Category.MESSAGES, 9, Severity.ERROR, new Implementation(LoggerUsageDetector.class, Scope.CLASS_FILE_SCOPE)); @Override public List&lt;String&gt; getApplicableCallNames() &#123; return Arrays.asList(“v”, “d”, “i”, “w”, “e”, “wtf”); &#125; @Override public List&lt;String&gt; getApplicableMethodNames() &#123; return Arrays.asList(“v”, “d”, “i”, “w”, “e”, “wtf”); &#125; @Override public void checkCall(@NonNull ClassContext context, @NonNull ClassNode classNode, @NonNull MethodNode method, @NonNull MethodInsnNode call) &#123; String owner = call.owner; if (owner.startsWith(“android/util/Log”)) &#123; context.report(ISSUE, method, call, context.getLocation(call), “You must use our LogUtils“); &#125; &#125;&#125; 这段代码中，我们定义了一个ISSUE，定义时传入的6个参数意义如下： LogUtilsNotUseds: 我们这条lint规则的id，这个id必须是独一无二的。 You must use our &#39;LogUtils&#39;：对这条lint规则的简短描述。 Logging should be avoided in production for security and performance reasons. Therefore, we created a LogUtils that wraps all our calls to Logger and disable them for release flavor.：对这条lint规则更详细的解释。 Category.MESSAGES：类别。 9：优先级，必须在1到10之间。 Severity.ERROR：严重程度。其他可用的严重程度还有FATAL、WARNING、INFORMATIONAL、IGNORE。 Implementation：这是连接Detector与Scope的桥梁，其中Detector的功能是寻找issue，而scope定义了在什么范围内查找issue。在我们的例子中，我们需要在字节码级别分析用户有没有使用android.util.Log。 这个类中针对字节码中的android/util/Log进行了检查，并在发现时报告LogUtilsNotUsed这个issue。你也可以在这个类中定义多个issue，然后在代码逻辑中（比如checkCall方法中）针对不同的情况，抛出不同的issue。也就是说，一个XXXDetector是可以报告多种issue的。如果需要检测更多问题，你也可以定义更多的XXXDetector类。XXXDetector类可以有多个。 【4】在ljflintrules中新建一个MyIssueRegistry类，它继承自IssueRegistry。这个类用来注册我们自己定义了哪些issue，这样lint在检查代码时才知道要针对哪些issue进行检查。代码如下： public class MyIssueRegistry extends IssueRegistry &#123; @Override public List&lt;Issue&gt; getIssues() &#123; System.out.println(“!!!!!!!!!!!!! ljf MyIssueRegistry lint rules works”); return Arrays.asList(LoggerUsageDetector.ISSUE); &#125;&#125; 这个类中只有一个方法，就是返回一个List，其中包含了我们自定义的所有issue。这里我们为了能够在控制台中清楚的看到我们自定义的lint规则是否被调用了，所以打印了一行提示信息。 【5】对于自定义lint生成的jar，我们必须在它的清单文件中指明它的主类。这里我们通过配置ljflintrules的build.gradle文件来完成这项工作： jar &#123; manifest &#123; attributes(‘Lint-Registry’: ‘com.ljf.lintrules.MyIssueRegistry’) &#125;&#125; 现在，你可以在控制台中通过命令./gradlew ljflintrules:assemble来执行编译任务，就可以输出我们需要的jar文件了。你可以在ljflintrules工程目录的build/libs/下找到ljflintrules.jar。 如果你想验证这个jar文件是不是真的有效，可以把它拷贝到~/.android/lint/目录下，然后在终端中输入lint –show LogUtilsNotUsed看看有没有输出我们定义的issue信息，有则表明自定义lint成功，如图： 测试完后记得把它从~/.android/lint/中删除。 【6】由于我们要把上一步生成的jar文件包含到一个aar中便于用户使用，所以我们还要在ljflintrules的build.gradle文件中添加以下信息： configurations &#123; lintJarOutput&#125;dependencies &#123; lintJarOutput files(jar)&#125;defaultTasks ‘assemble’ 经过以上所有步骤，现在ljflintrules的build.gradle文件看起来是这样的： apply plugin: ‘java’dependencies &#123; compile fileTree(dir: ‘libs’, include: [‘.jar’]) compile ‘com.android.tools.lint:lint-api:24.3.1’ compile ‘com.android.tools.lint:lint-checks:24.3.1’&#125;jar &#123; manifest &#123; attributes(‘Lint-Registry’: ‘com.ljf.lintrules.MyIssueRegistry’) &#125;&#125;configurations &#123; lintJarOutput&#125;dependencies &#123; lintJarOutput files(jar)&#125;defaultTasks ‘assemble’ 【7】新建一个Android Library项目，命名为ljflintrule_aar，用来输出aar，步骤如下： 在ljflintrule_aar的build.gradle的根节点加入以下内容： / rules for including “lint.jar” in aar /configurations &#123; lintJarImport&#125;dependencies &#123; lintJarImport project(path: “:ljflintrules”, configuration: “lintJarOutput”)&#125;task copyLintJar(type: Copy) &#123; from (configurations.lintJarImport) &#123; rename &#123; String fileName -&gt; ‘lint.jar’ &#125; &#125; into ‘build/intermediates/lint/‘&#125;project.afterEvaluate &#123; def compileLintTask = project.tasks.find &#123; it.name == ‘compileLint’ &#125; compileLintTask.dependsOn(copyLintJar)&#125; 如果这时再编译项目，就会在ljflintrule_aar的输出目录中得到一个包含lint.jar的aar文件，这里的lint.jar就是我们在第5步中生成的ljflintrules.jar，只是换了个名字。 【8】在用户app中使用我们的自定义lint。在用户自己的应用程序module中（我们这里就使用app module），打开app的build.gradle文件，在dependencies中加入以下依赖： compile project(‘:ljflintrule_aar’) 这里我们在app的MainActivity中使用了android自带的Log功能： public class MainActivity extends AppCompatActivity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); Log.d(“tag”, “dasfadsf”); &#125;&#125; 在终端中，我们执行./gradlew lint来执行lint任务，可以在终端中看到以下输出： 输出中指出发现了1个error和2个warning，并给出了详细报告的地址。 我们在浏览器中打开html格式的详细报告，如下图所示： 以上8个步骤完整演示了如何自定义lint并使用它。 小结本文对于自定义Lint规则的介绍主要是集中在总体开发流程，给出了一个简单的实例。在实际开发过程中，我们比较常见的需求是针对xml布局文件、java源代码等内容进行某些检查，受Lint开发API的限制需要用到AST的相关知识，以及lombok.ast开源库。由于lombok.ast开源库几乎无文档可用，所以还是需要花一定时间来阅读这个库的源码，并熟悉SDK自带的Lint源码如何使用这个库。如果你对自定义Lint感兴趣，可以关注下一篇文章的相关介绍。]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[尚妆统一图片压缩库算法说明]]></title>
      <url>http://fengqingxiuyi.xyz/Android/%E5%9B%BE%E7%89%87/%E5%8E%8B%E7%BC%A9/%E5%B0%9A%E5%A6%86%E7%BB%9F%E4%B8%80%E5%9B%BE%E7%89%87%E5%8E%8B%E7%BC%A9%E5%BA%93%E7%AE%97%E6%B3%95%E8%AF%B4%E6%98%8E.html</url>
      <content type="html"><![CDATA[注：本文所属Android-图片-压缩，本文主要介绍在使用Luban过程中，实际测试微信和朋友圈图片压缩后尺寸和比例的变化统计。 项目地址尚妆统一图片压缩库 算法序本图片压缩库的算法基于Luban算法步骤稍作改进。 操作流程从网上下载的81张不同尺寸的图片，依次分享到微信朋友圈，再保存到手机上，然后进行数据统计。 结论朋友圈图片压缩后比例变化 朋友圈图片压缩后尺寸变化 朋友圈图片压缩数据统计表朋友圈图片压缩数据统计表]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[vi(vim)命令]]></title>
      <url>http://fengqingxiuyi.xyz/%E5%91%BD%E4%BB%A4/vi(vim)%E5%91%BD%E4%BB%A4.html</url>
      <content type="html"><![CDATA[注：本文所属命令，本文已经忘记转载自哪里了，表示抱歉，查了很多文章，都不是完全一样。本文仅用作记录，持续更新… 介绍vi（vim）是上Linux非常常用的编辑器，很多Linux发行版都默认安装了vi(vim)。vi(vim)命令繁多但是如果使用灵活之后将会大大提高效率。vi是“visual interface”的缩写，vim是vi IMproved(增强版的vi)。在一般的系统管理维护中vi就够用，如果想使用代码加亮的话可以使用vim。 vi的3个模式1）插入模式：在此模式下可以输入字符，按ESC将回到命令模式。2）命令模式：可以移动光标、删除字符等。3）低行模式：可以保存文件、退出vi、设置vi、查找等功能(低行模式也可以看作是命令模式里的)。 vi命令大全 进入vi的命令123456vi filename :打开或新建文件，并将光标置于第一行首vi +n filename ：打开文件，并将光标置于第n行首vi + filename ：打开文件，并将光标置于最后一行首vi +/pattern filename：打开文件，并将光标置于第一个与pattern匹配的串处vi -r filename ：在上次正用vi编辑时发生系统崩溃，恢复filenamevi -o/O filename1 filename2 ... ：打开多个文件，依次进行编辑 vi 关闭文件12345:w //保存文件:w vpser.net //保存至vpser.net文件:q //退出编辑器，如果文件已修改请使用下面的命令:q! //退出编辑器，且不保存:wq //退出编辑器，且保存文件 移动光标类命令123456789101112131415161718192021222324252627h ：光标左移一个字符l ：光标右移一个字符space：光标右移一个字符Backspace：光标左移一个字符k或Ctrl+p：光标上移一行j或Ctrl+n ：光标下移一行Enter ：光标下移一行w或W ：光标右移一个字至字首b或B ：光标左移一个字至字首e或E ：光标右移一个字至字尾) ：光标移至句尾( ：光标移至句首&#125;：光标移至段落开头&#123;：光标移至段落结尾nG：光标移至第n行首n+：光标下移n行n-：光标上移n行n$：光标移至第n行尾H ：光标移至屏幕顶行M ：光标移至屏幕中间行L ：光标移至屏幕最后行0：（注意是数字零）光标移至当前行首$：光标移至当前行尾n+ //向下跳n行n- //向上跳n行nG //跳到行号为n的行G //跳至文件的底部 屏幕翻滚类命令12345Ctrl+u：向文件首翻半屏Ctrl+d：向文件尾翻半屏Ctrl+f：向文件尾翻一屏Ctrl＋b；向文件首翻一屏nz：将第n行滚至屏幕顶部，不指定n时将当前行滚至屏幕顶部。 插入文本类命令123456789101112i ：在光标前I ：在当前行首a：光标后A：在当前行尾o：在当前行之下新开一行O：在当前行之上新开一行r：替换当前字符R：替换当前字符及其后的字符，直至按ESC键s：从当前光标位置处开始，以输入的文本替代指定数目的字符S：删除指定数目的行，并以所输入文本代替之ncw或nCW：修改指定数目的字nCC：修改指定数目的行 复制、粘贴12345678yy //将当前行复制到缓存区，也可以用 "ayy 复制，"a 为缓冲区，a也可以替换为a到z的任意字母，可以完成多个复制任务。nyy //将当前行向下n行复制到缓冲区，也可以用 "anyy 复制，"a 为缓冲区，a也可以替换为a到z的任意字母，可以完成多个复制任务。yw //复制从光标开始到词尾的字符。nyw //复制从光标开始的n个单词。y^ //复制从光标到行首的内容。y$ //复制从光标到行尾的内容。p //粘贴剪切板里的内容在光标后，如果使用了前面的自定义缓冲区，建议使用"ap 进行粘贴。P //粘贴剪切板里的内容在光标前，如果使用了前面的自定义缓冲区，建议使用"aP 进行粘贴。 文本替换1234:s/old/new //用new替换行中首次出现的old:s/old/new/g //用new替换行中所有的old:n,m s/old/new/g //用new替换从n到m行里所有的old:%s/old/new/g //用new替换当前文件里所有的old 简单替换表达式1234567891011 :%s/four/4/g“%” 范围前缀表示在所有行中执行替换，最后的 “g” 标记表示替换行中的所有匹配点，如果仅仅对当前行进行操作，那么只要去掉%即可如果你有一个像 “thirtyfour” 这样的单词，上面的命令会出错。这种情况下，这个单词会被替换成”thirty4″。要解决这个问题，用 “&lt;”来指定匹配单词开头： :%s/&lt;four/4/g显然，这样在处理 “fourty” 的时候还是会出错。用 “&gt;” 来解决这个问题： :%s/&lt;four&gt;/4/g如果你在编码，你可能只想替换注释中的 “four”，而保留代码中的。由于这很难指定，可以在替换命令中加一个 “c” 标记，这样，Vim 会在每次替换前提示你： :%s/&lt;four&gt;/4/gc单词精确匹配替换sed -e "s/\&lt;old\&gt;/new/g" file 删除命令123456789101112ndw或ndW：删除光标处开始及其后的n-1个字do：删至行首d$：删至行尾ndd：删除当前行及其后n-1行x或X：删除一个字符，x删除光标后的，而X删除光标前的Ctrl+u：删除输入方式下所输入的文本x //删除当前字符nx //删除从光标开始的n个字符dd //删除当前行ndd //向下删除当前行在内的n行u //撤销上一步操作U //撤销对当前行的所有操作 搜索及替换命令1234567/pattern：从光标开始处向文件尾搜索pattern?pattern：从光标开始处向文件首搜索patternn：在同一方向重复上一次搜索命令N：在反方向上重复上一次搜索命令：s/p1/p2/g：将当前行中所有p1均用p2替代：n1,n2s/p1/p2/g：将第n1至n2行中所有p1均用p2替代：g/p1/s//p2/g：将文件中所有p1均用p2替换 选项设置1234567891011all：列出所有选项设置情况term：设置终端类型ignorance：在搜索中忽略大小写list：显示制表位(Ctrl+I)和行尾标志（$)number：显示行号report：显示由面向行的命令修改过的数目terse：显示简短的警告信息warn：在转到别的文件时若没保存当前文件则显示NO write信息nomagic：允许在搜索模式中，使用前面不带“/”的特殊字符nowrapscan：禁止vi在搜索到达文件两端时，又从另一端开始mesg：允许vi显示其他用户用write写到自己终端上的信息 最后行方式命令1234567891011：n1,n2 co n3：将n1行到n2行之间的内容拷贝到第n3行下：n1,n2 m n3：将n1行到n2行之间的内容移至到第n3行下：n1,n2 d ：将n1行到n2行之间的内容删除：w ：保存当前文件：e filename：打开文件filename进行编辑：x：保存当前文件并退出：q：退出vi：q!：不保存文件并退出vi：!command：执行shell命令command：n1,n2 w!command：将文件中n1行至n2行的内容作为command的输入并执行之，若不指定n1，n2，则表示将整个文件内容作为command的输入：r!command：将命令command的输出结果放到当前行 寄存器操作12345“?nyy：将当前行及其下n行的内容保存到寄存器？中，其中?为一个字母，n为一个数字“?nyw：将当前行及其下n个字保存到寄存器？中，其中?为一个字母，n为一个数字“?nyl：将当前行及其下n个字符保存到寄存器？中，其中?为一个字母，n为一个数字“?p：取出寄存器？中的内容并将其放到光标位置处。这里？可以是一个字母，也可以是一个数字ndd：将当前行及其下共n行文本删除，并将所删内容放到1号删除寄存器中。]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Git命令]]></title>
      <url>http://fengqingxiuyi.xyz/%E5%91%BD%E4%BB%A4/Git%E5%91%BD%E4%BB%A4.html</url>
      <content type="html"><![CDATA[注：本文所属命令，本文转载自常用 Git 命令清单，本文仅用作记录。 一般来说，日常使用只要记住下图6个命令，就可以了。但是熟练使用，恐怕要记住60～100个命令。详见下图： 下面是我整理的常用 Git 命令清单。几个专用名词的译名如下。Workspace：工作区Index / Stage：暂存区Repository：仓库区（或本地仓库）Remote：远程仓库 一、新建代码库12345678# 在当前目录新建一个Git代码库$ git init# 新建一个目录，将其初始化为Git代码库$ git init [project-name]# 下载一个项目和它的整个代码历史$ git clone [url] 二、配置Git的设置文件为.gitconfig，它可以在用户主目录下（全局配置），也可以在项目目录下（项目配置）。 123456789# 显示当前的Git配置$ git config --list# 编辑Git配置文件$ git config -e [--global]# 设置提交代码时的用户信息$ git config [--global] user.name "[name]"$ git config [--global] user.email "[email address]" 三、增加/删除文件123456789101112131415161718192021# 添加指定文件到暂存区$ git add [file1] [file2] ...# 添加指定目录到暂存区，包括子目录$ git add [dir]# 添加当前目录的所有文件到暂存区$ git add .# 添加每个变化前，都会要求确认# 对于同一个文件的多处变化，可以实现分次提交$ git add -p# 删除工作区文件，并且将这次删除放入暂存区$ git rm [file1] [file2] ...# 停止追踪指定文件，但该文件会保留在工作区$ git rm --cached [file]# 改名文件，并且将这个改名放入暂存区$ git mv [file-original] [file-renamed] 四、代码提交123456789101112131415161718# 提交暂存区到仓库区$ git commit -m [message]# 提交暂存区的指定文件到仓库区$ git commit [file1] [file2] ... -m [message]# 提交工作区自上次commit之后的变化，直接到仓库区$ git commit -a# 提交时显示所有diff信息$ git commit -v# 使用一次新的commit，替代上一次提交# 如果代码没有任何新变化，则用来改写上一次commit的提交信息$ git commit --amend -m [message]# 重做上一次commit，并包括指定文件的新变化$ git commit --amend [file1] [file2] ... 五、分支123456789101112131415161718192021222324252627282930313233343536373839404142# 列出所有本地分支$ git branch# 列出所有远程分支$ git branch -r# 列出所有本地分支和远程分支$ git branch -a# 新建一个分支，但依然停留在当前分支$ git branch [branch-name]# 新建一个分支，并切换到该分支$ git checkout -b [branch]# 新建一个分支，指向指定commit$ git branch [branch] [commit]# 新建一个分支，与指定的远程分支建立追踪关系$ git branch --track [branch] [remote-branch]# 切换到指定分支，并更新工作区$ git checkout [branch-name]# 切换到上一个分支$ git checkout -# 建立追踪关系，在现有分支与指定的远程分支之间$ git branch --set-upstream [branch] [remote-branch]# 合并指定分支到当前分支$ git merge [branch]# 选择一个commit，合并进当前分支$ git cherry-pick [commit]# 删除分支$ git branch -d [branch-name]# 删除远程分支$ git push origin --delete [branch-name]$ git branch -dr [remote/branch] 六、标签1234567891011121314151617181920212223242526# 列出所有tag$ git tag# 新建一个tag在当前commit$ git tag [tag]# 新建一个tag在指定commit$ git tag [tag] [commit]# 删除本地tag$ git tag -d [tag]# 删除远程tag$ git push origin :refs/tags/[tagName]# 查看tag信息$ git show [tag]# 提交指定tag$ git push [remote] [tag]# 提交所有tag$ git push [remote] --tags# 新建一个分支，指向某个tag$ git checkout -b [branch] [tag] 七、查看信息123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960# 显示有变更的文件$ git status# 显示当前分支的版本历史$ git log# 显示commit历史，以及每次commit发生变更的文件$ git log --stat# 搜索提交历史，根据关键词$ git log -S [keyword]# 显示某个commit之后的所有变动，每个commit占据一行$ git log [tag] HEAD --pretty=format:%s# 显示某个commit之后的所有变动，其"提交说明"必须符合搜索条件$ git log [tag] HEAD --grep feature# 显示某个文件的版本历史，包括文件改名$ git log --follow [file]$ git whatchanged [file]# 显示指定文件相关的每一次diff$ git log -p [file]# 显示过去5次提交$ git log -5 --pretty --oneline# 显示所有提交过的用户，按提交次数排序$ git shortlog -sn# 显示指定文件是什么人在什么时间修改过$ git blame [file]# 显示暂存区和工作区的差异$ git diff# 显示暂存区和上一个commit的差异$ git diff --cached [file]# 显示工作区与当前分支最新commit之间的差异$ git diff HEAD# 显示两次提交之间的差异$ git diff [first-branch]...[second-branch]# 显示今天你写了多少行代码$ git diff --shortstat "@&#123;0 day ago&#125;"# 显示某次提交的元数据和内容变化$ git show [commit]# 显示某次提交发生变化的文件$ git show --name-only [commit]# 显示某次提交时，某个文件的内容$ git show [commit]:[filename]# 显示当前分支的最近几次提交$ git reflog 八、远程同步1234567891011121314151617181920212223# 下载远程仓库的所有变动$ git fetch [remote]# 显示所有远程仓库$ git remote -v# 显示某个远程仓库的信息$ git remote show [remote]# 增加一个新的远程仓库，并命名$ git remote add [shortname] [url]# 取回远程仓库的变化，并与本地分支合并$ git pull [remote] [branch]# 上传本地指定分支到远程仓库$ git push [remote] [branch]# 强行推送当前分支到远程仓库，即使有冲突$ git push [remote] --force# 推送所有分支到远程仓库$ git push [remote] --all 九、撤销12345678910111213141516171819202122232425262728293031# 恢复暂存区的指定文件到工作区$ git checkout [file]# 恢复某个commit的指定文件到暂存区和工作区$ git checkout [commit] [file]# 恢复暂存区的所有文件到工作区$ git checkout .# 重置暂存区的指定文件，与上一次commit保持一致，但工作区不变$ git reset [file]# 重置暂存区与工作区，与上一次commit保持一致$ git reset --hard# 重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变$ git reset [commit]# 重置当前分支的HEAD为指定commit，同时重置暂存区和工作区，与指定commit一致$ git reset --hard [commit]# 重置当前HEAD为指定commit，但保持暂存区和工作区不变$ git reset --keep [commit]# 新建一个commit，用来撤销指定commit# 后者的所有变化都将被前者抵消，并且应用到当前分支$ git revert [commit]# 暂时将未提交的变化移除，稍后再移入$ git stash$ git stash pop 十、其他12# 生成一个可供发布的压缩包$ git archive]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[ADB命令]]></title>
      <url>http://fengqingxiuyi.xyz/%E5%91%BD%E4%BB%A4/ADB%E5%91%BD%E4%BB%A4.html</url>
      <content type="html"><![CDATA[注：本文所属命令，本文常用命令部分转载自Android ADB命令大全(通过ADB命令查看wifi密码、MAC地址、设备信息、操作文件、查看文件、日志信息、卸载、启动和安装APK等)，本文仅用作记录。 常用命令1234567891011121314151617181920212223242526272829303132333435363738394041424344获取序列号：adb get-serialno查看连接计算机的设备：adb devices重启机器：adb reboot重启到bootloader，即刷机模式：adb reboot bootloader重启到recovery，即恢复模式：adb reboot recovery查看log：adb logcat终止adb服务进程：adb kill-server重启adb服务进程：adb start-server获取机器MAC地址：adb shell cat /sys/class/net/wlan0/address获取CPU序列号：adb shell cat /proc/cpuinfo安装APK：adb install &lt;apkfile&gt; //比如：adb install baidu.apk保留数据和缓存文件，重新安装apk：adb install -r &lt;apkfile&gt; //比如：adb install -r baidu.apk安装apk到sd卡：adb install -s &lt;apkfile&gt; // 比如：adb install -s baidu.apk卸载APK：adb uninstall &lt;package&gt; //比如：adb uninstall com.baidu.search卸载app但保留数据和缓存文件：adb uninstall -k &lt;package&gt; //比如：adb uninstall -k com.baidu.search启动应用：adb shell am start -n &lt;package_name&gt;/.&lt;activity_class_name&gt;查看设备cpu和内存占用情况：adb shell top查看占用内存前6的app：adb shell top -m 6刷新一次内存信息，然后返回：adb shell top -n 1查询各进程内存使用情况：adb shell procrank杀死一个进程：adb shell kill [pid]查看进程列表：adb shell ps查看指定进程状态：adb shell ps -x [PID]查看后台services信息：adb shell service list查看当前内存占用：adb shell cat /proc/meminfo查看IO内存分区：adb shell cat /proc/iomem将system分区重新挂载为可读写分区：adb remount从本地复制文件到设备：adb push &lt;local&gt; &lt;remote&gt;从设备复制文件到本地：adb pull &lt;remote&gt; &lt;local&gt;列出目录下的文件和文件夹，等同于dos中的dir命令：adb shell ls进入文件夹，等同于dos中的cd 命令：adb shell cd &lt;folder&gt;重命名文件：adb shell rename path/oldfilename path/newfilename删除system/avi.apk：adb shell rm /system/avi.apk删除文件夹及其下面所有文件：adb shell rm -r &lt;folder&gt;移动文件：adb shell mv path/file newpath/file设置文件权限：adb shell chmod 777 /system/fonts/DroidSansFallback.ttf新建文件夹：adb shell mkdir path/foldelname查看文件内容：adb shell cat &lt;file&gt;查看wifi密码：adb shell cat /data/misc/wifi/*.conf清除log缓存：adb logcat -c查看bug报告：adb bugreport获取设备名称：adb shell cat /system/build.prop查看ADB帮助：adb help跑monkey：adb shell monkey -v -p your.package.name 500 开发所需命令11、adb shell dumpsys activity | grep mFocusedActivity：获取真机显示页面的Activity名称，例如：mFocusedActivity: ActivityRecord&#123;4801e67 u0 com.showjoy.ggl/.module.home.MainActivity t867&#125;]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Mac快捷键]]></title>
      <url>http://fengqingxiuyi.xyz/%E5%BF%AB%E6%8D%B7%E9%94%AE/Mac%E5%BF%AB%E6%8D%B7%E9%94%AE.html</url>
      <content type="html"><![CDATA[注：本文所属快捷键，本文不详细介绍Mac上所有的快捷键，本文主要介绍自己在Mac上常用的快捷键。 说明1231、⇧：代表的是shift键2、⌥：代表的是option键3、⌘：代表的是command键 快捷键1234567891、⇧⌘c：打开Mac的“我的电脑”2、⇧⌘g：前往自定义路径的文件夹3、先⌘c再⌥⌘v：剪切4、⌘x：剪切文字文本一类的5、⌘[：倒退到上一步，如网页之间的前进与后退6、⌘]：前进到下一步，如网页之间的前进与后退7、OS X常用快捷键：/Volumes/MAIN/qingfeng/Data/技术文章/OS X常用快捷键.jpg￼8、Mac 键盘快捷键：https://support.apple.com/zh-cn/HT201236 技巧11、开启窗口三指拖拽功能：系统偏好设置-&gt;辅助功能-&gt;左边窗口中的“鼠标与触控板”-&gt;右下角的“触控板选项…”-&gt;勾选“启用拖移”并设置为“三指拖移”然后点击“好”即可 OS X常用快捷键]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[AndroidStudio快捷键]]></title>
      <url>http://fengqingxiuyi.xyz/%E5%BF%AB%E6%8D%B7%E9%94%AE/AndroidStudio%E5%BF%AB%E6%8D%B7%E9%94%AE.html</url>
      <content type="html"><![CDATA[注：本文所属快捷键，本文已经不知道是转载的谁的了，表示抱歉，其中有一大部分和网上的应该是一样的，但是结尾部分有所不同，有兴趣的可以看一下，本文介绍一些AndroidStudio的快捷键。 查找／查看相关12345678910111213⌘O: 全局查找class类名⌘F: 在当前编辑文件中查找⌘F12: 当前编辑的文件中结构快速导航⌘E: 打开最近访问的文件列表⌥⌘O: 输入类名／方法名／字段名来查找任何匹配的类／方法／字段⇧⌘O: 全局项目查找文件（类／资源文件／布局文件都通过该快捷键查找）⌃H: 查看当前编辑class类的hierarchy结构⌥F7: 列出全局项目中该类／方法 被引用／调用的情况⌥⌘F7: 列出全局项目中该类／方法 被引用／调用的情况⌃⌥H: 方法被调用结构［method’s Call Hierarchy］⌘P: 列出函数方法一系列的有效参数，如果光标是一个方法调用的括号之间⇧⌘F7: 快速，高亮显示变量在当前文件中的引用情况,使用⌘G和⇧⌘G快捷键 可以前往跳到下一个/上一个高亮的变量，按⎋移除高亮显示F1: 查看类／方法的注释文档 控制操作相关12345678910111213⌘/: 注释与取消注释，注释效果 //…⌥⌘/: 注释与取消注释，注释效果 /*…*/⇧⌥up/down: 移动行上下移动⌘delete: 删除行⌘d: 复制行⌘J: 快速生成模版代码块，如if,while,return等⌘N: 快速生成getter／setter方法，构造方法，toString()方法等⌥⌘T: Surround with快速调出if,for,try...catch,while等环绕代码⌃O: 引入重写父类的方法［Override Methods］⌃I: 引入实现接口或抽象类方法［Implement Methods］⌃Space: 当申明一个变量时，根据变量类型提示给出建议的变量名称，等还有其他很多智能提示作用⌥⌘L: 代码格式化⌘⇧U: 切换选中内容的大小写 代码重构相关123456⇧F6: 代码重构时，类名／方法名／变量名 重命名操作⌘R: 代码重构时，可以用来批量重命名变量⌥⌘M: 方法重构，方法抽离⌥⌘P: 参数重构，将方法内变量抽离成方法参数⌥⌘V: 变量抽离，⌥⌘F: 字段抽离，将方法内的变量抽离成类字段申明,简单说就是把变量的申明从方法内重构抽离到方法外 其他12345678910111213141516171819202122232425262728293031323334353637383940F1 显示注释文档F2 高亮错误或警告快速定位Command + F12 显示当前文件的结构(查看所有方法)Command + F 查找文本Command + R 替换文本Command + O 查找类Command + E 最近打开的文件Command + 1 打开或隐藏工程面板Command + B 打开光标处的类或方法Command + X 删除行Command + D 复制行Command + P 方法参数提示Command + / 单行注释Option + Command + / 多行注释Option + Command + O 查找类中的方法或变量Option + Command + left/right 返回至上次浏览的位置Option + Command + [或] 可以跳到大括号的开头结尾Option + Command + T 可以把代码包在一块内 例如try/catchOption + Command + V new对象时快速返回变量类型及变量名Option + Command + F 选中变量名 将局部变量变成成员变量Option + Command + M 把选中内容抽取成方法Option + Command + L 格式化代码Shift + F6 重命名Shift + Option + C 对比最近修改的代码Shift + Command + U 大小写装换Shift + Command + Up/Down 代码向上/下移动Shift + Command + O 查找文件Option + F1 定位代码所在位置Option + 回车 导入包 自动修正Control + H 显示当前类的继承结构Control + Option + O 优化导入的类和包Control + Option + 空格 智能提示Control + Shift + 空格 提示类名和接口名⇧⌘A: 你可以调用任何菜单或动作的名称在Android studio中⇧⌘sapce：代码提示（Class Name Completion）shift+A: annotate在AS属性窗口中搜索postfix，可以查看类似快速编写for循环语句的步骤]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Mac上Android相关环境变量的配置]]></title>
      <url>http://fengqingxiuyi.xyz/%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/Mac%E4%B8%8AAndroid%E7%9B%B8%E5%85%B3%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E7%9A%84%E9%85%8D%E7%BD%AE.html</url>
      <content type="html"><![CDATA[注：本文所属环境变量，本文介绍在Mac上我个人常用的环境变量配置方法。 注：本文所述环境变量，只在Mac下有效 如果是针对当前用户进行环境变量的设置，只需要打开终端后，输入命令vi ~/.bash_profile即可自行配置环境变量（此处需要懂得vi的基本知识），如果没有.bash_profile文件则可以使用touch命令创建该文件： 1touch ~/.bash_profile 自行配置环境变量不做过多阐述，根据例子即可明白： 123456789101112131415#配置JAVA_HOME，此处路径根据自己的版本填写export JAVA_HOME=/Library/Java/JavaVirtualMachines/jdk1.8.0_92:.jdk/Contents/Home#把JAVA添加到到环境变量PATH中export PATH=.:$PATH:$JAVA_HOME/bin#配置CLASSPATHexport CLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar#设置gradle的主目录export GRADLE_HOME="/Applications/Android Studio.app/Contents/gradle/gradle-2.10/"#把JAVA添加到到环境变量PATH中export PATH=$PATH:$GRADLE_HOME/bin#配置NDK环境变量export PATH=$PATH:/Volumes/MAIN/qingfeng/Software/sdk/platform-toolsexport NDK_ROOT=/Volumes/MAIN/qingfeng/Software/android-ndk-r10eexport PATH=$PATH:$NDK_ROOT 配置完成后，使用以下命令即可使环境变量生效： 1source ~/.bash_profile]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[通用BaseAtapter]]></title>
      <url>http://fengqingxiuyi.xyz/Android/View/Atapter/%E9%80%9A%E7%94%A8BaseAtapter.html</url>
      <content type="html"><![CDATA[注：本文所属Android-View-Adapter，用于实现一个通用的BaseAdapter类，统一产品的Adapter类，作为一个工具类，加快敏捷开发的步骤。 序我们在开发项目的过程中，经常会用到ListView、GridView这一类的控件，从而不可避免的会用到BaseAtapter。然后我们必须实现那四个方法(getCount、getItem、getItemId、getView)，编写类似的代码，实在是太繁琐了。因此，我们需要创建一个通用的BaseAdapter来解决我们的难题。 继承BaseAdapter既然我们想要创建一个通用的BaseAdapter，那肯定需要继承于BaseAdapter，然后由于需要从外部传递data到adapter中进行处理，data的格式又是多样化的，所以我们需要使用泛型来解决这个问题，于是有了这样的代码： 123456789101112131415161718192021public class CommonAdapter extends BaseAdapter &#123; @Override public int getCount() &#123; return 0; &#125; @Override public Object getItem(int position) &#123; return null; &#125; @Override public long getItemId(int position) &#123; return 0; &#125; @Override public View getView(int position, View convertView, ViewGroup parent) &#123; return null; &#125;&#125; 创建构造方法接着就是同样的套路了，即创建构造方法，接收最为基本的上下文和data。于是有了，这样的代码： 1234567protected Context context;protected List&lt;T&gt; data;public CommonAdapter(Context context, List&lt;T&gt; data) &#123; this.context = context; this.data = data;&#125; 差点忘了还有布局文件了，如果你的SDK支持LayoutRes注解的话，那就再好不过了，只需要一行代码就可以搞定了： 1public abstract @LayoutRes int getLayoutId(); 如果不支持的话，也没有关系，从构造方法传入即可，但是这样其实不太好。 数据处理得到外部传入的数据之后，我们需要在那四个方法中进行一些基本的操作了，如判空操作： 1234567891011121314151617181920212223242526/** * @see android.widget.Adapter#getCount() */@Overridepublic int getCount() &#123; return null == data ? 0 : data.size();&#125;/** * @see android.widget.Adapter#getItem(int) */@Overridepublic T getItem(int position) &#123; if (null == data || data.size() &lt;= position) &#123; return null; &#125; return data.get(position);&#125;/** * @see android.widget.Adapter#getItemId(int) */@Overridepublic long getItemId(int position) &#123; return position;&#125; getView方法比较复杂，相对于其他三个方法而言，所以在这里就单独讲解，由于getView方法是需要ViewHolder类来进行协助管理的，所以在执行getView方法中的具体操作之前，需要先创建一个ViewHolder类 创建ViewHolder获得ViewHolder实例首先因为holder的相关操作都是在getView方法中执行的，所以，我们需要的参数有这么几个：position、convertView、parent，又因为我们之后需要在ViewHolder类中进行数据展示，所以必不可少的参数还有这两个：context、layoutId。有了这5个参数之后，我们就可以大干一场了： 我们可以创建一个静态方法，用于获取ViewHolder的实例，如下代码： 1234567891011public static ViewHolder get(Context context, View convertView, ViewGroup parent, int layoutId, int position) &#123; if (null == convertView) &#123; return new ViewHolder(context, parent, layoutId, position); &#125; else &#123; ViewHolder holder = (ViewHolder) convertView.getTag(); holder.mPosition = position; return holder; &#125;&#125; 创建构造方法根据上述代码，我们显然已经知道了构造方法的内容了，如下所示： 12345public ViewHolder(Context context, ViewGroup parent, int layoutId, int position) &#123; this.mPosition = position; this.mConvertView = LayoutInflater.from(context).inflate(layoutId, parent, false); this.mConvertView.setTag(this);&#125; getView既然我们已经处理好了ViewHolder类，那么现在就让我们来解决getView这个问题吧！其实我们只需要执行以下三步就可以了： 获得ViewHolder实例； 将需要传递出去的ViewHolder实例、指定位置的数据传递出去； 返回ViewHolder中获得的mConvertView 即如下代码： 12345678910111213/** * @see android.widget.Adapter#getView(int, View, ViewGroup) */@Overridepublic View getView(int position, View convertView, ViewGroup parent) &#123; ViewHolder holder = ViewHolder.get(context, convertView, parent, getLayoutId(), position); convert(holder, getItem(position), position); return holder.getConvertView();&#125;public abstract void convert(ViewHolder holder, T t, int position); 显示数据最后让我们重新回到ViewHolder类中，之前我已经说过了，我们需要在ViewHolder类中展示数据，所以我们需要创建一个方法，用于支持通过viewId获取控件。 这意味着我们需要将通过mConvertView.findViewById(viewId)获得的数据存储起来，然后在需要用到的地方取出来，这个时候你也许想起了，这不就是map么，是的，不过我不建议用map进行操作，这里我使用的SparseArray。 存储View这里我们首先需要在构造方法中创建SparseArray的实例，并将其定义为全局变量。 12345678910public &lt;T extends View&gt;T getView(int viewId) &#123; View view = mViews.get(viewId); if (null == view) &#123; view = mConvertView.findViewById(viewId); mViews.put(viewId, view); &#125; return (T) view;&#125; 获取View进行数据展示的操作有很多种，这里我就以最简单的显示文字内容为例： 12345public ViewHolder setText(int viewId, String text) &#123; TextView tv = getView(viewId); tv.setText(text); return this;&#125; 这句话表明当我们在自己的adapter类中重写了convert方法后，只需要使用holder实例，调用setText方法，并传递viewId和text内容就可以正常显示文本了！ 总结至此，我们的通用BaseAdapter就已经全部完工了，这里我就不公布源代码了，大家自行研究就会懂了。 对于获取View那一节，你可能会觉得比较麻烦，因为之后想要显示图片，我要在ViewHolder类中添加一个显示图片方法；想要设置背景，还需要在ViewHolder类中添加一个设置背景的方法……我想说这其实并没有什么，因为这对于整个项目都是通用的，只要设置一遍就可以了，如果你不想让ViewHoder类发生变化，也可以试试提取出来，记得告诉我哦，蟹蟹~😄]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[declare-styleable中format详解]]></title>
      <url>http://fengqingxiuyi.xyz/Android/View/%E8%87%AA%E5%AE%9A%E4%B9%89View/%E5%B1%9E%E6%80%A7/declare-styleable%E4%B8%ADformat%E8%AF%A6%E8%A7%A3.html</url>
      <content type="html"><![CDATA[注：本文所属Android-View-自定义View-属性，本文转载自：declare-styleable中format详解 我们在做项目的时候，由于android自带的属性不能满足需求，android提供了自定义属性的方法，其中的format是做什么用的？以及如何使用它？下面列出一些常用的。 reference：参考某一资源ID。（1）属性定义： 123&lt;declare-styleable name = "名称"&gt; &lt;attr name = "background" format = "reference" /&gt;&lt;/declare-styleable&gt; （2）属性使用： 1234&lt;ImageView android:layout_width = "42dip" android:layout_height = "42dip" android:background = "@drawable/图片ID"/&gt; color：颜色值。（1）属性定义： 123&lt;declare-styleable name = "名称"&gt; &lt;attr name = "textColor" format = "color" /&gt;&lt;/declare-styleable&gt; （2）属性使用： 1234&lt;TextView android:layout_width = "42dip" android:layout_height = "42dip" android:textColor = "#00FF00"/&gt; boolean：布尔值。（1）属性定义： 123&lt;declare-styleable name = "名称"&gt; &lt;attr name = "focusable" format = "boolean" /&gt;&lt;/declare-styleable&gt; （2）属性使用： 1234&lt;Button android:layout_width = "42dip" android:layout_height = "42dip" android:focusable = "true"/&gt; dimension：尺寸值。（1）属性定义： 123&lt;declare-styleable name = "名称"&gt; &lt;attr name = "layout_width" format = "dimension" /&gt;&lt;/declare-styleable&gt; （2）属性使用： 123&lt;Button android:layout_width = "42dip" android:layout_height = "42dip"/&gt; float：浮点值。（1）属性定义： 1234&lt;declare-styleable name = "AlphaAnimation"&gt; &lt;attr name = "fromAlpha" format = "float" /&gt; &lt;attr name = "toAlpha" format = "float" /&gt;&lt;/declare-styleable&gt; （2）属性使用： 123&lt;alpha android:fromAlpha = "1.0" android:toAlpha = "0.7"/&gt; integer：整型值。（1）属性定义： 12345678&lt;declare-styleable name = "AnimatedRotateDrawable"&gt; &lt;attr name = "visible" /&gt; &lt;attr name = "frameDuration" format="integer" /&gt; &lt;attr name = "framesCount" format="integer" /&gt; &lt;attr name = "pivotX" /&gt; &lt;attr name = "pivotY" /&gt; &lt;attr name = "drawable" /&gt;&lt;/declare-styleable&gt; （2）属性使用： 1234567&lt;animated-rotate xmlns:android = "http://schemas.android.com/apk/res/android" android:drawable = "@drawable/图片ID" android:pivotX = "50%" android:pivotY = "50%" android:framesCount = "12" android:frameDuration = "100"/&gt; string：字符串。（1）属性定义： 123&lt;declare-styleable name = "MapView"&gt; &lt;attr name = "apiKey" format = "string" /&gt;&lt;/declare-styleable&gt; （2）属性使用： 1234&lt;com.google.android.maps.MapView android:layout_width = "fill_parent" android:layout_height = "fill_parent" android:apiKey = "0jOkQ80oD1JL9C6HAja99uGXCRiS2CGjKO_bc_g"/&gt; fraction：百分数。（1）属性定义： 12345678&lt;declare-styleable name="RotateDrawable"&gt; &lt;attr name = "visible" /&gt; &lt;attr name = "fromDegrees" format = "float" /&gt; &lt;attr name = "toDegrees" format = "float" /&gt; &lt;attr name = "pivotX" format = "fraction" /&gt; &lt;attr name = "pivotY" format = "fraction" /&gt; &lt;attr name = "drawable" /&gt;&lt;/declare-styleable&gt; （2）属性使用： 12345678910&lt;rotate xmlns:android = "http://schemas.android.com/apk/res/android" android:interpolator = "@anim/动画ID" android:fromDegrees = "0" android:toDegrees = "360" android:pivotX = "200%" android:pivotY = "300%" android:duration = "5000" android:repeatMode = "restart" android:repeatCount = "infinite"/&gt; enum：枚举值。（1）属性定义： 123456&lt;declare-styleable name="名称"&gt; &lt;attr name="orientation"&gt; &lt;enum name="horizontal" value="0" /&gt; &lt;enum name="vertical" value="1" /&gt; &lt;/attr&gt;&lt;/declare-styleable&gt; （2）属性使用： 123456&lt;LinearLayout xmlns:android = "http://schemas.android.com/apk/res/android" android:orientation = "vertical" android:layout_width = "fill_parent" android:layout_height = "fill_parent"&gt;&lt;/LinearLayout&gt; flag：位或运算。（1）属性定义： 1234567891011121314&lt;declare-styleable name="名称"&gt; &lt;attr name="windowSoftInputMode"&gt; &lt;flag name = "stateUnspecified" value = "0" /&gt; &lt;flag name = "stateUnchanged" value = "1" /&gt; &lt;flag name = "stateHidden" value = "2" /&gt; &lt;flag name = "stateAlwaysHidden" value = "3" /&gt; &lt;flag name = "stateVisible" value = "4" /&gt; &lt;flag name = "stateAlwaysVisible" value = "5" /&gt; &lt;flag name = "adjustUnspecified" value = "0x00" /&gt; &lt;flag name = "adjustResize" value = "0x10" /&gt; &lt;flag name = "adjustPan" value = "0x20" /&gt; &lt;flag name = "adjustNothing" value = "0x30" /&gt; &lt;/attr&gt;&lt;/declare-styleable&gt; （2）属性使用： 123456789&lt;activity android:name = ".StyleAndThemeActivity" android:label = "@string/app_name" android:windowSoftInputMode = "stateUnspecified | stateUnchanged | stateHidden"&gt; &lt;intent-filter&gt; &lt;action android:name = "android.intent.action.MAIN" /&gt; &lt;category android:name = "android.intent.category.LAUNCHER" /&gt; &lt;/intent-filter&gt;&lt;/activity&gt; 特别要注意： 属性定义时可以指定多种类型值。 （1）属性定义： 123&lt;declare-styleable name = "名称"&gt; &lt;attr name = "background" format = "reference|color" /&gt;&lt;/declare-styleable&gt; （2）属性使用： 1234&lt;ImageView android:layout_width = "42dip" android:layout_height = "42dip" android:background = "@drawable/图片ID|#00FF00"/&gt;]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[attr和styleable的关系]]></title>
      <url>http://fengqingxiuyi.xyz/Android/View/%E8%87%AA%E5%AE%9A%E4%B9%89View/%E5%B1%9E%E6%80%A7/attr%E5%92%8Cstyleable%E7%9A%84%E5%85%B3%E7%B3%BB.html</url>
      <content type="html"><![CDATA[注：本文所属Android-View-自定义View-属性，本文转载自：深入理解Android 自定义attr Style styleable以及其应用 注：本文只截取了其中的attr和styleable的关系部分，其他部分可以查看原文，进行研究。 attr和styleable的关系首先要明确一点，attr不依赖于styleable，styleable只是为了方便attr的使用。 我们自己定义属性完全可以不放到styleable里面，比如直接在resources文件中定义一些属性： 12&lt;attr name="custom_attr1" format="string" /&gt;&lt;attr name="custom_attr2" format="string" /&gt; 定义一个attr就会在R文件里面生成一个Id，那么我们去获取这个属性时，必须调用如下代码： 12int[] custom_attrs = &#123;R.attr.custom_attr1,R.custom_attr2&#125;;TypedArray typedArray = context.obtainStyledAttributes(set,custom_attrs); 而通过定义一个styleable，我们可以在R文件里自动生成一个int[]，数组里面的int就是定义在styleable里面的attr的id。所以我们在获取属性的时候就可以直接使用styleable数组来获取一系列的属性。 1234&lt;declare-styleable name="custom_attrs"&gt; &lt;attr name="custom_attr1" format="string" /&gt; &lt;attr name="custom_attr2" format="string" /&gt;&lt;/declare-styleable&gt; 获取： 1TypedArray typedArray = context.obtainStyledAttributes(set,R.styleable.custom_attrs); 由上面的例子可以知道，定义一个declare-styleable，在获取属性的时候为我们自动提供了一个属性数组。此外，我觉得使用declare-styleable的方式有利于我们我们把相关的属性组织起来，有一个分组的概念，属性的使用范围更加明确。]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[属性的设置与使用]]></title>
      <url>http://fengqingxiuyi.xyz/Android/View/%E8%87%AA%E5%AE%9A%E4%B9%89View/%E5%B1%9E%E6%80%A7/%E5%B1%9E%E6%80%A7%E7%9A%84%E8%AE%BE%E7%BD%AE%E4%B8%8E%E4%BD%BF%E7%94%A8.html</url>
      <content type="html"><![CDATA[注：本文所属Android-View-自定义View-属性，为了将某些公用的View抽取成通用的View，我们需要用到自定义View，而且一般情况下，为了方便快捷，我们需要在布局文件中就设置好值，所以我们需要学会运用属性。接下来就让我们一起进入实战演练一番吧！ 案例：比如说我们编写一个ShopCheckItem类，继承于RelativeLayout，用来作为自定义的View，那么我们需要执行以下几个步骤： 编写布局文件首先我们需要编写布局文件，不要问为什么，自定义View的办法有很多种，本文只讲这种办法，慢慢看你就懂了！ 1234567891011121314151617181920212223242526272829&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android" android:layout_width="match_parent" android:layout_height="wrap_content" android:paddingLeft="20dp" android:paddingRight="20dp"&gt; &lt;com.showjoy.view.SHIconFontTextView android:id="@+id/view_shop_check_item_icon" android:layout_width="32dp" android:layout_height="32dp"/&gt; &lt;TextView android:id="@+id/view_shop_check_item_name" android:layout_width="wrap_content" android:layout_height="wrap_content" android:layout_centerVertical="true" android:layout_marginLeft="5dp" android:layout_toRightOf="@id/view_shop_check_item_icon" android:textColor="@color/black" android:textSize="16sp" /&gt; &lt;ImageView android:id="@+id/view_shop_check_item_selected" android:layout_width="25dp" android:layout_height="25dp" android:layout_alignParentRight="true"/&gt;&lt;/RelativeLayout&gt; 自定义属性接着根据布局，发现我们需要这样一些属性，如：icon、name、selected。于是我们就可以在styles.xml文件中编写自定义的属性了，具体代码如下所示： 123456&lt;declare-styleable name="ShopCheckItem"&gt; &lt;attr name="shop_check_item_icon" format="string" /&gt; &lt;attr name="shop_check_item_name" format="string" /&gt; &lt;attr name="shop_check_item_name_color" format="color" /&gt; &lt;attr name="shop_check_item_selected" format="boolean" /&gt;&lt;/declare-styleable&gt; 自定义View编写好属性后，我们就可以开始自定义view的编写了，一般包括以下几个步骤： 使用inflate方式将布局转换为View找到布局文件中得控件即findViewById获取在布局文件中自定义属性的值根据自定义属性的值初始化控件暴露接口注意：接口不一定是interface，只要是提供给别人用的，就算是一个public方法也是接口，如果不清楚，可以查看这篇文章：接口回调 所以，完整代码如下所示： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182package com.showjoy.shop.common.view;import android.content.Context;import android.content.res.TypedArray;import android.text.TextUtils;import android.util.AttributeSet;import android.widget.ImageView;import android.widget.RelativeLayout;import android.widget.TextView;import com.showjoy.shop.R;import com.showjoy.view.SHIconFontTextView;/** * Created by qingfeng on 7/20/16. */public class ShopCheckItem extends RelativeLayout &#123; private SHIconFontTextView viewShopCheckItemIcon; private TextView viewShopCheckItemName; private ImageView viewShopCheckItemSelected; public ShopCheckItem(Context context) &#123; super(context); init(context, null); &#125; public ShopCheckItem(Context context, AttributeSet attrs) &#123; super(context, attrs); init(context, attrs); &#125; public ShopCheckItem(Context context, AttributeSet attrs, int defStyleAttr) &#123; super(context, attrs, defStyleAttr); init(context, attrs); &#125; private void init(Context context, AttributeSet attrs) &#123; inflate(context, R.layout.view_pay_method, this); viewShopCheckItemIcon = (SHIconFontTextView) findViewById(R.id.view_shop_check_item_icon); viewShopCheckItemName = (TextView) findViewById(R.id.view_shop_check_item_name); viewShopCheckItemSelected = (ImageView) findViewById(R.id.view_shop_check_item_selected); if (null != attrs) &#123; TypedArray typeArray = context.obtainStyledAttributes(attrs, R.styleable.ShopCheckItem); String icon = typeArray.getString(R.styleable.ShopCheckItem_shop_check_item_icon); if (!TextUtils.isEmpty(icon)) &#123; viewShopCheckItemIcon.setText(icon); &#125; String name = typeArray.getString(R.styleable.ShopCheckItem_shop_check_item_name); if (!TextUtils.isEmpty(name)) &#123; viewShopCheckItemName.setText(name); &#125; int color = typeArray.getColor(R.styleable.ShopCheckItem_shop_check_item_name_color, context.getResources().getColor(R.color.grey5)); viewShopCheckItemName.setTextColor(color); boolean selected = typeArray.getBoolean(R.styleable.ShopCheckItem_shop_check_item_selected, false); if (selected) &#123; viewShopCheckItemSelected.setImageResource(R.mipmap.view_shop_check_item_selected); &#125; else &#123; viewShopCheckItemSelected.setImageResource(R.drawable.view_shop_check_item_unselected); &#125; typeArray.recycle(); &#125; &#125; public void setSelected(boolean selected) &#123; if (selected) &#123; viewShopCheckItemIcon.setTextColor(getContext().getResources().getColor(R.color.black)); viewShopCheckItemName.setTextColor(getContext().getResources().getColor(R.color.black)); viewShopCheckItemSelected.setImageResource(R.mipmap.view_shop_check_item_selected); &#125; else &#123; viewShopCheckItemIcon.setTextColor(getContext().getResources().getColor(R.color.grey5)); viewShopCheckItemName.setTextColor(getContext().getResources().getColor(R.color.grey5)); viewShopCheckItemSelected.setImageResource(R.drawable.view_shop_check_item_unselected); &#125; &#125;&#125; 总结是不是很简单，自定义View就是这么简单，当然自定义View不止这么一种方式咯，大家可以自行探索，然后在下方评论区域告诉我，蟹蟹~😄]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Mac+GitHub+Hexo+NexT使用注意点]]></title>
      <url>http://fengqingxiuyi.xyz/MGHN/Mac+GitHub+Hexo+NexT%E4%BD%BF%E7%94%A8%E6%B3%A8%E6%84%8F%E7%82%B9.html</url>
      <content type="html"><![CDATA[注：本文所属MGHN，本文专门用于记录在使用Hexo博客过程中遇到的一些（奇葩的）问题。 favicon不显示当我们在搭建Hexo博客的时候，必然会自定义favicon.ico，显示在网页选项卡的左上角，如图所示： 设置favicon也很简单，只需要在主题配置文件（_config.yml）中，进行如下操作即可： 12# Put your favicon.ico into `hexo-site/source/` directory.favicon: /images/Blog/favicon.ico 如果favicon的路径设置正确，而且清除了缓存，刷新了页面好几次，但favicon仍然不显示的话，可以等待一段时间，再去刷新，可能就会显示了！ 404问题现象：从首页点击某篇文章跳转到了404页面！ 分析：既然出现了404页面，那么必定是路径问题；仔细检查路径发现，原来是以前名为mou.md的文件，现在变成了Mou.md。所以在github上路径中文件夹的名字仍然是mou，而不是Mou。 解决：本来以为只需要执行以下命令就可以了： 1Blog$ hexo clean &amp;&amp; hexo g &amp;&amp; hexo d 后来发现自己还是太年轻了，因为hexo clean的只是本地的文件，和github完全没有关系，之后想了半天也毫无头绪，于是另辟蹊径：将Mou.md文件再重命名一下，如Mou2.md，执行上述命令之后，再重命名回Mou.md，再执行上述命令就可以了。😄 总结：当我在重命名md文件时，切忌不可只是进行了大小写转换，因为像这样把文章部署到github上之后，文件名对应的文件夹是不会发生变化的！！！]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[ListView-Header]]></title>
      <url>http://fengqingxiuyi.xyz/Android/View/ListView/ListView-Header.html</url>
      <content type="html"><![CDATA[注：本文所属Android-View-ListView，本文主要介绍ListView的Header显示问题。 问：ListView没有数据时怎么显示Header？ 答：只要ListView不设置为GONE，然后再setAdapter之前添加了headerView，就会显示Header。]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[TextView占位符]]></title>
      <url>http://fengqingxiuyi.xyz/Android/View/TextView/TextView%E5%8D%A0%E4%BD%8D%E7%AC%A6.html</url>
      <content type="html"><![CDATA[注：本文所属Android-View-TextView，用于介绍如何为一句话中的某些数据设置占位符再显示。 这个其实很简单，这里我就直接上例子了： 1textView.setText(String.format("%s考了%d分", "小明", 88); 想必大家一看就懂了，置于那些想要深入研究，还有哪些占位符的小伙伴们，可以看以下文章： Java魔法堂：String.format详解]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[ImageView引用图片上下方空白]]></title>
      <url>http://fengqingxiuyi.xyz/Android/View/ImageView/ImageView%E5%BC%95%E7%94%A8%E5%9B%BE%E7%89%87%E4%B8%8A%E4%B8%8B%E6%96%B9%E7%A9%BA%E7%99%BD.html</url>
      <content type="html"><![CDATA[注：本文所属Android-View-ImageView，本文主要介绍如何解决ImageView引用图片上下方空白的问题。 疑问疑问：当我们将一张图片引用到我们指定的ImageView容器中，可能由于图片尺寸、比例等原因，无法铺满整个容器（表述不好），导致白边的出现，而且怎么去也去不掉。如下布局代码： 12345678910111213141516&lt;LinearLayout android:layout_width="match_parent" android:layout_height="match_parent" android:orientation="vertical"/&gt; &lt;ImageView android:layout_width="match_parent" android:layout_height="wrap_content" android:src="@mipmap/share_invite"/&gt; &lt;TextView android:layout_width="wrap_content" android:layout_height="wrap_content" android:text="测试空白区域文本"/&gt;&lt;/LinearLayout&gt; 如上述布局代码，本身没有任何问题，但是因为图片的尺寸，比例等原因，就可能出现图片和文本之间存在空白区域的问题。 解决那么怎么解决呢？ 其实很简单，我们只需要为ImageView添加以下属性就可以了： 1android:adjustViewBounds="true" adjustViewBounds我想，你一定会问，这句话代表着什么意思？为什么这样就可以了呢？这里我就给大家简要解释一下： Google官方对于adjustViewBounds这个属性是这样介绍的： 谷歌原文：Set this to true if you want the ImageView to adjust its bounds to preserve the aspect ratio of its drawable. 个人翻译（不喜勿喷）：如果你想要ImageView适应边界，同时保持图片宽高比，可以将它设置为true。 我们也可以这样理解：将 android:adjustViewBounds 设置为true，即可去除因图片宽高比等原因导致ImageView直接引用图片时上下方存在空白区域的问题。 注意点图片本身上下方无空白区域!!!]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[设置Hint字体大小]]></title>
      <url>http://fengqingxiuyi.xyz/Android/View/EditText/%E8%AE%BE%E7%BD%AEHint%E5%AD%97%E4%BD%93%E5%A4%A7%E5%B0%8F.html</url>
      <content type="html"><![CDATA[注：本文所属Android-View-EditText，本文主要介绍如何为EditText的Hint设置字体大小。 设置Hint字体大小通常有以下两种方式： 静态设置静态设置即在布局文件中设置相关属性。 很简单，我们只要在布局文件中，在EditText标签下设置textSize即可实现，但是有些情况好像设置了也没有用，尚不清楚。 动态设置动态设置即在代码中动态实现Hint字体大小，有以下两种情况： 已在布局中设置好Hint值1234567891011private void setHint(EditText editText, int fontSize) &#123; CharSequence hint = registerGoodsName.getHint(); // 新建一个可以添加属性的文本对象 SpannableString ss = new SpannableString(hint); // 新建一个属性对象,设置文字的大小 AbsoluteSizeSpan ass = new AbsoluteSizeSpan(fontSize, true); // 附加属性到文本 ss.setSpan(ass, 0, ss.length(), Spanned.SPAN_EXCLUSIVE_EXCLUSIVE); // 设置hint editText.setHint(new SpannedString(ss)); // 一定要进行转换,否则属性会消失&#125; 未在布局中设置好Hint值12345678910private void setHint(EditText editText, String hint, int fontSize) &#123; // 新建一个可以添加属性的文本对象 SpannableString ss = new SpannableString(hint); // 新建一个属性对象,设置文字的大小 AbsoluteSizeSpan ass = new AbsoluteSizeSpan(fontSize, true); // 附加属性到文本 ss.setSpan(ass, 0, ss.length(), Spanned.SPAN_EXCLUSIVE_EXCLUSIVE); // 设置hint editText.setHint(new SpannedString(ss)); // 一定要进行转换,否则属性会消失&#125;]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[接口回调]]></title>
      <url>http://fengqingxiuyi.xyz/Android/Wiki/%E6%8E%A5%E5%8F%A3%E5%9B%9E%E8%B0%83.html</url>
      <content type="html"><![CDATA[注：本文所属Android-Wiki，本文主要介绍接口回调的相关知识。 接口的概念接口的概念：使用 interface 关键字来声明，可以看做是一种特殊的抽象类，可以指定一个类必须做什么，而不是规定它如何去做。 接口的分类个人看法：接口分为以下两种： 情况一：狭义的接口：即上述所述(接口的概念)。 情况二：广义的接口：即为了给其他类调用而存在。 接下来依次讲述一番他们的使用方法： 狭义的接口情况一：狭义的接口（本文所述为同步回调），即使用 interface 关键字来声明，通常需要经历以下几个步骤： （1）定义接口 Callback ,包含回调方法 click()，该接口可以重新定义一个，也可以在其他类（如：adapter类）内部，具体代码如下： 123public interface Callback &#123; void click();&#125; （2）在需要设置接口回调的类中“注册接口”，比如类名为Caller，具体代码如下： 1234private Callback callback;public void setCallback(Callback callback) &#123; this.callback = callback;&#125; （3）在需要设置接口回调的位置，调用回调方法，例如，为了解耦，需要将adapter中得点击事件回调到外部activity进行操作，具体代码如下： 12345adapterView.setOnClickListener(v -&gt; &#123; if (null != callback) &#123; callback.click(); &#125;&#125;); （4）在activity类中监听回调，具体代码如下： 123456new Caller().setCallback(new Callback() &#123; @Override public void click() &#123; // do something... &#125;&#125;); 广义的接口情况二：广义的接口：即为了给其他类调用而存在 这种情况非常多，比如说，你自定义了一个View，但是缺少了给这个View设置颜色的方法，这个时候我们就可以定义一个公共的setColor方法，提供给外部调用，这就是一个接口，具体执行步骤如下所示： （1）在自定义的View中定义如下方法： 123public void setColor(int color) &#123; this.setColor(context.getResources().getColor(color));&#125; （2）在activity中调用该方法即可： 1activityView.setColor(android.R.color.black); 总结至此接口回调就讲完了，如果想要深入理解接口回调机制，可以查看以下文章： 一个经典例子让你彻彻底底理解java回调机制]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[将layout转换为Bitmap]]></title>
      <url>http://fengqingxiuyi.xyz/Android/View/Bitmap/%E5%B0%86layout%E8%BD%AC%E6%8D%A2%E4%B8%BABitmap.html</url>
      <content type="html"><![CDATA[注：本文所属Android-View-Bitmap，本文主要介绍如何将layout转换为Bitmap，以及遇到的一些坑。 （1）编写好要转换为图片的布局文件，必须设置根控件的id。 （2）在要执行该业务的类中使用View.inflate的方式将布局转换为View。 （3）转换为View之后，找到布局文件中的控件，并为其设置数据，如果无需设置可省略。 （4）将View添加到要执行该业务的类的某个控件中，并将这个控件设置为invisible，便于隐藏渲染。注意：此控件的父控件应该为RealtiveLayout，避免出现空白区域，影响用户体验。 （5）调用以下方法，将layout转换为Bitmap： 12345678public void layout2Bitmap(ViewGroup viewGroup) &#123; int width = viewGroup.getMeasuredWidth(); int height = viewGroup.getMeasuredHeight(); Bitmap b = Bitmap.createBitmap(width, height, Bitmap.Config.RGB_565); Canvas canvas = new Canvas(b); viewGroup.draw(canvas); img.setImageBitmap(b);&#125; （6）注意：执行完第4步后，不能立刻执行第5步，因为此时页面可能还没有渲染完毕，直接执行第5步会导致提示width和height必须大于0的异常发生，需要根据业务需要，在合适的地方执行。]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[获取指定包名下的Activity]]></title>
      <url>http://fengqingxiuyi.xyz/Android/Wiki/%E8%8E%B7%E5%8F%96%E6%8C%87%E5%AE%9A%E5%8C%85%E5%90%8D%E4%B8%8B%E7%9A%84Activity.html</url>
      <content type="html"><![CDATA[注：本文所属Android-Wiki，本文主要介绍如何获取指定包名下的所有Activity，并实现Activity的跳转。 Activity类文件12345678910111213141516171819202122232425262728public void getActivities(Context context) &#123; PackageInfo packageInfo; try &#123; packageInfo = context.getPackageManager().getPackageInfo( context.getPackageName(), PackageManager.GET_ACTIVITIES); List&lt;String&gt; activityNames = new ArrayList&lt;&gt;(); List&lt;ActivityInfo&gt; activityInfos = Arrays.asList(packageInfo.activities); // 将activityInfos中的name添加到集合activityNames中 for (ActivityInfo activityInfo : activityInfos) &#123; activityNames.add(activityInfo.name.substring(activityInfo.name.lastIndexOf(".")+1)); &#125; // 显示ListView if (activityNames != null) &#123; testListview.setAdapter(new ArrayAdapter&lt;&gt;(context, android.R.layout.simple_list_item_1, activityNames)); &#125; // 跳转到指定的Activity页面 testListview.setOnItemClickListener((parent, view, position, id) -&gt; &#123; try &#123; activity.startActivity(new Intent(activity, Class.forName(activityInfos.get(position).name))); &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; &#125;); &#125; catch (PackageManager.NameNotFoundException e) &#123; e.printStackTrace(); &#125;&#125; 布局文件1234567891011121314&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android" android:layout_width="match_parent" android:layout_height="match_parent" android:background="@color/black"&gt; &lt;ListView android:id="@+id/test_listview" android:layout_width="match_parent" android:layout_height="wrap_content" android:divider="@color/white" android:dividerHeight="1dp" /&gt;&lt;/RelativeLayout&gt;]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Android模板制作]]></title>
      <url>http://fengqingxiuyi.xyz/Android/%E6%A8%A1%E6%9D%BF/Android%E6%A8%A1%E6%9D%BF%E5%88%B6%E4%BD%9C.html</url>
      <content type="html"><![CDATA[注：本文所属Android-框架，本文详细介绍模板相关的知识和如何制作Android模版及使用，便于较少不必要的工作。 本文专门介绍和模板相关的知识，那么问题来了： 模板是什么 模板使用位置 模板如何创建(包含模板存放位置) 模板如何使用 接下来，我就按照以上顺序为大家解读看起来高大上的模板。 警告本文所有模板路径均为Mac下的路径，Windows用户也可以查看路径中的相关信息，进而快速定位。 模板是什么个人理解：模板即为了帮助人们简化某些固定而繁琐的操作而制作的工具，用于快速实现这些固定而繁琐的操作。 模板使用位置当我们在使用AndroidStudio进行开发的时候，将鼠标选中工程项目，然后右击可以在New选项下面看到很多AndroidStudio提供给我们的模板类别，例如：Activity、AIDL等。具体可看下图： 细心的你会发现在这些模板的上面有一个选项，叫：Edit File Templates…，如下图所示： 点击这个选项，会进入自定义模板页面，其中内置的变量在页面下方都有解释，是不是很方便，但是它有一个致命的缺点：一次只能创建一个java文件。具体可看下图： 因为觉得这个很简单，所以我就不做过多阐述了，接下来我就仔细阐述一下，如何一次创建多个java文件，而且还可以选择是否包含xml文件。 模板如何创建(包含模板存放位置)警告如果直接复制相关代码的话，请注意其中的注释，可能会带来一些问题，如果出现问题，可以把#开头的注释去除，再尝试！！！ 如果不懂上面这段话的意思的话，可以先行跳过。 FreeMarkerAndroidStudio的模板是使用FreeMarker模板引擎制作的，有兴趣的可以了解一下。 本文参考：http://www.i-programmer.info/professional-programmer/resources-and-tools/6845-android-adt-template-format-document.html 案例&amp;解答案例： 由于现在的项目使用的是类MVP架构，所以基本上每个模块都需要entity、request、activity、presenter、viewmodel这五个类，无论是登录注册模块，还是商品详情页、首页、收益页面等模块，都无法摆脱这几个类，因此准备为这个类MVP架构制作一个通用模板。 解答： 制作好模板之后，我想说，其实很简单，只是把会变化的部分用${...}替换罢了，不过在这里我们还是老老实实的从头开始吧！ 步骤模板存放位置首页我们进入AndroidStudio安装目录下的/plugins/android/lib/templates文件夹，这就是AndroidStudio模板文件的目录了，到这里你可能还有所迷惑，因为你没有发现像我刚开始所说的Activity、AIDL等模板文件，没关系，你再进入activities文件夹下面就可以看到Activity的相关模板了，进入other文件夹就可以看到AIDL的相关模板了。 模板副本这里我们选择activities文件夹，然后你是不是觉得手足无措，不知道如何下手？其实一开始我也不知道怎么做，但是没关系，AndroidStudio不是已经提供给我们这么多模板了么，为了简单起见，我们在这里拷贝一份EmptyActivity，并将其重命名为MVPActivity，放在当前目录下。 目录结构打开文件夹后，我们看到以下目录结构： 123456789EmptyActivity |----globals.xml.ftl # 全局变量文件 |----recipe.xml.ftl # 配置要引用的模板路径以及生成文件的路径 |----root |----src |----app_package |----SimpleActivity.java.ftl # 模板文件 |----template_blank_activity.png # 创建模板时界面左边的预览图 |----template.xml # 模板的配置信息以及要输入的参数 接下我们可以根据目录结构顺序（建议按以下顺序看），打开看一下，这里大致介绍一下： globals.xml.ftlglobals.xml.ftl中都是类似 1&lt;global id="hasNoActionBar" type="boolean" value="false" /&gt; 这样的语句，显然它的意思就是我定义了一个全局变量hasNoActionBar，它的类型是boolean，默认值为false。 recipe.xml.ftlrecipe.xml.ftl稍微有些复杂，这里讲解以下instantiate、open等几个重要参数： copy：复制–将from中的文件复制到to路径下，但并不会将ftl中得变量进行转换，即如果源文件中的类名为${activityClass}，复制过后类名还是${activityClass}转换为我们需要的类名。 merge：合并–将from中的文件合并到to路径下的文件中。 instantiate：和copy类似，也是将from中的文件复制到to路径下，但是它会将${activityClass}转换为我们需要的类名。其实有这样一个过程：ftl-&gt;freemarker process -&gt; java。 open：代码生成后，打开file中指定的文件。 SimpleActivity.java.ftl打开SimpleActivity.java.ftl文件，会发现和我们创建Activity类后及其类似，只是把包名、类名、布局名等用${...}替换了，其实${...}中得内容都是id名，这里不做过多阐述，我们继续往下看。 template.xmltemplate.xml：打开以后你会发现这个文件好长，看来是重头戏了！！！是的，我们来详细解读一下： 一眼看去是不是和AndroidManifest.xml中得Application节点中的内容结构很相似（包括Application节点） 12345678910111213141516171819202122232425262728293031&lt;?xml version="1.0"?&gt;&lt;template format="5" # The template format version that this template adheres to. Should be 3 revision="5" # 可选，当你想更新模板的时候可以以整数的形式增加此模板的版本号 name="Empty Activity" # 模板显示的名字 minApi="7" # 可选，模板所需的最小API值，IDE将确保在实例化模板之前，目标工程的minSdkVersion不低于这个值 minBuildApi="14" # 可选，模板所需的最小编译API，值为API级别，IDE将确保在实例化模板之前，项目工程的API等级大于或等于这个值 description="Creates a new empty activity"&gt; # 模板的描述信息 &lt;category value="Activity" /&gt; # 模板类型，用于在菜单栏File-New下显示，如Activity、AIDL等 &lt;formfactor value="Mobile" /&gt; # 如同我们在创建module时所显示的类型，如：Wear、TV等。 &lt;parameter id="activityClass" # 唯一标示，在ftl文件中可以用$&#123;activityClass&#125;获取参数值 name="Activity Name" # 创建模板时在文本框左边显示的该文本框名称 type="string" # 这个参数的类型，如：string, boolean, enum等 constraints="class|unique|nonempty" # 可选，这个参数的约束类型，可用|符号联合使用，constraints值类型大全请看4.5 suggest="$&#123;layoutToActivity(layoutName)&#125;" # 可选，自动提示，比如输入layout的值可以自动生成activityClass default="MainActivity" # 可选，参数默认值，创建模板时在文本框中显示，相当于hint help="The name of the activity class to create" /&gt; # 创建模板时，选中文本框后，在底部显示的关于该文本框的帮助信息 &lt;!-- 128x128 thumbnails relative to template.xml --&gt; &lt;thumbs&gt; &lt;!-- default thumbnail is required --&gt; &lt;thumb&gt;template_blank_activity.png&lt;/thumb&gt; # 可选，用于创建模板时，在左边显示名为template_blank_activity的预览图片 &lt;/thumbs&gt; &lt;globals file="globals.xml.ftl" /&gt; # 可选，将工程定义的全局变量包含进来 &lt;execute file="recipe.xml.ftl" /&gt; # 开始执行模板渲染&lt;/template&gt; constraints值类型大全123456789101112Valid constraint types are: nonempty — the value must not be empty apilevel — the value should represent a numeric API level package — the value should represent a valid Java package name class — the value should represent a valid Java class name activity — the value should represent a fully-qualified activity class name layout — the value should represent a valid layout resource name drawable — the value should represent a valid drawable resource name string — the value should represent a valid string resource name id — the value should represent a valid id resource name unique — the value must be unique; this constraint only makes sense when other constraints are specified, such as layout, which would mean that the value should not represent an existing layout resource name exists — the value must already exist; this constraint only makes sense when other constraints are specified, such as layout, which would mean that the value should represent an existing layout resource name template.xml制作到这里相信大家对template.xml文件有了一定的了解了，好了，让我们来大干一场吧！ MVP版template.xml既然这里详细的讲解了template.xml文件，我们先从template.xml文件入手吧，这里我就不一个个细说了，直接上完整代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384&lt;?xml version="1.0"?&gt;&lt;template format="2" # 可修改，此处已修改 revision="2" # 可修改，此处已修改 name="MVP Activity" # 需要修改 minApi="7" # 可修改 minBuildApi="14" # 可修改 description="Creates a new MVP activity"&gt; # 需要修改 &lt;category value="AAShowJoyMVP" /&gt; # 可修改，此处已修改 &lt;formfactor value="Mobile" /&gt; # 一般不修改 &lt;parameter # Activity类 id="activityClass" # 可修改 name="Activity Name" # 可修改 type="string" # 一般不修改 constraints="class|unique|nonempty" # 一般不修改 default="TestActivity" # 可修改，此处已修改 help="The name of the activity class to create" /&gt; # 可修改，此处未修改 &lt;parameter # Activity类的布局文件 id="layoutName" name="Layout Name" type="string" constraints="layout|unique|nonempty" suggest="$&#123;classToResource(activityClass)&#125;_activity" # 可修改，此处已修改，若不明白可以跳过，之后会有详解！！！ default="test_activity" help="The name of the layout to create for the activity" /&gt; &lt;parameter # 是否作为启动Activity id="isLauncher" name="Launcher Activity" type="boolean" default="false" # 默认非启动Activity help="If true, this activity will have a CATEGORY_LAUNCHER intent filter, making it visible in the launcher" /&gt; &lt;parameter # 包名 id="packageName" name="Package name" type="string" constraints="package" default="com.showjoy.shop" /&gt; &lt;parameter # viewModel类 id="viewModelClass" name="View Model Name" type="string" constraints="class|nonempty|unique" default="TestViewModel" suggest="$&#123;underscoreToCamelCase(classToResource(activityClass))&#125;ViewModel" # 此类同布局文件，之后会有详解！！！ help="The name of the ViewModel to create" /&gt; &lt;parameter # presenter类 id="presenterClass" name="Presenter Name" type="string" constraints="class|nonempty|unique" default="TestPresenter" suggest="$&#123;underscoreToCamelCase(classToResource(activityClass))&#125;Presenter" help="The name of the Presenter to create" /&gt; &lt;parameter # request类 id="requestClass" name="Request Name" type="string" constraints="class|nonempty|unique" default="TestRequest" suggest="$&#123;underscoreToCamelCase(classToResource(activityClass))&#125;Request" help="The name of the Request to create" /&gt; &lt;parameter # entity类 id="entityClass" name="Entity Name" type="string" constraints="class|nonempty|unique" default="TestEntity" suggest="$&#123;underscoreToCamelCase(classToResource(activityClass))&#125;Entity" help="The name of the Entity to create" /&gt; &lt;globals file="globals.xml.ftl" /&gt; # 一般不修改 &lt;execute file="recipe.xml.ftl" /&gt; # 一般不修改&lt;/template&gt; template.xml文件的使用到这里就结束了，还是比较简单的，以下阐述之前所留下的两个问题： （1） 1suggest="$&#123;classToResource(activityClass)&#125;_activity" classToResource(activityClass)：这句话的意思是，当我们在创建该模板后，在activityClass对应的文本框中输入某个值，比如：test，它会直接在layoutName对应的文本框中显示，即：test，所以以完整的语句（1）而言，此时layoutName对应的文本框中显示的应该是test_activity。 （2） 1suggest="$&#123;underscoreToCamelCase(classToResource(activityClass))&#125;ViewModel" classToResource(activityClass)在（1）中描述的已经很清楚了，即为test，那么underscoreToCamelCase又是什么意思呢？其实就是将test转换为驼峰命名的方法，即Test。所以以完整的语句（2）而言，此时viewModelClass对应的文本框中显示的应该是TestViewModel。 如果你觉得文字描述过于繁琐，仍然看不懂的话，可以查看以下gif： MVP版目录结构接下来我们就可以把要制作成模板的类，拷贝到相应的文件夹中，此时的目录结构为： 12345678910111213141516MVPActivity |----globals.xml.filter |----recipe.xml.ftl |----activity_layout_recipe.xml.filter # 此文件与recipe类似，只是因为解耦思想，所以将class和layout分别引入 |----root |----src |----app_package |----classes |----Activity.java.ftl |----Entity.java.ftl |----Presenter.java.ftl |----Request.java.ftl |----ViewModel.java.ftl |----layout |----activity_layout.xml.ftl |----template.xml Request.java.ftl为了方便而又全面的进行讲解，此处我们以Request.java.ftl文件为例，这里我就直接上全部代码了： 12345678910111213141516171819202122232425package $&#123;packageName&#125;.request; # $&#123;packageName&#125;对应的是template.xml文件中id为packageName的参数设置的字符串，如果该类不在包名根目录下，可以在后面添加相应的module名。import android.support.annotation.NonNull; # 如果包名中未涉及到在创建模板时设置的包名和类名，则无需修改import $&#123;packageName&#125;.entities.$&#123;entityClass&#125;; # 如果包名中涉及到在创建模板时设置的包名和类名，则只需相对应的进行修改即可/** * 将以下涉及到在创建模板时设置的包名和类名，进行如下相对应的替换即可，布局文件也是这样替换的！！！ */public class $&#123;requestClass&#125; extends SHGetRequest&lt;$&#123;entityClass&#125;&gt; &#123; @Override protected Class&lt;$&#123;entityClass&#125;&gt; getDataClass() &#123; return $&#123;entityClass&#125;.class; &#125; @Override protected TypeReference&lt;$&#123;entityClass&#125;&gt; getDataTypeReference() &#123; return null; &#125; @NonNull @Override protected String getRequestUrl() &#123; return null; &#125;&#125; 布局文件接下来我们来看一下布局文件的替换： 123456789&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android" xmlns:tools="http://schemas.android.com/tools" android:layout_width="match_parent" android:layout_height="match_parent" tools:context="$&#123;relativePackage&#125;.$&#123;activityClass&#125;"&gt;&lt;/RelativeLayout&gt; 虽然说tools命名空间一般都是可有可无的，这里为了全面，也讲述以下，你应该发现了一个从未见过的id：relativePackage，不用迷惑，估计你也想到了，其实我就是在globals.xml.ftl文件中定义了一个全局变量而已，它的值默认为包名，具体代码如下： 1&lt;global id="relativePackage" type="string" value="$&#123;packageName&#125;"/&gt; globals.xml.ftl既然说到了globals.xml.ftl文件，我们就去看看好了： 12345678910&lt;?xml version="1.0"?&gt;&lt;globals&gt; &lt;global id="hasNoActionBar" type="boolean" value="false" /&gt; &lt;global id="parentActivityClass" value="" /&gt; &lt;global id="simpleLayoutName" value="$&#123;layoutName&#125;" /&gt; &lt;global id="excludeMenu" type="boolean" value="true" /&gt; &lt;global id="generateActivityTitle" type="boolean" value="false" /&gt; &lt;global id="relativePackage" type="string" value="$&#123;packageName&#125;"/&gt; &lt;#include "../common/common_globals.xml.ftl" /&gt;&lt;/globals&gt; 其实并没有什么，global代表的都是全局变量，#include代表的是引用的文件，相当于继承。 recipe.xml.ftl然后就只有recipe.xml.ftl文件了，也快结束了： 123456789101112131415161718192021222324252627&lt;?xml version="1.0"?&gt;&lt;recipe&gt; &lt;#include "../common/recipe_manifest.xml.ftl" /&gt; # 引入同级目录中的activity_layout_recipe.xml.ftl文件，其内容会在下一节中讲述 &lt;#include "activity_layout_recipe.xml.ftl" /&gt; &lt;instantiate from="src/app_package/classes/Activity.java.ftl" to="$&#123;escapeXmlAttribute(srcOut)&#125;/$&#123;activityClass&#125;.java" /&gt; &lt;instantiate from="src/app_package/classes/ViewModel.java.ftl" to="$&#123;escapeXmlAttribute(srcOut)&#125;/$&#123;viewModelClass&#125;.java" /&gt; &lt;instantiate from="src/app_package/classes/Entity.java.ftl" to="$&#123;escapeXmlAttribute(srcOut)&#125;/entities/$&#123;entityClass&#125;.java" /&gt; &lt;instantiate from="src/app_package/classes/Presenter.java.ftl" to="$&#123;escapeXmlAttribute(srcOut)&#125;/$&#123;presenterClass&#125;.java" /&gt; &lt;instantiate from="src/app_package/classes/Request.java.ftl" to="$&#123;escapeXmlAttribute(srcOut)&#125;/request/$&#123;requestClass&#125;.java" /&gt; &lt;open file="$&#123;escapeXmlAttribute(srcOut)&#125;/$&#123;viewModelClass&#125;.java" /&gt; &lt;open file="$&#123;escapeXmlAttribute(resOut)&#125;/layout/$&#123;layoutName&#125;.xml" /&gt;&lt;/recipe&gt; instantiate的作用在上面已经讲的很清楚了，简单来说就是将ftl文件转换为java文件，而open指的是在创建模板成功后，打开指定的文件，很简单吧，这里只有一个注意点：路径 不要写错了！！！ 12$&#123;escapeXmlAttribute(srcOut)&#125;代表的即为包名所代表的路径$&#123;escapeXmlAttribute(resOut)&#125;代表的是res根目录 activity_layout_recipe.xml.ftl之前因为解耦思想，所以把布局文件的recipe文件单独处理了，即为activity_layout_recipe.xml.ftl，打开文件，其实很简单： 123456&lt;recipe&gt; &lt;instantiate from="src/app_package/layout/activity_layout.xml.ftl" to="$&#123;escapeXmlAttribute(resOut)&#125;/layout/$&#123;layoutName&#125;.xml" /&gt;&lt;/recipe&gt; 这里就不做阐述了，大家看上一节就明白了。 模板如何使用模板创建好之后，我们首先需要的是验证是否能够正确创建出我们需要的部分，且没有错误发生，这个过程其实就是模板使用的过程，具体可以参考第2章模板使用位置。 总结至此，Android模板制作已经全部完成了，本文篇幅还是比较长的，如果有什么疑问可以评论，我会尽力解决每一个问题的，谢谢，码字好累额！！！]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[支付宝支付-注意点]]></title>
      <url>http://fengqingxiuyi.xyz/Android/%E6%94%AF%E4%BB%98%E5%AE%9D/%E6%94%AF%E4%BB%98%E5%AE%9D%E6%94%AF%E4%BB%98-%E6%B3%A8%E6%84%8F%E7%82%B9.html</url>
      <content type="html"><![CDATA[注：本文所属Android-支付宝，由于支付宝SDK对于整个支付流程已经介绍的十分详细了，在这里我就简单说一些注意点。 由于存在支付宝可能没有安装的情况，所以我们在调用支付宝支付时，需要对其进行判断，做出不同的处理方式，即是使用客户端支付，还是使用H5支付，这里简单阐述一下： 情况一：已安装支付宝客户端1234567891011121314151617181920212223242526272829303132333435363738394041424344/** * 唤醒支付宝支付 * @param data 服务端返回订单数据 */public void payOrder(JSONObject data) &#123; registerLoadingView.setVisibility(View.GONE); String redirectStr = data.getString("redirectStr"); if (!TextUtils.isEmpty(redirectStr)) &#123; // 唤醒支付宝支付 Thread payThread = new Thread(() -&gt; &#123; PayTask alipay = new PayTask(activity); String result = alipay.pay(redirectStr); Message msg = Message.obtain(); msg.what = MSG_PAY_RESPONSE; msg.obj = result; handler.sendMessage(msg); &#125;); payThread.start(); &#125;&#125;Handler handler = new Handler(msg -&gt; &#123; if (MSG_PAY_RESPONSE == msg.what) &#123; Result result = new Result((String) msg.obj); if (!TextUtils.isEmpty(result.getResult())) &#123; switch (result.getResult()) &#123; case "4000": // 系统异常 TODO Toast.makeText(context, "订单支付失败", Toast.LENGTH_SHORT).show(); break; case "6001": // 用户中途取消支付操作 TODO Toast.makeText(context, "订单支付已被取消", Toast.LENGTH_SHORT).show(); break; case "6002": // 网络连接出错 TODO Toast.makeText(context, "网络连接出错", Toast.LENGTH_SHORT).show(); break; case "9000": // 操作成功 TODO Toast.makeText(context, "订单支付成功", Toast.LENGTH_SHORT).show(); // TODO do something... break; &#125; &#125; &#125; return false;&#125;); 情况二：未安装支付宝客户端需要在Androidmanifest.xml文件中加入以下代码，即可进入H5支付流程。 1234567&lt;!-- 支付宝 --&gt;&lt;activity android:name="com.alipay.sdk.app.H5PayActivity" android:configChanges="orientation|keyboardHidden|navigation" android:exported="false" android:screenOrientation="behind" android:windowSoftInputMode="adjustResize|stateHidden" /&gt;]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[支付宝支付-相关网址]]></title>
      <url>http://fengqingxiuyi.xyz/Android/%E6%94%AF%E4%BB%98%E5%AE%9D/%E6%94%AF%E4%BB%98%E5%AE%9D%E6%94%AF%E4%BB%98-%E7%9B%B8%E5%85%B3%E7%BD%91%E5%9D%80.html</url>
      <content type="html"><![CDATA[注：本文所属Android-支付宝，本文只是介绍一下关于支付宝支付的相关网址信息，便于大家快速定位到指定位置。 资源下载网址：App支付DEMO&amp;SDK 内容： App支付DEMO&amp;SDKApp支付功能（支付产品全面升级，若您使用的是老接口，请移步老版本移动支付文档。） 说明 链接 iOS&amp;Android版资源 说明：iOS版SDK已支持IPv6_only网络 SDK&amp;DEMO iOS&amp;Android版资源（适用于集成了百川sdk，出现UTDID冲突） SDK 支付调用网址：App支付Android集成流程详解]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[微信支付-相关网址]]></title>
      <url>http://fengqingxiuyi.xyz/Android/%E5%BE%AE%E4%BF%A1/%E6%94%AF%E4%BB%98/%E5%BE%AE%E4%BF%A1%E6%94%AF%E4%BB%98-%E7%9B%B8%E5%85%B3%E7%BD%91%E5%9D%80.html</url>
      <content type="html"><![CDATA[注：本文所属Android-微信-支付，本文只是介绍一下关于微信支付的相关网址信息，便于大家快速定位到指定位置。 资源下载网址：Android资源下载 内容： Android资源下载 开发工具包（SDK）使用微信分享、登录、收藏、支付等功能需要的库以及文件。点击下载&nbsp;Android开发工具包使用微信语音识别接口、语音合成接口。点击下载&nbsp;语音SDK+Demo+开发文档使用微信图像识别接口。点击下载&nbsp;图像SDK+Demo+开发文档使用微信卡券功能接口。点击下载&nbsp;卡券SDK+开发文档范例代码包含了一个完整的范例工程。该范例的使用可以参阅Android平台上手指南：HelloWeixin@Android。点击下载签名生成工具用于获取安装到手机的第三方应用签名的apk包。点击下载&nbsp;签名生成工具 支付调用网址：APP支付调用]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[类微信图片压缩算法]]></title>
      <url>http://fengqingxiuyi.xyz/Android/%E5%9B%BE%E7%89%87/%E5%8E%8B%E7%BC%A9/%E7%B1%BB%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87%E5%8E%8B%E7%BC%A9%E7%AE%97%E6%B3%95.html</url>
      <content type="html"><![CDATA[注：本文所属Android-图片-压缩，本文主要介绍Luban的算法。 原文出处：https://github.com/Curzibn/Luban/blob/master/DESCRIPTION.md 官方网址：https://github.com/Curzibn/Luban/ 前言Luban 是图片压缩工具，通过参考或者自创压缩规则推求极致的压缩效果目前的版本压缩效果主要参考微信。因为微信用户量最大，如果压缩后的图片越接近微信则越被用户接受。 说明目前的 Luban 只是压缩结果接近微信，自身的算法只是为了达到这个效果而设计的。与微信并无任何联系，也不敢妄称是微信的算法。 算法步骤注：下文所说“比例”统一表示：图片短边除以长边为该图片比例 第三挡压缩（参考最新版微信压缩效果） 判断图片比例值，是否处于以下区间内； [1, 0.5625) 即图片处于 [1:1 ~ 9:16) 比例范围内 [0.5625, 0.5) 即图片处于 [9:16 ~ 1:2) 比例范围内 [0.5, 0) 即图片处于 [1:2 ~ 1:∞) 比例范围内 判断图片最长边是否过边界值； [1, 0.5625) 边界值为：1664 n（n=1）, 4990 n（n=2）, 1280 * pow(2, n-1)（n≥3） [0.5625, 0.5) 边界值为：1280 * pow(2, n-1)（n≥1） [0.5, 0) 边界值为：1280 * pow(2, n-1)（n≥1） 计算压缩图片实际边长值，以第2步计算结果为准，超过某个边界值则：width / pow(2, n-1)，height/pow(2, n-1) 计算压缩图片的实际文件大小，以第2、3步结果为准，图片比例越大则文件越大。 size = (newW newH) / (width height) * m； [1, 0.5625) 则 width &amp; height 对应 1664，4990，1280 * n（n≥3），m 对应 150，300，300； [0.5625, 0.5) 则 width = 1440，height = 2560, m = 200； [0.5, 0) 则 width = 1280，height = 1280 / scale，m = 500；注：scale为比例值 判断第4步的size是否过小 [1, 0.5625) 则最小 size 对应 60，60，100 [0.5625, 0.5) 则最小 size 都为 100 [0.5, 0) 则最小 size 都为 100 6.将前面求到的值压缩图片 width, height, size 传入压缩流程，压缩图片直到满足以上数值 附以上具体数值均由逆推微信朋友圈所得]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[类微信图片压缩使用]]></title>
      <url>http://fengqingxiuyi.xyz/Android/%E5%9B%BE%E7%89%87/%E5%8E%8B%E7%BC%A9/%E7%B1%BB%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87%E5%8E%8B%E7%BC%A9%E4%BD%BF%E7%94%A8.html</url>
      <content type="html"><![CDATA[注：本文所属Android-图片-压缩，本文主要介绍Luban的使用。 原文出处：https://github.com/Curzibn/Luban/blob/master/README.md 官方网址：https://github.com/Curzibn/Luban/ LubanLuban(鲁班)——Android图片压缩工具，仿微信朋友圈压缩策略 项目描述目前做app开发总绕不开图片这个元素。但是随着手机拍照分辨率的提升，图片的压缩成为一个很重要的问题。单纯对图片进行裁切，压缩已经有很多文章介绍。但是裁切成多少，压缩成多少却很难控制好，裁切过头图片太小，质量压缩过头则显示效果太差。 于是自然想到app巨头“微信”会是怎么处理，Luban(鲁班)就是通过在微信朋友圈发送近100张不同分辨率图片，对比原图与微信压缩后的图片逆向推算出来的压缩算法。 因为有其他语言也想要实现 Luban，所以描述了一遍算法步骤 因为是逆向推算，效果还没法跟微信一模一样，但是已经很接近微信朋友圈压缩后的效果，具体看以下对比！ 效果与对比 内容 原图 Luban Wechat 截屏 720P 720*1280,390k 720*1280,87k 720*1280,56k 截屏 1080P 1080*1920,2.21M 1080*1920,104k 1080*1920,112k 拍照 13M(4:3) 3096*4128,3.12M 1548*2064,141k 1548*2064,147k 拍照 9.6M(16:9) 4128*2322,4.64M 1032*581,97k 1032*581,74k 滚动截屏 1080*6433,1.56M 1080*6433,351k 1080*6433,482k 导入compile &apos;io.reactivex:rxandroid:1.2.1&apos; compile &apos;io.reactivex:rxjava:1.1.6&apos; compile &apos;top.zibin:Luban:1.0.5&apos; 使用Listener方式Luban内部采用io线程进行图片压缩，外部调用只需设置好结果监听即可 Luban.get(this) .load(File) //传人要压缩的图片 .putGear(Luban.THIRD_GEAR) //设定压缩档次，默认三挡 .setCompressListener(new OnCompressListener() { //设置回调 @Override public void onStart() { //TODO 压缩开始前调用，可以在方法内启动 loading UI } @Override public void onSuccess(File file) { //TODO 压缩成功后调用，返回压缩后的图片文件 } @Override public void onError(Throwable e) { //TODO 当压缩过去出现问题时调用 } }).launch(); //启动压缩 RxJava方式RxJava 调用方式请自行随意控制线程 Luban.get(this) .load(file) .putGear(Luban.THIRD_GEAR) .asObservable() .subscribeOn(Schedulers.io()) .observeOn(AndroidSchedulers.mainThread()) .doOnError(new Action1&lt;Throwable&gt;() { @Override public void call(Throwable throwable) { throwable.printStackTrace(); } }) .onErrorResumeNext(new Func1&lt;Throwable, Observable&lt;? extends File&gt;&gt;() { @Override public Observable&lt;? extends File&gt; call(Throwable throwable) { return Observable.empty(); } }) .subscribe(new Action1&lt;File&gt;() { @Override public void call(File file) { //TODO 压缩成功后调用，返回压缩后的图片文件 } }); LicenseCopyright 2016 Zheng Zibin Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[细说Android事件传递机制]]></title>
      <url>http://fengqingxiuyi.xyz/Android/%E4%BA%8B%E4%BB%B6%E4%BC%A0%E9%80%92%E6%9C%BA%E5%88%B6/%E7%BB%86%E8%AF%B4Android%E4%BA%8B%E4%BB%B6%E4%BC%A0%E9%80%92%E6%9C%BA%E5%88%B6.html</url>
      <content type="html"><![CDATA[注：本文所属Android-事件传递机制，本文主要介绍以下几个类：dispatchTouchEvent、onInterceptTouchEvent、onTouchEvent，本文转载自：http://blog.csdn.net/yanzi1225627/article/details/22592831 本文背景:前些天用到了之前写的自定义图片文字复合控件，在给他设置监听时遇到了麻烦。虽然最后解决了问题，但发现在不重写LinearLayout的onInterceptTouchEvent时，子ImageView、子TextView、父Linearlayout三者不同的属性配置(android:clickable android:focuseable)会造成自定义控件onClick监听失败、或成功。复写了父Linearlayout 的onInterceptTouchEvent时，监听不受子图片、子文字的属性影响。为知其所以然，深入研究android的事件传递机制，记录于此。一、View的dispatchTouchEvent和onTouchEvent 探讨Android事件传递机制前，明确android的两大基础控件类型:View和ViewGroup。View即普通的控件，没有子布局的，如Button、TextView. ViewGroup继承自View，表示可以有子控件，如Linearlayout、Listview这些。而事件即MotionEvent，最重要的有3个:(1)MotionEvent.ACTION_DOWN &nbsp;按下View，是所有事件的开始(2)MotionEvent.ACTION_MOVE &nbsp; 滑动事件(3)MotionEvent.ACTION_UP &nbsp; &nbsp; &nbsp; 与down对应，表示抬起 另外，明确事件传递机制的最终目的都是为了触发执行View的点击监听和触摸监听: **.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View v) { // TODO Auto-generated method stub Log.i(tag, &quot;testLinelayout—onClick…&quot;); } }); *.setOnTouchListener(new View.OnTouchListener() { @Override public boolean onTouch(View v, MotionEvent event) { // TODO Auto-generated method stub return false; } }); 我们简称为onClick监听和onTouch监听，一般程序会注册这两个监听。从上面可以看到，onTouch监听里默认return false。不要小看了这个return false，后面可以看到它有大用。 对于View来说，事件传递机制有两个函数：dispatchTouchEvent负责分发事件，在dispatch*里又会调用onTouchEvent表示执行事件，或者说消费事件，结合源码分析其流程。事件传递的入口是View的dispatchTouchEvent()函数: / Pass the touch screen motion event down to the target view, or this view if it is the target. @param event The motion event to be dispatched. @return True if the event was handled by the view, false otherwise. / public boolean dispatchTouchEvent(MotionEvent event) { if (mInputEventConsistencyVerifier != null) { mInputEventConsistencyVerifier.onTouchEvent(event, 0); } if (onFilterTouchEventForSecurity(event)) { //noinspection SimplifiableIfStatement ListenerInfo li = mListenerInfo; if (li != null &amp;&amp; li.mOnTouchListener != null &amp;&amp; (mViewFlags &amp; ENABLED_MASK) == ENABLED &amp;&amp; li.mOnTouchListener.onTouch(this, event)) { return true; } if (onTouchEvent(event)) { return true; } } if (mInputEventConsistencyVerifier != null) { mInputEventConsistencyVerifier.onUnhandledEvent(event, 0); } return false; }找到这个判断:&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (li != null &amp;&amp; li.mOnTouchListener != null &amp;&amp; (mViewFlags &amp; ENABLED_MASK) == ENABLED&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;&amp; li.mOnTouchListener.onTouch(this, event)) {&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return true;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }他会执行View的OnTouchListener.onTouch这个函数，也就是上面说的onTouch监听。里面有三个判断，如果三个都为1，就会执行return true，不往下走了。而默认的onTouch监听返回false，只要一个是false，就不会返回true。接着往下看，程序执行onTouchEvent： if (onTouchEvent(event)) { return true; }onTouchEvent的源码比较多，贴最重要的: if (!mHasPerformedLongPress) { // This is a tap, so remove the longpress check removeLongPressCallback(); // Only perform take click actions if we were in the pressed state if (!focusTaken) { // Use a Runnable and post this rather than calling // performClick directly. This lets other visual state // of the view update before click actions start. if (mPerformClick == null) { mPerformClick = new PerformClick(); } if (!post(mPerformClick)) { performClick(); } } }可以看到有个performClick(),它的源码里有这么一句&nbsp;li.mOnClickListener.onClick(this); public boolean performClick() { sendAccessibilityEvent(AccessibilityEvent.TYPE_VIEW_CLICKED); ListenerInfo li = mListenerInfo; if (li != null &amp;&amp; li.mOnClickListener != null) { playSoundEffect(SoundEffectConstants.CLICK); li.mOnClickListener.onClick(this); return true; } return false; }终于对上了，它执行了我们注册的onClick监听。当然执行前会经过一系列判断，是否注册了监听等。总结:1、事件入口是dispatchTouchEvent(),它会先执行注册的onTouch监听,如果一切顺利的话，接着执行onTouchEvent，在onTouchEvent里会执行onClick监听。2、无论是dispatchTouchEvent还是onTouchEvent，如果返回true表示这个事件已经被消费、处理了，不再往下传了。在dispathTouchEvent的源码里可以看到，如果onTouchEvent返回了true，那么它也返回true。如果dispatch在执行onTouch监听的时候，onTouch返回了true，那么它也返回true，这个事件提前被onTouch消费掉了。就不再执行onTouchEvent了，更别说onClick监听了。3、我们通常在onTouch监听了设置图片一旦被触摸就改变它的背景、透明度之类的，这个onTouch表示事件的时机。而在onClick监听了去具体干某些事。 下面通过代码来说明,自定义一个TestButton继承自Button，重写它的dispath和onTouchEvent方法，为了简单只关注down和up事件。package org.yanzi.ui;import android.content.Context;import android.util.AttributeSet;import android.util.Log;import android.view.MotionEvent;import android.widget.Button;public class TestButton extends Button { private final static String tag = &quot;yan&quot;; public TestButton(Context context, AttributeSet attrs) { super(context, attrs); // TODO Auto-generated constructor stub } @Override public boolean onTouchEvent(MotionEvent event) { // TODO Auto-generated method stub switch(event.getAction()){ case MotionEvent.ACTION_DOWN: Log.i(tag, &quot;TestButton-onTouchEvent-ACTION_DOWN…&quot;); break; case MotionEvent.ACTION_UP: Log.i(tag, &quot;TestButton-onTouchEvent-ACTION_UP…&quot;); break; default:break; } return super.onTouchEvent(event); } @Override public boolean dispatchTouchEvent(MotionEvent event) { // TODO Auto-generated method stub switch(event.getAction()){ case MotionEvent.ACTION_DOWN: Log.i(tag, &quot;TestButton-dispatchTouchEvent-ACTION_DOWN…&quot;); break; case MotionEvent.ACTION_UP: Log.i(tag, &quot;TestButton-dispatchTouchEvent-ACTION_UP…&quot;); break; default:break; } return super.dispatchTouchEvent(event); }}在Activity里注册两个监听: testBtn.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View v) { // TODO Auto-generated method stub Log.i(tag, &quot;testBtn—onClick…&quot;); } }); testBtn.setOnTouchListener(new View.OnTouchListener() { @Override public boolean onTouch(View v, MotionEvent event) { // TODO Auto-generated method stub switch(event.getAction()){ case MotionEvent.ACTION_DOWN: Log.i(tag, &quot;testBtn-onTouch-ACTION_DOWN…&quot;); break; case MotionEvent.ACTION_UP: Log.i(tag, &quot;testBtn-onTouch-ACTION_UP…&quot;); break; default:break; } return false; } });同时复写Activity的dispatch方法和onTouchEvent方法：@Override public boolean dispatchTouchEvent(MotionEvent ev) { // TODO Auto-generated method stub switch(ev.getAction()){ case MotionEvent.ACTION_DOWN: Log.i(tag, &quot;MainActivity-dispatchTouchEvent-ACTION_DOWN…&quot;); break; case MotionEvent.ACTION_UP: Log.i(tag, &quot;MainActivity-dispatchTouchEvent-ACTION_UP…&quot;); break; default:break; } return super.dispatchTouchEvent(ev); } @Override public boolean onTouchEvent(MotionEvent event) { // TODO Auto-generated method stub switch(event.getAction()){ case MotionEvent.ACTION_DOWN: Log.i(tag, &quot;MainActivity-onTouchEvent-ACTION_DOWN…&quot;); break; case MotionEvent.ACTION_UP: Log.i(tag, &quot;MainActivity-onTouchEvent-ACTION_UP…&quot;); break; default:break; } return super.onTouchEvent(event); }最终一次点击，打印信息如下: Line 33: 01-08 14:59:45.847 I/yan &nbsp; &nbsp; ( 4613): MainActivity-dispatchTouchEvent-ACTION_DOWN… Line 35: 01-08 14:59:45.849 I/yan &nbsp; &nbsp; ( 4613): TestButton-dispatchTouchEvent-ACTION_DOWN… Line 37: 01-08 14:59:45.849 I/yan &nbsp; &nbsp; ( 4613): testBtn-onTouch-ACTION_DOWN… Line 39: 01-08 14:59:45.849 I/yan &nbsp; &nbsp; ( 4613): TestButton-onTouchEvent-ACTION_DOWN… Line 41: 01-08 14:59:45.939 I/yan &nbsp; &nbsp; ( 4613): MainActivity-dispatchTouchEvent-ACTION_UP… Line 43: 01-08 14:59:45.941 I/yan &nbsp; &nbsp; ( 4613): TestButton-dispatchTouchEvent-ACTION_UP… Line 45: 01-08 14:59:45.944 I/yan &nbsp; &nbsp; ( 4613): testBtn-onTouch-ACTION_UP… Line 47: 01-08 14:59:45.946 I/yan &nbsp; &nbsp; ( 4613): TestButton-onTouchEvent-ACTION_UP… Line 49: 01-08 14:59:45.974 I/yan &nbsp; &nbsp; ( 4613): testBtn—onClick… 事件先由Activity的dispatchTouchEvent进行分发，然后TestButton的dispatchTouchEvent进行分发，接着执行onTouch监听，然后执行onTouchEvent。第二次UP动作的时候，在onTouchEvent里又执行了onClick监听。 如果我们想这个TestButton只能执行onTouch监听不能执行onClick监听，方法有很多。在onTouch监听里默认返回false改为true，如下:testBtn.setOnTouchListener(new View.OnTouchListener() { @Override public boolean onTouch(View v, MotionEvent event) { // TODO Auto-generated method stub switch(event.getAction()){ case MotionEvent.ACTION_DOWN: Log.i(tag, &quot;testBtn-onTouch-ACTION_DOWN…&quot;); break; case MotionEvent.ACTION_UP: Log.i(tag, &quot;testBtn-onTouch-ACTION_UP…&quot;); break; default:break; } return true; } });事件流程为: Line 75: 01-08 15:05:51.627 I/yan &nbsp; &nbsp; ( 5262): MainActivity-dispatchTouchEvent-ACTION_DOWN… Line 77: 01-08 15:05:51.628 I/yan &nbsp; &nbsp; ( 5262): TestButton-dispatchTouchEvent-ACTION_DOWN… Line 79: 01-08 15:05:51.629 I/yan &nbsp; &nbsp; ( 5262): testBtn-onTouch-ACTION_DOWN… Line 81: 01-08 15:05:51.689 I/yan &nbsp; &nbsp; ( 5262): MainActivity-dispatchTouchEvent-ACTION_UP… Line 83: 01-08 15:05:51.691 I/yan &nbsp; &nbsp; ( 5262): TestButton-dispatchTouchEvent-ACTION_UP… Line 85: 01-08 15:05:51.695 I/yan &nbsp; &nbsp; ( 5262): testBtn-onTouch-ACTION_UP… 可以看到压根就没执行onTouchEvent。因为onTouch返回了true，已提前将这个事件消费了，就不往下传了，dispatch流程提前终止。二、ViewGroup的dispatchTouchEvent、onInterceptTouchEvent、onTouchEvent 再来看ViewGroup，在复写ViewGroup时可以发现它的onTouchEvent在在View里的，表示这两个方法是一样的。但dispatchTouchEvent是在ViewGroup里的，表示和View的dispatchTouchEvent不一样，多了一个onInterceptTouchEvent函数，表示拦截的意思。链接&nbsp;打个很形象的比喻，这玩意就像个秘书、谋士。为啥View没有呢，因为它级别不够，一个Button里面是不可能有子View的。但LinearLayout(继承ViewGroup)就有孩子(子布局)，这个onInterceptTouchEvent就会判断事件要不要通知它的孩子呢。它的源码如下： public boolean dispatchTouchEvent(MotionEvent ev) { if (mInputEventConsistencyVerifier != null) { mInputEventConsistencyVerifier.onTouchEvent(ev, 1); } boolean handled = false; if (onFilterTouchEventForSecurity(ev)) { final int action = ev.getAction(); final int actionMasked = action &amp; MotionEvent.ACTION_MASK; // Handle an initial down. if (actionMasked == MotionEvent.ACTION_DOWN) { // Throw away all previous state when starting a new touch gesture. // The framework may have dropped the up or cancel event for the previous gesture // due to an app switch, ANR, or some other state change. cancelAndClearTouchTargets(ev); resetTouchState(); } // Check for interception. final boolean intercepted; if (actionMasked == MotionEvent.ACTION_DOWN || mFirstTouchTarget != null) { final boolean disallowIntercept = (mGroupFlags &amp; FLAG_DISALLOW_INTERCEPT) != 0; if (!disallowIntercept) { intercepted = onInterceptTouchEvent(ev); ev.setAction(action); // restore action in case it was changed } else { intercepted = false; } } else { // There are no touch targets and this action is not an initial down // so this view group continues to intercept touches. intercepted = true; } // Check for cancelation. final boolean canceled = resetCancelNextUpFlag(this) || actionMasked == MotionEvent.ACTION_CANCEL; // Update list of touch targets for pointer down, if needed. final boolean split = (mGroupFlags &amp; FLAG_SPLIT_MOTION_EVENTS) != 0; TouchTarget newTouchTarget = null; boolean alreadyDispatchedToNewTouchTarget = false; if (!canceled &amp;&amp; !intercepted) { if (actionMasked == MotionEvent.ACTION_DOWN || (split &amp;&amp; actionMasked == MotionEvent.ACTION_POINTER_DOWN) || actionMasked == MotionEvent.ACTION_HOVER_MOVE) { final int actionIndex = ev.getActionIndex(); // always 0 for down final int idBitsToAssign = split ? 1 &lt;&lt; ev.getPointerId(actionIndex) : TouchTarget.ALL_POINTER_IDS; // Clean up earlier touch targets for this pointer id in case they // have become out of sync. removePointersFromTouchTargets(idBitsToAssign); final int childrenCount = mChildrenCount; if (childrenCount != 0) { // Find a child that can receive the event. // Scan children from front to back. final View[] children = mChildren; final float x = ev.getX(actionIndex); final float y = ev.getY(actionIndex); final boolean customOrder = isChildrenDrawingOrderEnabled(); for (int i = childrenCount - 1; i &gt;= 0; i–) { final int childIndex = customOrder ? getChildDrawingOrder(childrenCount, i) : i; final View child = children[childIndex]; if (!canViewReceivePointerEvents(child) || !isTransformedTouchPointInView(x, y, child, null)) { continue; } newTouchTarget = getTouchTarget(child); if (newTouchTarget != null) { // Child is already receiving touch within its bounds. // Give it the new pointer in addition to the ones it is handling. newTouchTarget.pointerIdBits |= idBitsToAssign; break; } resetCancelNextUpFlag(child); if (dispatchTransformedTouchEvent(ev, false, child, idBitsToAssign)) { // Child wants to receive touch within its bounds. mLastTouchDownTime = ev.getDownTime(); mLastTouchDownIndex = childIndex; mLastTouchDownX = ev.getX(); mLastTouchDownY = ev.getY(); newTouchTarget = addTouchTarget(child, idBitsToAssign); alreadyDispatchedToNewTouchTarget = true; break; } } } if (newTouchTarget == null &amp;&amp; mFirstTouchTarget != null) { // Did not find a child to receive the event. // Assign the pointer to the least recently added target. newTouchTarget = mFirstTouchTarget; while (newTouchTarget.next != null) { newTouchTarget = newTouchTarget.next; } newTouchTarget.pointerIdBits |= idBitsToAssign; } } } // Dispatch to touch targets. if (mFirstTouchTarget == null) { // No touch targets so treat this as an ordinary view. handled = dispatchTransformedTouchEvent(ev, canceled, null, TouchTarget.ALL_POINTER_IDS); } else { // Dispatch to touch targets, excluding the new touch target if we already // dispatched to it. Cancel touch targets if necessary. TouchTarget predecessor = null; TouchTarget target = mFirstTouchTarget; while (target != null) { final TouchTarget next = target.next; if (alreadyDispatchedToNewTouchTarget &amp;&amp; target == newTouchTarget) { handled = true; } else { final boolean cancelChild = resetCancelNextUpFlag(target.child) || intercepted; if (dispatchTransformedTouchEvent(ev, cancelChild, target.child, target.pointerIdBits)) { handled = true; } if (cancelChild) { if (predecessor == null) { mFirstTouchTarget = next; } else { predecessor.next = next; } target.recycle(); target = next; continue; } } predecessor = target; target = next; } } // Update list of touch targets for pointer up or cancel, if needed. if (canceled || actionMasked == MotionEvent.ACTION_UP || actionMasked == MotionEvent.ACTION_HOVER_MOVE) { resetTouchState(); } else if (split &amp;&amp; actionMasked == MotionEvent.ACTION_POINTER_UP) { final int actionIndex = ev.getActionIndex(); final int idBitsToRemove = 1 &lt;&lt; ev.getPointerId(actionIndex); removePointersFromTouchTargets(idBitsToRemove); } } if (!handled &amp;&amp; mInputEventConsistencyVerifier != null) { mInputEventConsistencyVerifier.onUnhandledEvent(ev, 1); } return handled; }可以看到标红的有两句(intercepted = onInterceptTouchEvent(ev); &nbsp;&nbsp;&nbsp;if (!canceled &amp;&amp; !intercepted)&nbsp;&nbsp;)，它会先调用&nbsp;intercepted = onInterceptTouchEvent(ev);然后通过if判断。 public boolean onInterceptTouchEvent(MotionEvent ev) { return false; }它就一句话，默认false。也就是说这个谋士默认的意见是，永远不拦截！！！！只要有孩子，就交给孩子们处理吧。下面给出实例说明，新建TestLinearLayout继承自Linearlayout。package org.yanzi.ui;import android.content.Context;import android.util.AttributeSet;import android.util.Log;import android.view.MotionEvent;import android.widget.LinearLayout;public class TestLinearLayout extends LinearLayout{ private final static String tag = &quot;yan&quot;; public TestLinearLayout(Context context, AttributeSet attrs) { super(context, attrs); // TODO Auto-generated constructor stub } @Override public boolean dispatchTouchEvent(MotionEvent ev) { // TODO Auto-generated method stub switch(ev.getAction()){ case MotionEvent.ACTION_DOWN: Log.i(tag, &quot;TestLinearLayout-dispatchTouchEvent-ACTION_DOWN…&quot;); break; case MotionEvent.ACTION_UP: Log.i(tag, &quot;TestLinearLayout-dispatchTouchEvent-ACTION_UP…&quot;); break; default:break; } return super.dispatchTouchEvent(ev); } @Override public boolean onInterceptTouchEvent(MotionEvent ev) { // TODO Auto-generated method stub switch(ev.getAction()){ case MotionEvent.ACTION_DOWN: Log.i(tag, &quot;TestLinearLayout-onInterceptTouchEvent-ACTION_DOWN…&quot;); break; case MotionEvent.ACTION_UP: Log.i(tag, &quot;TestLinearLayout-onInterceptTouchEvent-ACTION_UP…&quot;); break; default:break; } return super.onInterceptTouchEvent(ev); } @Override public boolean onTouchEvent(MotionEvent event) { // TODO Auto-generated method stub switch(event.getAction()){ case MotionEvent.ACTION_DOWN: Log.i(tag, &quot;TestLinearLayout-onTouchEvent-ACTION_DOWN…&quot;); break; case MotionEvent.ACTION_UP: Log.i(tag, &quot;TestLinearLayout-onTouchEvent-ACTION_UP…&quot;); break; default:break; } return super.onTouchEvent(event); }}布局文件改成:&lt;RelativeLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&amp;quot; xmlns:tools=&quot;http://schemas.android.com/tools&amp;quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:paddingBottom=&quot;@dimen/activity_vertical_margin&quot; android:paddingLeft=&quot;@dimen/activity_horizontal_margin&quot; android:paddingRight=&quot;@dimen/activity_horizontal_margin&quot; android:paddingTop=&quot;@dimen/activity_vertical_margin&quot; tools:context=&quot;.MainActivity&quot; &gt; &lt;TextView android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;@string/hello_world&quot; /&gt; &lt;org.yanzi.ui.TestLinearLayout android:id=&quot;@+id/linearlayout_test&quot; android:layout_width=&quot;200dip&quot; android:layout_height=&quot;200dip&quot; &gt; &lt;org.yanzi.ui.TestButton android:id=&quot;@+id/btn_test&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;测试按钮&quot; /&gt; &lt;/org.yanzi.ui.TestLinearLayout&gt;&lt;/RelativeLayout&gt;在Activity里给这个自定义LinearLayout也注册上onClick监听、onTouch监听。testLinelayout = (TestLinearLayout)findViewById(R.id.linearlayout_test); testLinelayout.setOnTouchListener(new View.OnTouchListener() { @Override public boolean onTouch(View v, MotionEvent event) { // TODO Auto-generated method stub switch(event.getAction()){ case MotionEvent.ACTION_DOWN: Log.i(tag, &quot;testLinelayout-onTouch-ACTION_DOWN…&quot;); break; case MotionEvent.ACTION_UP: Log.i(tag, &quot;testLinelayout-onTouch-ACTION_UP…&quot;); break; default:break; } return false; } }); testLinelayout.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View v) { // TODO Auto-generated method stub Log.i(tag, &quot;testLinelayout—onClick…&quot;); } });不复写事件传递里的 任何方法，流程如下: Line 57: 01-08 15:29:42.167 I/yan &nbsp; &nbsp; ( 5826): MainActivity-dispatchTouchEvent-ACTION_DOWN… Line 59: 01-08 15:29:42.169 I/yan &nbsp; &nbsp; ( 5826): TestLinearLayout-dispatchTouchEvent-ACTION_DOWN… Line 61: 01-08 15:29:42.169 I/yan &nbsp; &nbsp; ( 5826): TestLinearLayout-onInterceptTouchEvent-ACTION_DOWN… Line 63: 01-08 15:29:42.169 I/yan &nbsp; &nbsp; ( 5826): TestButton-dispatchTouchEvent-ACTION_DOWN… Line 65: 01-08 15:29:42.170 I/yan &nbsp; &nbsp; ( 5826): testBtn-onTouch-ACTION_DOWN… Line 67: 01-08 15:29:42.170 I/yan &nbsp; &nbsp; ( 5826): TestButton-onTouchEvent-ACTION_DOWN…————————————————————————————————————————— Line 69: 01-08 15:29:42.279 I/yan &nbsp; &nbsp; ( 5826): MainActivity-dispatchTouchEvent-ACTION_UP… Line 71: 01-08 15:29:42.280 I/yan &nbsp; &nbsp; ( 5826): TestLinearLayout-dispatchTouchEvent-ACTION_UP… Line 73: 01-08 15:29:42.283 I/yan &nbsp; &nbsp; ( 5826): TestLinearLayout-onInterceptTouchEvent-ACTION_UP… Line 75: 01-08 15:29:42.287 I/yan &nbsp; &nbsp; ( 5826): TestButton-dispatchTouchEvent-ACTION_UP… Line 81: 01-08 15:29:42.298 I/yan &nbsp; &nbsp; ( 5826): testBtn-onTouch-ACTION_UP… Line 83: 01-08 15:29:42.301 I/yan &nbsp; &nbsp; ( 5826): TestButton-onTouchEvent-ACTION_UP… Line 85: 01-08 15:29:42.313 I/yan &nbsp; &nbsp; ( 5826): testBtn—onClick…由Activity的dispatchTouchEvent—-Linearlayout的dispatchTouchEvent————问问它的谋士要不要让孩子知道onInterceptTouchEvent———孩子的dispatchTouchEvent—–孩子的onTouch监听——孩子的onTouchEvent—-孩子的onClick监听。为了更清晰这个流程，下面作如下改动：1、如果事件传给了孩子们，但孩子没有onTouch和onClick监听怎么办？即将button的onclick和onTouch都注释掉:流程如下: Line 131: 01-08 15:36:16.574 I/yan &nbsp; &nbsp; ( 6124): TestLinearLayout-dispatchTouchEvent-ACTION_DOWN… Line 133: 01-08 15:36:16.574 I/yan &nbsp; &nbsp; ( 6124): TestLinearLayout-onInterceptTouchEvent-ACTION_DOWN… Line 135: 01-08 15:36:16.574 I/yan &nbsp; &nbsp; ( 6124): TestButton-dispatchTouchEvent-ACTION_DOWN… Line 137: 01-08 15:36:16.575 I/yan &nbsp; &nbsp; ( 6124): TestButton-onTouchEvent-ACTION_DOWN… Line 143: 01-08 15:36:16.746 I/yan &nbsp; &nbsp; ( 6124): MainActivity-dispatchTouchEvent-ACTION_UP… Line 145: 01-08 15:36:16.747 I/yan &nbsp; &nbsp; ( 6124): TestLinearLayout-dispatchTouchEvent-ACTION_UP… Line 147: 01-08 15:36:16.747 I/yan &nbsp; &nbsp; ( 6124): TestLinearLayout-onInterceptTouchEvent-ACTION_UP… Line 149: 01-08 15:36:16.748 I/yan &nbsp; &nbsp; ( 6124): TestButton-dispatchTouchEvent-ACTION_UP… Line 151: 01-08 15:36:16.748 I/yan &nbsp; &nbsp; ( 6124): TestButton-onTouchEvent-ACTION_UP…因为事件给了孩子们，它没监听也关系不到父亲了，父亲的onClick和onTouch都没执行。2,如果将TestLinearlayout的onInterceptTouchEvent 改成return true，即不让孩子们知道。 Line 57: 01-08 15:40:06.832 I/yan &nbsp; &nbsp; ( 6640): MainActivity-dispatchTouchEvent-ACTION_DOWN… Line 59: 01-08 15:40:06.835 I/yan &nbsp; &nbsp; ( 6640): TestLinearLayout-dispatchTouchEvent-ACTION_DOWN… Line 61: 01-08 15:40:06.836 I/yan &nbsp; &nbsp; ( 6640): TestLinearLayout-onInterceptTouchEvent-ACTION_DOWN… Line 63: 01-08 15:40:06.836 I/yan &nbsp; &nbsp; ( 6640): testLinelayout-onTouch-ACTION_DOWN… Line 65: 01-08 15:40:06.836 I/yan &nbsp; &nbsp; ( 6640): TestLinearLayout-onTouchEvent-ACTION_DOWN… Line 67: 01-08 15:40:07.016 I/yan &nbsp; &nbsp; ( 6640): MainActivity-dispatchTouchEvent-ACTION_UP… Line 69: 01-08 15:40:07.017 I/yan &nbsp; &nbsp; ( 6640): TestLinearLayout-dispatchTouchEvent-ACTION_UP… Line 73: 01-08 15:40:07.025 I/yan &nbsp; &nbsp; ( 6640): testLinelayout-onTouch-ACTION_UP… Line 75: 01-08 15:40:07.026 I/yan &nbsp; &nbsp; ( 6640): TestLinearLayout-onTouchEvent-ACTION_UP… Line 77: 01-08 15:40:07.052 I/yan &nbsp; &nbsp; ( 6640): testLinelayout—onClick… 果然事件就此打住，孩子们压根不知道，父亲执行了onClick和onTouch监听。可见父亲还是伟大的啊，只要谋士不拦截事件，那么事件就给孩子。 最后的结论:1、如果是自定义复合控件，如图片+文字，我再Activity里给你注册了onClick监听，期望点击它执行。那么最简单的方法就是将图片+文字的父布局，也即让其容器ViewGroup的秘书将事件拦下，这样父亲就可以执行onClick了。这时候的父亲就像一个独立的孩子一样了(View)，无官一身轻，再也不用管它的孩子了,可以正常onClick onTouch.2、如果希望一个View只onTouch而不onClick，在onTouch里return true就ok了。3、dispatch是为了onTouch监听，onTouchEvent是为了onClick监听。4、自定义布局时，一般情况下：@Override public boolean onTouchEvent(MotionEvent event) {return super.onTouchEvent(event);} &nbsp;@Override public boolean dispatchTouchEvent(MotionEvent event) {return super.dispatchTouchEvent(event); 我们可以复写，但是最后的super.是万万不能少滴。如果少了，表示连dispatch onTouchEvent压根就不调用了，事件就此打住。 貌似真相水落石出了，但究竟清楚了没有请看下篇根据自定义复合控件的监听问题再探讨下。参考: &nbsp;&nbsp;链接1&nbsp;(灰常感谢前辈的大作啊) &nbsp; &nbsp;链接2测试代码: &nbsp;http://download.csdn.net/detail/yanzi1225627/7121063—————————本文系原创，转载注明作者:yanzi1225627]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[View注意点]]></title>
      <url>http://fengqingxiuyi.xyz/ShowJoy/View/View%E6%B3%A8%E6%84%8F%E7%82%B9.html</url>
      <content type="html"><![CDATA[注：本文所属ShowJoy-View，本文主要介绍Fresco图片框架注意点／自定义的ShopEditText使用以及tools使用详解等，本文持续更新… Fresco图片框架注意点Fresco官方文档：http://fresco-cn.org/docs/getting-started.html 注意点1：凡是使用Fresco设置的图片，必须设置具体的宽高才可以正常显示例如：SHImageView 模块地址：同级目录下的SHImageView.java文件或http://git.showjoy.net/android/showjoyandroid_image/tree/master 注意点2：为Fresco图片设置圆形背景12345678910// 去除fresco:roundedCornerRadius="5dp"可预览&lt;com.showjoy.image.SHCircleImageView android:id="@+id/home_best_seller_img" android:layout_width="match_parent" android:layout_height="match_parent" fresco:actualImageScaleType="centerCrop" fresco:backgroundImage="@color/white" fresco:roundedCornerRadius="5dp" fresco:roundingBorderColor="@color/grey2" fresco:roundingBorderWidth="2dp" /&gt; 答：因为已经设置了round属性，所以已经是圆形了，这个时候，如果想要设置其圆形边框内的背景，需要通过这个属性backgroundImage设置背景才是圆形边框内的背景色 ShopEditTextShopEditText必须设置字体大小（注：已提供属性），否则字体显示特别小模块地址：同级目录下ShopEditText文件夹下的ShopEditText.java文件 tools-Designtime AttributesGoogle文档地址：http://tools.android.com/tips/layout-designtime-attributes 中文翻译：这些属性用于渲染布局，而不会影响到程序运行。也就是说只在预览布局时出现，在程序运行时相当于该属性不存在。 例子： 123456789101112&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android" xmlns:tools="http://schemas.android.com/tools" android:layout_width="match_parent" android:layout_height="match_parent"&gt; &lt;TextView android:layout_width="match_parent" android:layout_height="wrap_content" tools:text="test"/&gt;&lt;/RelativeLayout&gt; 更加全面的tools详解：http://blog.csdn.net/zhengdan66/article/details/46960985 android:paddingstart(paddingend)android:paddingstart(paddingend)：左右对齐时使用。左对齐时：paddingstart对应paddingleft；paddingend对应paddingright；右对齐时则刚好相反；]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[SHImageView]]></title>
      <url>http://fengqingxiuyi.xyz/ShowJoy/View/SHImageView.html</url>
      <content type="html"><![CDATA[注：本文所属ShowJoy-View，本文介绍 统一图片组件 的制作与使用，本图片组件封装于Fresco组件，本文用于介绍 统一图片组件 的制作与使用，可查看Fresco官方文档：http://fresco-cn.org/docs/getting-started.html 统一图片组件 的制作123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109package com.showjoy.image;import android.content.Context;import android.graphics.drawable.Drawable;import android.text.TextUtils;import android.util.AttributeSet;import com.showjoy.image.base.ISHImageLoadListener;import com.showjoy.image.fresco.FrescoImageView;/** * 尚妆统一图片组件 * Created by lufei on 3/30/16. */public class SHImageView extends FrescoImageView &#123; String imageUrl; int width; int height; ISHImageLoadListener loadListener; public SHImageView(Context context) &#123; super(context); init(); &#125; public SHImageView(Context context, AttributeSet attrs) &#123; super(context, attrs); init(); &#125; public SHImageView(Context context, AttributeSet attrs, int defStyle) &#123; super(context, attrs, defStyle); init(); &#125; public SHImageView(Context context, AttributeSet attrs, int defStyleAttr, int defStyleRes) &#123; super(context, attrs, defStyleAttr, defStyleRes); init(); &#125; @Override public void setImageUrl(String url) &#123; if (TextUtils.equals(imageUrl, url)) &#123; return; &#125; imageUrl = url; super.setImageUrl(url); &#125; @Override public void setFailureImage() &#123; super.setFailureImage(); &#125; @Override public void placeholderImage(int resource) &#123; super.placeholderImage(resource); &#125; @Override public void placeholderImage(Drawable drawable) &#123; super.placeholderImage(drawable); &#125; @Override public void setImageRes(int resId) &#123; super.setImageRes(resId); &#125; @Override public void setImageUrl(String url, ISHImageLoadListener loadListener) &#123; if (TextUtils.equals(imageUrl, url) &amp;&amp; this.loadListener == loadListener) &#123; return; &#125; imageUrl = url; this.loadListener = loadListener; super.setImageUrl(url, loadListener); &#125; @Override public void setImageUrl(String url, int width, int height) &#123; if (TextUtils.equals(imageUrl, url) &amp;&amp; this.width == width &amp;&amp; this.height == height) &#123; return; &#125; imageUrl = url; this.width = width; this.height = height; super.setImageUrl(url, width, height); &#125; @Override public void setImageUrl(String url, int width, int height, ISHImageLoadListener loadListener) &#123; if (TextUtils.equals(imageUrl, url) &amp;&amp; this.width == width &amp;&amp; this.height == height &amp;&amp; this.loadListener == loadListener) &#123; return; &#125; imageUrl = url; this.loadListener = loadListener; this.width = width; this.height = height; super.setImageUrl(url, width, height, loadListener); &#125; @Override public void setImageRes(int resId, ISHImageLoadListener loadListener) &#123; super.setImageRes(resId, loadListener); &#125;&#125; 统一图片组件 的使用1234&lt;com.showjoy.image.SHImageView android:id="@+id/image" android:layout_width="30dp" android:layout_height="30dp" /&gt; 注意：此 统一图片组件 的宽和高不能同时为wrap_content，具体参考Fresco文档。]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[ShopEditText]]></title>
      <url>http://fengqingxiuyi.xyz/ShowJoy/View/ShopEditText.html</url>
      <content type="html"><![CDATA[注：本文所属ShowJoy-View，本文介绍 统一文本编辑框 的制作与使用，统一文本编辑框继承于RelativeLayout，同时也支持大范围区域的点击效果！ 统一文本编辑框 的制作Java文件内容123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143package com.showjoy.shop.common.view;import android.content.Context;import android.content.res.TypedArray;import android.text.InputType;import android.text.TextUtils;import android.util.AttributeSet;import android.util.TypedValue;import android.view.Gravity;import android.view.View;import android.widget.EditText;import android.widget.LinearLayout;import android.widget.RelativeLayout;import android.widget.TextView;import com.showjoy.shop.R;import com.showjoy.view.SHIconFontTextView;/** * 达人店专用的统一编辑框 * Created by lufei on 7/20/16. */public class ShopEditText extends RelativeLayout &#123; private RelativeLayout viewShopEditRoot; private SHIconFontTextView viewShopEditLeftIcon; private SHIconFontTextView viewShopEditRightIcon; private EditText viewShopEditInput; private LinearLayout inviteErrorTip; private SHIconFontTextView inviteErrorIcon; private TextView inviteErrorTextView; public ShopEditText(Context context) &#123; super(context); init(context, null); &#125; public ShopEditText(Context context, AttributeSet attrs) &#123; super(context, attrs); init(context, attrs); &#125; public ShopEditText(Context context, AttributeSet attrs, int defStyleAttr) &#123; super(context, attrs, defStyleAttr); init(context, attrs); &#125; private void init(Context context, AttributeSet attrs) &#123; inflate(context, R.layout.view_shop_edit, this); viewShopEditRoot = (RelativeLayout) findViewById(R.id.view_shop_edit_root); viewShopEditLeftIcon = (SHIconFontTextView) findViewById(R.id.view_shop_edit_left_icon); viewShopEditRightIcon = (SHIconFontTextView) findViewById(R.id.view_shop_edit_right_icon); viewShopEditInput = (EditText) findViewById(R.id.view_shop_edit_input); inviteErrorTip = (LinearLayout) findViewById(R.id.invite_error_tip); inviteErrorIcon = (SHIconFontTextView) findViewById(R.id.invite_error_icon); inviteErrorTextView = (TextView) findViewById(R.id.invite_error_text_view); if (null != attrs) &#123; TypedArray typeArray = context.obtainStyledAttributes(attrs, R.styleable.ShopEditText); String emptyText = typeArray.getString(R.styleable.ShopEditText_shop_edit_empty_text); if (!TextUtils.isEmpty(emptyText)) &#123; inviteErrorTextView.setText(emptyText); &#125; String hint = typeArray.getString(R.styleable.ShopEditText_shop_edit_hint); if (!TextUtils.isEmpty(hint)) &#123; viewShopEditInput.setHint(hint); &#125; String leftIcon = typeArray.getString(R.styleable.ShopEditText_shop_edit_left_icon); if (!TextUtils.isEmpty(leftIcon)) &#123; viewShopEditLeftIcon.setText(leftIcon); &#125; String rightIcon = typeArray.getString(R.styleable.ShopEditText_shop_edit_right_icon); if (!TextUtils.isEmpty(rightIcon)) &#123; viewShopEditRightIcon.setText(rightIcon); &#125; int gravity = typeArray.getInt(R.styleable.ShopEditText_shop_edit_gravity, 0); if (gravity == 0) &#123; viewShopEditInput.setGravity(Gravity.LEFT); inviteErrorTip.setGravity(Gravity.LEFT); &#125;else if (gravity == 1) &#123; viewShopEditInput.setGravity(Gravity.CENTER); inviteErrorTip.setGravity(Gravity.CENTER); &#125;else if (gravity == 2) &#123; viewShopEditInput.setGravity(Gravity.RIGHT); inviteErrorTip.setGravity(Gravity.RIGHT); &#125; float size = typeArray.getDimension(R.styleable.ShopEditText_shop_edit_text_size, 14f); viewShopEditInput.setTextSize(TypedValue.COMPLEX_UNIT_PX, size); typeArray.recycle(); &#125; inviteErrorTip.setOnClickListener(v -&gt; &#123; setErrorVisible(false); &#125;); &#125; public void setInputType(int inputType) &#123; viewShopEditInput.setInputType(inputType); &#125; public String getText() &#123; return viewShopEditInput.getText().toString(); &#125; public void setErrorText(String text) &#123; inviteErrorTextView.setText(text); &#125; public void setErrorVisible(boolean visible) &#123; if (visible) &#123; inviteErrorTip.setVisibility(VISIBLE); viewShopEditInput.setVisibility(GONE); &#125;else &#123; inviteErrorTip.setVisibility(GONE); viewShopEditInput.setVisibility(VISIBLE); &#125; &#125; public void setReadOnly(boolean readOnly) &#123; if (readOnly) &#123; viewShopEditInput.setInputType(InputType.TYPE_NULL); &#125;else &#123; viewShopEditInput.setInputType(InputType.TYPE_CLASS_TEXT); &#125; &#125; public void setText(String text) &#123; viewShopEditInput.setText(text); &#125; public View getRightIcon() &#123; return viewShopEditRightIcon; &#125; @Override public void setOnClickListener(OnClickListener l) &#123; super.setOnClickListener(l); viewShopEditInput.setOnClickListener(l); &#125;&#125; 属性文件内容PS: 以下内容位于styles.xml文件中 123456789101112&lt;declare-styleable name="ShopEditText"&gt; &lt;attr name="shop_edit_hint" format="string" /&gt; &lt;attr name="shop_edit_empty_text" format="string" /&gt; &lt;attr name="shop_edit_left_icon" format="string" /&gt; &lt;attr name="shop_edit_right_icon" format="string" /&gt; &lt;attr name="shop_edit_text_size" format="dimension" /&gt; &lt;attr name="shop_edit_gravity" format="integer"&gt; &lt;flag name="left" value="0" /&gt; &lt;flag name="center" value="1" /&gt; &lt;flag name="right" value="2" /&gt; &lt;/attr&gt;&lt;/declare-styleable&gt; 布局文件内容123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android" android:id="@+id/view_shop_edit_root" android:layout_width="match_parent" android:layout_height="wrap_content" android:orientation="vertical"&gt; &lt;LinearLayout android:id="@+id/view_shop_edit" android:layout_width="match_parent" android:layout_height="wrap_content" android:orientation="horizontal" android:gravity="center"&gt; &lt;com.showjoy.view.SHIconFontTextView android:id="@+id/view_shop_edit_left_icon" android:layout_width="wrap_content" android:layout_height="wrap_content" android:layout_marginRight="5.5dp" android:textColor="@color/grey4" android:textSize="18sp" /&gt; &lt;EditText android:id="@+id/view_shop_edit_input" android:layout_width="0dp" android:layout_height="wrap_content" android:layout_weight="1" android:background="@null" android:hint="请填写邀请码" android:textSize="18sp" /&gt; &lt;com.showjoy.view.SHIconFontTextView android:id="@+id/view_shop_edit_right_icon" android:layout_width="wrap_content" android:layout_height="wrap_content" android:textColor="@color/grey4" android:textSize="18sp" /&gt; &lt;/LinearLayout&gt; &lt;View android:id="@+id/view_shop_edit_line" android:layout_width="match_parent" android:layout_height="1px" android:layout_marginTop="10dp" android:layout_below="@id/view_shop_edit" android:background="@color/grey4"/&gt; &lt;LinearLayout android:id="@+id/invite_error_tip" android:layout_width="match_parent" android:layout_height="wrap_content" android:orientation="horizontal" android:layout_marginTop="10dp" android:layout_below="@+id/view_shop_edit_line" android:visibility="gone"&gt; &lt;com.showjoy.view.SHIconFontTextView android:id="@+id/invite_error_icon" android:layout_width="wrap_content" android:layout_height="wrap_content" android:textSize="18sp"/&gt; &lt;TextView android:id="@+id/invite_error_text_view" android:layout_width="wrap_content" android:layout_height="wrap_content" android:gravity="center" android:textColor="@color/redPink" android:textSize="18sp" /&gt; &lt;/LinearLayout&gt;&lt;/RelativeLayout&gt; 统一文本编辑框 的使用123456789&lt;com.showjoy.shop.common.view.ShopEditText android:id="@+id/login_user_name" android:layout_width="250dp" android:layout_height="wrap_content" android:layout_below="@+id/login_logo" android:layout_centerHorizontal="true" android:layout_marginTop="35dp" app:shop_edit_hint="输入用户名" app:shop_edit_text_size="16sp" /&gt;]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Android-Relativelayout属性总结]]></title>
      <url>http://fengqingxiuyi.xyz/ShowJoy/View/Android-Relativelayout%E5%B1%9E%E6%80%A7%E6%80%BB%E7%BB%93.html</url>
      <content type="html"><![CDATA[注：本文所属ShowJoy-View，本文转载自：http://blog.csdn.net/kimifdw/article/details/11981509 指定偏移量1.android:paddingleft(paddingright/paddingtop/paddingbottom)：控件内部内容（如文本距离该控件的边距）；2.android:paddingstart(paddingend)：左右对齐时使用。左对齐时：paddingstart对应paddingleft；paddingend对应paddingright；右对齐时则刚好相反；3.android:layout_margin：该控件距离父控件的边距；（layout_marginleft/layout_marginright/layout_margintop/layout_marginbottom）； 给定控件ID4.android:layout_above ：将该控件的底部至于给定ID的控件之上；5.android:layout_below ：将该控件的顶部至于给定ID的控件之下；6.android:layout_toLeftOf ：将该控件的右边缘和给定ID的控件的左边缘对齐； android:layout_toRightOf：将该控件的左边缘和给定ID的控件的右边缘对齐；8.android:layout_alignBaseline： 该控件的baseline和给定ID的控件的baseline对齐；（baseline为控件的基准线）；9.android:layout_alignBottom：将该控件的底部边缘与给定ID控件的底部边缘； android:layout_alignLeft：将该控件的左边缘与给定ID控件的左边缘对齐；11.android:layout_alignRight ：将该控件的右边缘与给定ID控件的右边缘对齐；12.android:layout_alignTop ： 将给定控件的顶部边缘与给定ID控件的顶部对齐；相对于父组件13.android:alignParentBottom ：如果该值为true，则将该控件的底部和父控件的底部对齐；14.android:layout_alignParentLeft：如果该值为true，则将该控件的左边与父控件的左边对齐；15.android:layout_alignParentRight ：如果该值为true，则将该控件的右边与父控件的右边对齐；16.android:layout_alignParentTop：如果该值为true，则将空间的顶部与父控件的顶部对齐；17.android:layout_alignWithParentIfMissing 如果对应的兄弟元素找不到的话就以父元素做参照物；居中18.android:layout_centerHorizontal ：如果值为真，该控件将被至于水平方向的中央；19.android:layout_centerInParent：如果值为真，该控件将被至于父控件水平方向和垂直方向的中央；20.android:layout_centerVertical： 如果值为真，该控件将被至于垂直方向的中央；其它21.android:gravity：设置容器中的内容的位置，默认为靠左；22.android:layout_gravity：设置容器中内容相对于容器的位置（无法在relativelayout中使用）；]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[网络请求注意点]]></title>
      <url>http://fengqingxiuyi.xyz/ShowJoy/%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82/%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82%E6%B3%A8%E6%84%8F%E7%82%B9.html</url>
      <content type="html"><![CDATA[注：本文所属ShowJoy-网络请求，本文主要从数据类型和请求参数等方面介绍一些网络请求的注意点，本文持续更新… 快速创建数据实体类步骤： 在AndroidStudio上安装GsonFormat插件，重启AndroidStudio。 创建实体类，如GoodsResult类。 复制接口返回的data下的数据，如{…}，如果data是JSONArray类型，则取其中一个{…}即可。 将光标置于GoodsResult类的{}中，然后按快捷键option+s，出现GsonFormat弹框后，粘贴即可 如果数据格式正确，点击OK会自动生成实体类，否则会出现错误提示：data err! 返回数据类型问题如果有数据返回，则服务端返回的数据格式有以下两种形式： 形式1：data是JSONObject类型123456789&#123; "count": 0, "data": &#123; ... &#125;, "isRedirect": 0, "isSuccess": 1, "login": 0&#125; 形式2：data是JSONArray类型1234567891011121314&#123; "count": 2, "data": [ &#123; ... &#125;, &#123; ... &#125; ], "isRedirect": 0, "isSuccess": 1, "login": 0&#125; 根据不同的数据格式，我们需要创建不同的请求类： 形式1：data是JSONObject类型123456789101112131415161718public class HomeRequest extends SHGetRequest&lt;HomeResult&gt; &#123; @Override protected Class&lt;HomeResult&gt; getDataClass() &#123; return HomeResult.class; &#125; @Override protected TypeReference&lt;HomeResult&gt; getDataTypeReference() &#123; return null; &#125; @NonNull @Override protected String getRequestUrl() &#123; return SHHost.getMainHost()+"/api/shop"; &#125;&#125; 形式2：data是JSONArray类型1234567891011121314151617181920public class GoodsRequest extends SHGetRequest&lt;List&lt;GoodsRequest&gt;&gt; &#123; @Override protected Class&lt;List&lt;GoodsRequest&gt;&gt; getDataClass() &#123; return null; &#125; // 因为TypeReference是抽象类，不可以直接new，所以需要在最后添加&#123;&#125;，作为匿名内部类。 @Override protected TypeReference&lt;List&lt;GoodsRequest&gt;&gt; getDataTypeReference() &#123; return new TypeReference&lt;List&lt;GoodsRequest&gt;&gt;()&#123;&#125;; &#125; @NonNull @Override protected String getRequestUrl() &#123; return SHHost.getMainHost()+"/api/shop/products"; &#125;&#125; addParam问题例如：request.addParam(“page”, page);案例：在一开始的时候我们添加了page字段，此时page值为1；当我们需要加载下一页的时候，怎么修改page字段的值呢？答：有人说直接page++即可实现，但是由于配置参数，开启请求这些操作都是在presenter类里面实现的，我们无法在viewModel类里面直接修改；此时我们只需要覆盖page字段即可，如下所示： 12345public void loadNext() &#123; // page如果存在, 则会被覆盖 goodsRequest.addParam("page", page); goodsRequest.start();&#125; 显示调用接口时，手机网络请求响应过程核心思想：使用Charles软件，利用电脑代理手机网络进行监测步骤： 打开手机上已经的网络的详情页 在代理选项下“主机名”文本框中输入电脑上已连接网络的IP地址 在代理选项下“端口”文本框中输入端口号：8888 打开Charles软件，在Structure对应的文本框中选择我们请求的接口地址，进行数据监测。]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[达人店-网络请求过程]]></title>
      <url>http://fengqingxiuyi.xyz/ShowJoy/%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82/%E8%BE%BE%E4%BA%BA%E5%BA%97-%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82%E8%BF%87%E7%A8%8B.html</url>
      <content type="html"><![CDATA[注：本文所属ShowJoy-网络请求，本文讲述整个达人店App的网络请求过程，本文持续更新… 1、创建BaseActivity，执行onCreate方法，发现如下代码：1viewModel = getViewModel(); 2、进入getViewModel()方法，发现如下代码：1public abstract @NonNull T getViewModel(); 可以得知它是在BaseActivity的子类实现的，随便进入一个子类看看，发现原来是创建了一个子类对象，即如下代码： 12345@NonNull@Overridepublic CategoryViewModel getViewModel() &#123; return new CategoryViewModel(this);&#125; 3、再进入这个子类的构造方法可以发现如下代码：123public CategoryViewModel(BaseActivity activity) &#123; super(activity);&#125; 4、继续进入查看,发现了如下代码：123456public BaseViewModel(BaseActivity activity) &#123; this.activity = activity; this.context = activity.getApplicationContext(); init();&#125; 5、进入init()方法发现如下代码：1234567891011private void init() &#123; presenter = getPresenter(); if (null != presenter) &#123; presenter.initParams(getParams()); if (presenter.requestOnStart()) &#123; presenter.startRequest(); &#125; &#125; ...&#125; 至此可以明白：在getViewModel的时候已经开始请求数据了！！！ 6、重新回到BaseActivity的onCreate方法中，发现它继续执行如下代码：123456setContentView(getContentViewRes());activity = this;context = activity.getApplicationContext();viewModel.initView();viewModel.viewCreated(); 这里我们主要查看viewCreated方法就可以了。 7、进入viewCreated方法，可以发现如下代码：1234567public void viewCreated() &#123; initData(); viewCreated = true; if (null != presenter) &#123; presenter.updateView(); &#125;&#125; 这里我们发现了重要方法，即updateView，显而易见它是用来显示数据的，继续进入可以发现如下代码： 1234567891011public void updateView() &#123; if (!responsed) &#123; showCache(); return; &#125; if (responseSuccess) &#123; responseSuccess(response); &#125; else &#123; responseError(responseErrorCode); &#125;&#125; 8、好，到这里重点来了，之前我们已经说过，在getViewModel的时候已经开始网络请求的，因为是异步请求，所以我们无法得知在执行第7步的时候，是否已经请求完毕，这里分两种情况： 情况一：网络请求尚未完成继续执行updateView中的代码，因为responsed默认为false，所以，此时页面是以缓存的数据进行展示的（注：如果有缓存的话）；之后网络请求完成了，假设请求成功，则执行如下代码： 123456789public void onResponseSuccess(R r) &#123; responsed = true; responseSuccess = true; response = r; if (viewModel.isViewCreated()) &#123; updateView(); &#125;&#125; 因为responsed和viewCreated都已经是true，所以再次执行updateView方法，但因为responsed是true，所以此时的updateView方法执行以下代码： 12345if (responseSuccess) &#123; responseSuccess(response);&#125; else &#123; responseError(responseErrorCode);&#125; 即使用网络请求得到的数据重新展示页面 情况二：网络请求已完成这里以响应成功为例，则会执行onResponseSuccess方法，即如下代码： 123456789public void onResponseSuccess(R r) &#123; responsed = true; responseSuccess = true; response = r; if (viewModel.isViewCreated()) &#123; updateView(); &#125;&#125; 此时因为尚未执行viewCreated方法，所以不执行updateView方法，然后代码继续向下执行，即执行viewCreated方法，即如下代码： 1234567public void viewCreated() &#123; initData(); viewCreated = true; if (null != presenter) &#123; presenter.updateView(); &#125;&#125; 显而易见，执行的是updateView方法，只不过此时responsed已经为true，所以updateView执行的是以下内容： 12345if (responseSuccess) &#123; responseSuccess(response);&#125; else &#123; responseError(responseErrorCode);&#125; 即显示数据的时候不再使用缓存显示，而是用响应的数据进行展示。 9、至此我们就讲完了目前 达人店 项目的网络请求过程。]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[选择恐惧症的福音！教你认清MVC，MVP和MVVM]]></title>
      <url>http://fengqingxiuyi.xyz/Android/%E6%A1%86%E6%9E%B6/%E9%80%89%E6%8B%A9%E6%81%90%E6%83%A7%E7%97%87%E7%9A%84%E7%A6%8F%E9%9F%B3%EF%BC%81%E6%95%99%E4%BD%A0%E8%AE%A4%E6%B8%85MVC%EF%BC%8CMVP%E5%92%8CMVVM.html</url>
      <content type="html"><![CDATA[注：本文所属Android-框架，本文转载自：http://zjutkz.net/2016/04/13/选择恐惧症的福音！教你认清MVC，MVP和MVVM/ 相信大家对MVC，MVP和MVVM都不陌生，作为三个最耳熟能详的Android框架，它们的应用可以是非常广泛的，但是对于一些新手来说，可能对于区分它们三个都有困难，更别说在实际的项目中应用了，有些时候想用MVP的，代码写着写着就变成了MVC，久而久之就对它们三个的选择产生了恐惧感，如果你也是这样的人群，那么这篇文章可能会对你有很大的帮助，希望大家看完都会有收获吧！ 文章重点： (1)了解并区分MVC，MVP，MVVM。 (2)知道这三种模式在Android中如何使用。 (3)走出data binding的误区。 (4)了解MVP+data binding的开发模式。 本篇文章的demo我将会上传到我的github上。 水之积也不厚,则其负大舟也无力正如庄子在逍遥游中说的，如果水不够深，那就没有能够担负大船的力量 。所以在真正开始涉及具体的代码之前，我们要先对MVC，MVP和MVVM做一个初步的了解。如果各位同学对此已经有所了解了，可以选择性跳过这一节。 MVCMVC，Model View Controller，是软件架构中最常见的一种框架，简单来说就是通过controller的控制去操作model层的数据，并且返回给view层展示，具体见下图 当用户出发事件的时候，view层会发送指令到controller层，接着controller去通知model层更新数据，model层更新完数据以后直接显示在view层上，这就是MVC的工作原理。 那具体到Android上是怎么样一个情况呢？ 大家都知道一个Android工程有什么对吧，有java的class文件，有res文件夹，里面是各种资源，还有类似manifest文件等等。对于原生的Android项目来说，layout.xml里面的xml文件就对应于MVC的view层，里面都是一些view的布局代码，而各种java bean，还有一些类似repository类就对应于model层，至于controller层嘛，当然就是各种activity咯。大家可以试着套用我上面说的MVC的工作原理是理解。比如你的界面有一个按钮，按下这个按钮去网络上下载一个文件，这个按钮是view层的，是使用xml来写的，而那些和网络连接相关的代码写在其他类里，比如你可以写一个专门的networkHelper类，这个就是model层，那怎么连接这两层呢？是通过button.setOnClickListener()这个函数，这个函数就写在了activity中，对应于controller层。是不是很清晰。 大家想过这样会有什么问题吗？显然是有的，不然为什么会有MVP和MVVM的诞生呢，是吧。问题就在于xml作为view层，控制能力实在太弱了，你想去动态的改变一个页面的背景，或者动态的隐藏/显示一个按钮，这些都没办法在xml中做，只能把代码写在activity中，造成了activity既是controller层，又是view层的这样一个窘境。大家回想一下自己写的代码，如果是一个逻辑很复杂的页面，activity或者fragment是不是动辄上千行呢？这样不仅写起来麻烦，维护起来更是噩梦。（当然看过Android源码的同学其实会发现上千行的代码不算啥，一个RecyclerView.class的代码都快上万行了呢。。） MVC还有一个重要的缺陷，大家看上面那幅图，view层和model层是相互可知的，这意味着两层之间存在耦合，耦合对于一个大型程序来说是非常致命的，因为这表示开发，测试，维护都需要花大量的精力。 正因为MVC有这样那样的缺点，所以才演化出了MVP和MVVM这两种框架。 MVPMVP作为MVC的演化，解决了MVC不少的缺点，对于Android来说，MVP的model层相对于MVC是一样的，而activity和fragment不再是controller层，而是纯粹的view层，所有关于用户事件的转发全部交由presenter层处理。下面还是让我们看图 从图中就可以看出，最明显的差别就是view层和model层不再相互可知，完全的解耦，取而代之的presenter层充当了桥梁的作用，用于操作view层发出的事件传递到presenter层中，presenter层去操作model层，并且将数据返回给view层，整个过程中view层和model层完全没有联系。看到这里大家可能会问，虽然view层和model层解耦了，但是view层和presenter层不是耦合在一起了吗？其实不是的，对于view层和presenter层的通信，我们是可以通过接口实现的，具体的意思就是说我们的activity，fragment可以去实现实现定义好的接口，而在对应的presenter中通过接口调用方法。不仅如此，我们还可以编写测试用的View，模拟用户的各种操作，从而实现对Presenter的测试。这就解决了MVC模式中测试，维护难的问题。 当然，其实最好的方式是使用fragment作为view层，而activity则是用于创建view层(fragment)和presenter层(presenter)的一个控制器。 MVVMMVVM最早是由微软提出的 这里要感谢泡在网上的日子，因为前面看到的三张图我都是从它的博客中摘取的，如果有人知道不允许这样做的话请告诉我，我会从我的博客中删除的，谢谢。 从图中看出，它和MVP的区别貌似不大，只不过是presenter层换成了viewmodel层，还有一点就是view层和viewmodel层是相互绑定的关系，这意味着当你更新viewmodel层的数据的时候，view层会相应的变动ui。 我们很难去说MVP和MVVM这两个MVC的变种孰优孰劣，还是要具体情况具体分析。 纸上得来终觉浅，绝知此事要躬行对于程序员来说，空谈是最没效率的一种方式，相信大家看了我上面对于三种模式的分析，或多或少都会有点云里雾里，下面让我们结合代码来看看。 让我们试想一下下面这个情景，用户点击一个按钮A，获取github上对应公司对应仓库中贡献排行第一的任的名字，然后我们还会有一个按钮B，用户点击按钮B，界面上排行第一的那个人的名字就会换成自己的。 MVCMVC实现是最简单的。 首先看对应view层的xml文件 &lt;?xml version=”1.0” encoding=”utf-8”?&gt;&lt;LinearLayout xmlns:android=“http://schemas.android.com/apk/res/android“ xmlns:tools=“http://schemas.android.com/tools“ android:layout_width=“match_parent” android:layout_height=“match_parent” android:id=“@+id/container” android:orientation=“vertical” tools:context=“.ui.view.MainActivity” android:fitsSystemWindows=“true”&gt; &lt;Button android:text=“get” android:layout_width=“match_parent” android:layout_height=“wrap_content” android:onClick=“get”/&gt; &lt;Button android:text=“change” android:layout_width=“match_parent” android:layout_height=“wrap_content” android:onClick=“change”/&gt; &lt;TextView android:id=“@+id/top_contributor” android:layout_width=“match_parent” android:layout_height=“match_parent” android:gravity=“center” android:textSize=“30sp”/&gt;&lt;/LinearLayout&gt; 很简单，两个Button一个TextView 接着看对应controller层的activity public class MainActivity extends AppCompatActivity &#123; private ProcessDialog dialog; private Contributor contributor = new Contributor(); private TextView topContributor; private Subscriber&lt;Contributor&gt; contributorSub = new Subscriber&lt;Contributor&gt;() &#123; @Override public void onStart() &#123; showProgress(); &#125; @Override public void onCompleted() &#123; &#125; @Override public void onError(Throwable e) &#123; &#125; @Override public void onNext(Contributor contributor) &#123; MainActivity.this.contributor = contributor; topContributor.setText(contributor.login); dismissProgress(); &#125; &#125;; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); topContributor = (TextView)findViewById(R.id.top_contributor); &#125; public void get(View view)&#123; getTopContributor(“square”, “retrofit”); &#125; public void change(View view)&#123; contributor.login = “zjutkz”; topContributor.setText(contributor.login); &#125; public void getTopContributor(String owner,String repo)&#123; GitHubApi.getContributors(owner, repo) .take(1) .observeOn(AndroidSchedulers.mainThread()) .subscribeOn(Schedulers.newThread()) .map(new Func1&lt;List&lt;Contributor&gt;, Contributor&gt;() &#123; @Override public Contributor call(List&lt;Contributor&gt; contributors) &#123; return contributors.get(0); &#125; &#125;) .subscribe(contributorSub); &#125; public void showProgress()&#123; if(dialog == null)&#123; dialog = new ProcessDialog(this); &#125; dialog.showMessage(“正在加载…”); &#125; public void dismissProgress()&#123; if(dialog == null)&#123; dialog = new ProcessDialog(this); &#125; dialog.dismiss(); &#125;&#125; 我们看一下get()方法中调用的getTopContributor方法 public void getTopContributor(String owner,String repo)&#123; GitHubApi.getContributors(owner, repo) .take(1) .observeOn(AndroidSchedulers.mainThread()) .subscribeOn(Schedulers.newThread()) .map(new Func1&lt;List&lt;Contributor&gt;, Contributor&gt;() &#123; @Override public Contributor call(List&lt;Contributor&gt; contributors) &#123; return contributors.get(0); &#125; &#125;) .subscribe(contributorSub);&#125; 熟悉rxjava和retrofit的同学应该都明白这是啥意思，如果对这两个开源库不熟悉也没事，可以参考给 Android 开发者的 RxJava 详解和用 Retrofit 2 简化 HTTP 请求这两篇文章。 对于这里大家只要知道这段代码的意思就是去获取github上owner公司中的repo仓库里贡献排名第一的那个人。贡献者是通过Contributor这个java bean存储的。 public class Contributor &#123; public String login; public int contributions; @Override public String toString() &#123; return login + “, “ + contributions; &#125;&#125; 很简单，login表示贡献者的名字，contributor表示贡献的次数。 然后通过rxjava的subscriber中的onNext()函数得到这个数据。 private Subscriber&lt;Contributor&gt; contributorSub = new Subscriber&lt;Contributor&gt;() &#123; @Override public void onStart() &#123; showProgress(); &#125; @Override public void onCompleted() &#123; &#125; @Override public void onError(Throwable e) &#123; &#125; @Override public void onNext(Contributor contributor) &#123; MainActivity.this.contributor = contributor; topContributor.setText(contributor.login); dismissProgress(); &#125;&#125;; 至于另外那个change按钮的工作大家应该都看得懂，这里不重复了。 好了，我们来回顾一遍整个流程。 首先在xml中写好布局代码。 其次，activity作为一个controller，里面的逻辑是监听用户点击按钮并作出相应的操作。比如针对get按钮，做的工作就是调用GithubApi的方法去获取数据。 GithubApi，Contributor等类则表示MVC中的model层，里面是数据和一些具体的逻辑操作。 说完了流程再来看看问题，还记得我们前面说的吗，MVC在Android上的应用，一个具体的问题就是activity的责任过重，既是controller又是view。这里是怎么体现的呢？看了代码大家发现其中有一个progressDialog，在加载数据的时候显示，加载完了以后取消，逻辑其实是view层的逻辑，但是这个我们没办法写到xml里面啊，包括TextView.setTextView()，这个也一样。我们只能把这些逻辑写到activity中，这就造成了activity的臃肿，这个例子可能还好，如果是一个复杂的页面呢？大家自己想象一下。 MVP通过具体的代码大家知道了MVC在Android上是如何工作的，也知道了它的缺点，那MVP是如何修正的呢？ 这里先向大家推荐github上的一个第三方库，通过这个库大家可以很轻松的实现MVP。好了，还是看代码吧。 首先还是xml &lt;?xml version=”1.0” encoding=”utf-8”?&gt;&lt;LinearLayout xmlns:android=“http://schemas.android.com/apk/res/android“ xmlns:tools=“http://schemas.android.com/tools“ android:layout_width=“match_parent” android:layout_height=“match_parent” android:id=“@+id/container” android:orientation=“vertical” tools:context=“.ui.view.MainActivity” android:fitsSystemWindows=“true”&gt; &lt;Button android:text=“get” android:layout_width=“match_parent” android:layout_height=“wrap_content” android:onClick=“get”/&gt; &lt;Button android:text=“change” android:layout_width=“match_parent” android:layout_height=“wrap_content” android:onClick=“change”/&gt; &lt;TextView android:id=“@+id/top_contributor” android:layout_width=“match_parent” android:layout_height=“match_parent” android:gravity=“center” android:textSize=“30sp”/&gt;&lt;/LinearLayout&gt; 这个和MVC是一样的，毕竟界面的形式是一样的嘛。 接下去，我们看一个接口。 public interface ContributorView extends MvpView &#123; void onLoadContributorStart(); void onLoadContributorComplete(Contributor topContributor); void onChangeContributorName(String name);&#125; 这个接口起什么作用呢？还记得我之前说的吗？MVP模式中，view层和presenter层靠的就是接口进行连接，而具体的就是上面的这个了，里面定义的三个方法，第一个是开始获取数据，第二个是获取数据成功，第三个是改名。我们的view层（activity）只要实现这个接口就可以了。 下面看activity的代码 public class MainActivity extends MvpActivity&lt;ContributorView,ContributorPresenter&gt; implements ContributorView &#123; private ProcessDialog dialog; private TextView topContributor; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); topContributor = (TextView)findViewById(R.id.top_contributor); &#125; @NonNull @Override public ContributorPresenter createPresenter() &#123; return new ContributorPresenter(); &#125; public void get(View view)&#123; getPresenter().get(“square”, “retrofit”); &#125; public void change(View view)&#123; getPresenter().change(); &#125; @Override public void onLoadContributorStart() &#123; showProgress(); &#125; @Override public void onLoadContributorComplete(Contributor contributor) &#123; topContributor.setText(contributor.toString()); dismissProgress(); &#125; @Override public void onChangeContributorName(String name) &#123; topContributor.setText(name); &#125; public void showProgress()&#123; if(dialog == null)&#123; dialog = new ProcessDialog(this); &#125; dialog.showMessage(“正在加载…”); &#125; public void dismissProgress()&#123; if(dialog == null)&#123; dialog = new ProcessDialog(this); &#125; dialog.dismiss(); &#125;&#125; 它继承自MvpActivity，实现了刚才的ContributorView接口。继承的那个MvpActivity大家这里不用太关心主要是做了一些初始化和生命周期的封装。我们只要关心这个activity作为view层，到底是怎么工作的。 public void get(View view)&#123; getPresenter().get(“square”, “retrofit”);&#125;public void change(View view)&#123; getPresenter().change();&#125; get()和change()这两个方法是我们点击按钮以后执行的，可以看到，里面完完全全没有任何和model层逻辑相关的东西，只是简单的委托给了presenter，那我们再看看presenter层做了什么 public class ContributorPresenter extends MvpBasePresenter&lt;ContributorView&gt; &#123; private Subscriber&lt;Contributor&gt; contributorSub = new Subscriber&lt;Contributor&gt;() &#123; @Override public void onStart() &#123; ContributorView view = getView(); if(view != null)&#123; view.onLoadContributorStart(); &#125; &#125; @Override public void onCompleted() &#123; &#125; @Override public void onError(Throwable e) &#123; &#125; @Override public void onNext(Contributor topContributor) &#123; ContributorView view = getView(); if(view != null)&#123; view.onLoadContributorComplete(topContributor); &#125; &#125; &#125;; public void get(String owner,String repo)&#123; GitHubApi.getContributors(owner, repo) .take(1) .observeOn(AndroidSchedulers.mainThread()) .subscribeOn(Schedulers.newThread()) .map(new Func1&lt;List&lt;Contributor&gt;, Contributor&gt;() &#123; @Override public Contributor call(List&lt;Contributor&gt; contributors) &#123; return contributors.get(0); &#125; &#125;) .subscribe(contributorSub); &#125; public void change()&#123; ContributorView view = getView(); if(view != null)&#123; view.onChangeContributorName(“zjutkz”); &#125; &#125;&#125; 其实就是把刚才MVC中activity的那部分和model层相关的逻辑抽取了出来，并且在相应的时机调用ContributorView接口对应的方法，而我们的activity是实现了这个接口的，自然会走到对应的方法中。 好了，我们来捋一捋。 首先，和MVC最大的不同，MVP把activity作为了view层，通过代码也可以看到，整个activity没有任何和model层相关的逻辑代码，取而代之的是把代码放到了presenter层中，presenter获取了model层的数据之后，通过接口的形式将view层需要的数据返回给它就OK了。 这样的好处是什么呢？首先，activity的代码逻辑减少了，其次，view层和model层完全解耦，具体来说，如果你需要测试一个http请求是否顺利，你不需要写一个activity，只需要写一个java类，实现对应的接口，presenter获取了数据自然会调用相应的方法，相应的，你也可以自己在presenter中mock数据，分发给view层，用来测试布局是否正确。 MVVM首先在看这段内容之前，你需要保证你对data binding框架有基础的了解。不了解的同学可以去看下这篇文章。在接下去让我们开始探索MVVM，MVVM最近在Android上可谓十分之火，最主要的原因就是谷歌推出了data binding这个框架，可以轻松的实现MVVM。但是，我在网上查阅关于Android的data binding资料的时候，发现国内有很多人都误解了，首先，我们从一篇错误的文章开始。当然我在这里引用这篇文章也是对事不对人，如果对文章的作者产生了不好的影响我这里说一声抱歉。 上面那篇文章是一个关于data binding的使用，看起来很美好，但是，其中有一个错误可以说是非常，非常，非常严重的。 它竟然说data binding的viewmodel层是binding类，其实不止是这篇文章，其他有一些开发者写的关于data binding的文章里都犯了一样的错误。大家如果也有这样的概念，请务必纠正过来！！ 说完了错误的概念，那data binding中真正的viewmodel是什么呢？我们还是以之前MVC，MVP的那个例子做引导。 首先是view层，这没啥好说的，和MVP一样，只不过多了数据绑定。view层就是xml和activity。 &lt;layout xmlns:android=“http://schemas.android.com/apk/res/android“&gt; &lt;data&gt; &lt;variable name=“contributor” type=“zjutkz.com.mvvm.viewmodel.Contributor”/&gt; &lt;/data&gt; &lt;LinearLayout android:layout_width=“match_parent” android:layout_height=“match_parent” android:id=“@+id/container” android:orientation=“vertical” android:fitsSystemWindows=“true”&gt; &lt;Button android:id=“@+id/get” android:text=“get” android:layout_width=“match_parent” android:layout_height=“wrap_content” android:onClick=“get”/&gt; &lt;Button android:id=“@+id/change” android:text=“change” android:layout_width=“match_parent” android:layout_height=“wrap_content” android:onClick=“change”/&gt; &lt;TextView android:id=“@+id/top_contributor” android:layout_width=“match_parent” android:layout_height=“match_parent” android:gravity=“center” android:textSize=“30sp” android:text=“@&#123;contributor.login&#125;”/&gt; &lt;/LinearLayout&gt;&lt;/layout&gt; public class MainActivity extends AppCompatActivity &#123; private Subscriber&lt;Contributor&gt; contributorSub = new Subscriber&lt;Contributor&gt;() &#123; @Override public void onStart() &#123; showProgress(); &#125; @Override public void onCompleted() &#123; &#125; @Override public void onError(Throwable e) &#123; &#125; @Override public void onNext(Contributor contributor) &#123; binding.setContributor(contributor); dismissProgress(); &#125; &#125;; private ProcessDialog dialog; private MvvmActivityMainBinding binding; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); binding = DataBindingUtil.setContentView(this, R.layout.mvvm_activity_main); &#125; public void get(View view)&#123; getContributors(“square”, “retrofit”); &#125; public void change(View view)&#123; if(binding.getContributor() != null)&#123; binding.getContributor().setLogin(“zjutkz”); &#125; &#125; public void showProgress()&#123; if(dialog == null)&#123; dialog = new ProcessDialog(this); &#125; dialog.showMessage(“正在加载…”); &#125; public void dismissProgress()&#123; if(dialog == null)&#123; dialog = new ProcessDialog(this); &#125; dialog.dismiss(); &#125; public void getContributors(String owner,String repo)&#123; GitHubApi.getContributors(owner, repo) .take(1) .observeOn(AndroidSchedulers.mainThread()) .subscribeOn(Schedulers.newThread()) .map(new Func1&lt;List&lt;Contributor&gt;, Contributor&gt;() &#123; @Override public Contributor call(List&lt;Contributor&gt; contributors) &#123; return contributors.get(0); &#125; &#125;) .subscribe(contributorSub); &#125;&#125; 如果你对data binding框架是有了解的，上面的代码你能轻松的看懂。 那model层又是什么呢？当然就是那些和数据相关的类，GithubApi等等。 重点来了，viewmodel层呢？好吧，viewmodel层就是是Contributor类！大家不要惊讶，我慢慢的来说。 public class Contributor extends BaseObservable&#123; private String login; private int contributions; @Bindable public String getLogin()&#123; return login; &#125; @Bindable public int getContributions()&#123; return contributions; &#125; public void setLogin(String login)&#123; this.login = login; notifyPropertyChanged(BR.login); &#125; public void setContributions(int contributions)&#123; this.contributions = contributions; notifyPropertyChanged(BR.contributions); &#125; @Override public String toString() &#123; return login + “, “ + contributions; &#125;&#125; 我们可以看到，Contributor和MVP相比，继承自了BaseObservable，有基础的同学都知道这是为了当Contributor内部的variable改变的时候ui可以同步的作出响应。 我为什么说Contributor是一个viewmodel呢。大家还记得viewmodel的概念吗？view和viewmodel相互绑定在一起，viewmodel的改变会同步到view层，从而view层作出响应。这不就是Contributor和xml中那些组件元素的关系吗？所以，大家不要被binding类迷惑了，data binding框架中的viewmodel是自己定义的那些看似是model类的东西！比如这里的Contributor！ 话说到这里，那binding类又是什么呢？其实具体对应到之前MVVM的那张图就很好理解了，我们想一下，binding类的工作是什么？ binding = DataBindingUtil.setContentView(this, R.layout.mvvm_activity_main);binding.setContributor(contributor); 首先，binding要通过DataBindingUtil.setContentView()方法将xml，也就是view层设定。 接着，通过setXXX()方法将viewmodel层注入进去。 由于这两个工作，view层(xml的各个组件)和viewmodel层(contributor)绑定在了一起。 好了，大家知道了吗，binding类，其实就是上图中view和viewmodel中间的那根线啊！！ 真理在荒谬被证实以前，都只是暗室里的装饰前面讨论了MVC，MVP和MVVM具体的实现方案，大家肯定都了解了它们三者的关系和使用方式。但是，这里我想说，不要把一个框架看作万能的，其实MVP和MVVM都是有自己的缺陷的！下面我一一来说。 MVPMVP的问题在于，由于我们使用了接口的方式去连接view层和presenter层，这样就导致了一个问题，如果你有一个逻辑很复杂的页面，你的接口会有很多，十几二十个都不足为奇。想象一个app中有很多个这样复杂的页面，维护接口的成本就会非常的大。 这个问题的解决方案就是你得根据自己的业务逻辑去斟酌着写接口。你可以定义一些基类接口，把一些公共的逻辑，比如网络请求成功失败，toast等等放在里面，之后你再定义新的接口的时候可以继承自那些基类，这样会好不少。 MVVMMVVM的问题呢，其实和MVC有一点像。data binding框架解决了数据绑定的问题，但是view层还是会过重，大家可以看我上面那个MVVM模式下的activity public class MainActivity extends AppCompatActivity &#123; private Subscriber&lt;Contributor&gt; contributorSub = new Subscriber&lt;Contributor&gt;() &#123; @Override public void onStart() &#123; showProgress(); &#125; @Override public void onCompleted() &#123; &#125; @Override public void onError(Throwable e) &#123; &#125; @Override public void onNext(Contributor contributor) &#123; binding.setContributor(contributor); dismissProgress(); &#125; &#125;; private ProcessDialog dialog; private MvvmActivityMainBinding binding; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); binding = DataBindingUtil.setContentView(this, R.layout.mvvm_activity_main); &#125; public void get(View view)&#123; getContributors(“square”, “retrofit”); &#125; public void change(View view)&#123; if(binding.getContributor() != null)&#123; binding.getContributor().setLogin(“zjutkz”); &#125; &#125; public void showProgress()&#123; if(dialog == null)&#123; dialog = new ProcessDialog(this); &#125; dialog.showMessage(“正在加载…”); &#125; public void dismissProgress()&#123; if(dialog == null)&#123; dialog = new ProcessDialog(this); &#125; dialog.dismiss(); &#125; public void getContributors(String owner,String repo)&#123; GitHubApi.getContributors(owner, repo) .take(1) .observeOn(AndroidSchedulers.mainThread()) .subscribeOn(Schedulers.newThread()) .map(new Func1&lt;List&lt;Contributor&gt;, Contributor&gt;() &#123; @Override public Contributor call(List&lt;Contributor&gt; contributors) &#123; return contributors.get(0); &#125; &#125;) .subscribe(contributorSub); &#125;&#125; 大家有没有发现，activity在MVVM中应该是view层的，但是里面却和MVC一样写了对model的处理。有人会说你可以把对model的处理放到viewmodel层中，这样不是更符合MVVM的设计理念吗？这样确实可以，但是progressDialog的show和dismiss呢？你怎么在viewmodel层中控制？这是view层的东西啊，而且在xml中也没有，我相信会有解决的方案，但是我们有没有一种更加便捷的方式呢？ 路漫漫其修远兮，吾将上下而求索其实，真正的最佳实践都是人想出来的，我们为何不结合一下MVP和MVVM的特点呢？其实谷歌已经做了这样的事，大家可以看下这个。没错，就是MVP+data binding，我们可以使用presenter去做和model层的通信，并且使用data binding去轻松的bind data。还是让我们看代码吧。 首先还是view层。 &lt;layout xmlns:android=“http://schemas.android.com/apk/res/android“&gt; &lt;data&gt; &lt;variable name=“contributor” type=“zjutkz.com.mvpdatabinding.viewmodel.Contributor”/&gt; &lt;/data&gt; &lt;LinearLayout android:layout_width=“match_parent” android:layout_height=“match_parent” android:id=“@+id/container” android:orientation=“vertical” android:fitsSystemWindows=“true”&gt; &lt;Button android:id=“@+id/get” android:text=“get” android:layout_width=“match_parent” android:layout_height=“wrap_content” android:onClick=“get”/&gt; &lt;Button android:id=“@+id/change” android:text=“change” android:layout_width=“match_parent” android:layout_height=“wrap_content” android:onClick=“change”/&gt; &lt;TextView android:id=“@+id/top_contributor” android:layout_width=“match_parent” android:layout_height=“match_parent” android:gravity=“center” android:textSize=“30sp” android:text=“@&#123;contributor.login&#125;”/&gt; &lt;/LinearLayout&gt;&lt;/layout&gt; public class MainActivity extends MvpActivity&lt;ContributorView,ContributorPresenter&gt; implements ContributorView &#123; private ProcessDialog dialog; private ActivityMainBinding binding; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); binding = DataBindingUtil.setContentView(this, R.layout.activity_main); &#125; @NonNull @Override public ContributorPresenter createPresenter() &#123; return new ContributorPresenter(); &#125; public void get(View view)&#123; getPresenter().get(“square”, “retrofit”); &#125; public void change(View view)&#123; if(binding.getContributor() != null)&#123; binding.getContributor().setLogin(“zjutkz”); &#125; &#125; @Override public void onLoadContributorStart() &#123; showProgress(); &#125; @Override public void onLoadContributorComplete(Contributor contributor) &#123; binding.setContributor(contributor); dismissProgress(); &#125; public void showProgress()&#123; if(dialog == null)&#123; dialog = new ProcessDialog(this); &#125; dialog.showMessage(“正在加载…”); &#125; public void dismissProgress()&#123; if(dialog == null)&#123; dialog = new ProcessDialog(this); &#125; dialog.dismiss(); &#125;&#125; 然后是presenter层 public class ContributorPresenter extends MvpBasePresenter&lt;ContributorView&gt; &#123; private Subscriber&lt;Contributor&gt; contributorSub = new Subscriber&lt;Contributor&gt;() &#123; @Override public void onStart() &#123; ContributorView view = getView(); if(view != null)&#123; view.onLoadContributorStart(); &#125; &#125; @Override public void onCompleted() &#123; &#125; @Override public void onError(Throwable e) &#123; &#125; @Override public void onNext(Contributor topContributor) &#123; ContributorView view = getView(); if(view != null)&#123; view.onLoadContributorComplete(topContributor); &#125; &#125; &#125;; public void get(String owner,String repo)&#123; GitHubApi.getContributors(owner, repo) .take(1) .observeOn(AndroidSchedulers.mainThread()) .subscribeOn(Schedulers.newThread()) .map(new Func1&lt;List&lt;Contributor&gt;, Contributor&gt;() &#123; @Override public Contributor call(List&lt;Contributor&gt; contributors) &#123; return contributors.get(0); &#125; &#125;) .subscribe(contributorSub); &#125;&#125; model层就是GithubApi等等。 我们使用了data binding框架去节省了类似findViewById和数据绑定的时间，又使用了presenter去将业务逻辑和view层分离。 当然这也不是固定的，你大可以在viewmodel中实现相应的接口，presenter层的数据直接发送到viewmodel中，在viewmodel里更新，因为view和viewmodel是绑定的，这样view也会相应的作出反应。 说到这里，我还是想重复刚才的那句话，最佳实践都是人想出来的，用这些框架根本的原因也是为了尽量低的耦合性和尽量高的可复用性。 下期预告还是想好下期写点啥，如果我能想到的话，see you next week.]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[MVP思想复杂使用]]></title>
      <url>http://fengqingxiuyi.xyz/ShowJoy/MVP/MVP%E6%80%9D%E6%83%B3%E5%A4%8D%E6%9D%82%E4%BD%BF%E7%94%A8.html</url>
      <content type="html"><![CDATA[注：本文所属ShowJoy-MVP，由于和前文MVP思想简单使用类似，所以此处不做过多阐述，以情况二为例： 情况二：打开的页面需要直接调用一个或多个接口注意：本情况最好是只调用一个接口，以搜索页面为例！！！ 创建实体类因为需要直接调用接口，所以我们必须的先创建好实体类，例如： 12345678public class SearchResult &#123; /** * shareId : 26 */ public int shareId;&#125; 创建请求类接着就需要创建请求类了，即SearchRequest类，主要用于请求地址的拼接与请求服务器，例如： 12345678910111213141516171819202122232425public class SearchRequest extends SHGetRequest&lt;List&lt;SearchResult&gt;&gt; &#123; @Override protected Class&lt;List&lt;SearchResult&gt;&gt; getDataClass() &#123; return null; &#125; @Override protected TypeReference&lt;List&lt;SearchResult&gt;&gt; getDataTypeReference() &#123; return new TypeReference&lt;List&lt;SearchResult&gt;&gt;()&#123;&#125;; &#125; @NonNull @Override protected String getRequestUrl() &#123; return SHHost.getMainHost() + "individuation/brands"; &#125; public void start(String id, int iddd) &#123; addParam("id", id); addParam("iddd", iddd); super.start(); &#125;&#125; 创建数据操作类然后我们需要创建数据操作类，即searchPresenter类，主要用于开启请求，处理请求成功或失败后返回的数据，进行解析、处理等操作，例如： 123456789101112131415161718192021222324252627282930313233343536373839404142434445public class SearchPresenter extends BasePresenter&lt;SearchViewModel, SHResponse&lt;List&lt;SearchResult&gt;&gt;&gt; &#123; SplashRequest splashRequest; public SearchPresenter(SearchViewModel viewModel) &#123; super(viewModel); &#125; @Override public BaseRequest getRequest() &#123; request = new SearchRequest(); //添加参数 request.addParam("type", 1); return request; &#125; @Override public void responseSuccess(SHResponse&lt;List&lt;SearchResult&gt;&gt; response) &#123; &#125; @Override public void responseError(int error) &#123; &#125; @Override public boolean needRequestData() &#123; return false; &#125; public void startSearchRequest(int id) &#123; splashRequest = new SplashRequest(); splashRequest.addParam("id", id); splashRequest.setCallBack(new IRequestCallBack&lt;SHResponse&lt;SplashResult&gt;&gt;() &#123; @Override public void onResponseSuccess(SHResponse&lt;SplashResult&gt; splashResultSHResponse) &#123; &#125; &#125;); splashRequest.start(); &#125;&#125; 创建ViewModel类再然后我们需要创建数据展示类，即SearchViewModel类，主要用于接收searchPresenter类传递过来的数据，并进行展示，例如： 123456789101112131415161718192021222324252627282930313233343536public class SearchViewModel extends BaseViewModel&lt;SearchPresenter&gt; &#123; private SwipeListView searchListView; private SearchListAdapter searchListAdapter; private SHListViewFooterView listViewFootView; public SearchViewModel(BaseActivity activity) &#123; super(activity); &#125; @Override public void initView() &#123; searchListView = (SwipeListView) findViewById(R.id.search_list_view); listViewFootView = new SHListViewFooterView(context); searchListAdapter = new SearchListAdapter(activity, null); searchListAdapter.setFooter(listViewFootView); searchListView.setAdapter(searchListAdapter); &#125; @Override protected void initData() &#123; //TODO adapter init &#125; @Override protected SearchPresenter getPresenter() &#123; return new SearchPresenter(this); &#125; //添加不同函数用于界面更新 public void updateListView(List&lt;SearchResult&gt; results) &#123; presenter.startSearchRequest(23); &#125;&#125; 创建Activity类最后就和情况一一样了，只需要创建SearchActivity类，实现相应的方法即可，例如： 123456789101112public class SearchActivity extends BaseActivity&lt;SearchViewModel&gt; &#123; @NonNull @Override public SearchViewModel getViewModel() &#123; return new SearchViewModel(this); &#125; @Override public int getContentViewRes() &#123; return R.layout.search_activity; &#125;&#125;]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[MVP思想简单使用]]></title>
      <url>http://fengqingxiuyi.xyz/ShowJoy/MVP/MVP%E6%80%9D%E6%83%B3%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8.html</url>
      <content type="html"><![CDATA[注：本文所属ShowJoy-MVP，由于MVC导致了Activity负担过程，而且View和Model之间耦合严重，所里本文就MVP思想简单做了以下两种情况： 情况一：打开的页面不需要立刻调用接口注意：本情况以关于我们页面为例！！！ 创建ViewModel类创建AboutViewModel类继承于BaseViewModel，并实现需要实现的方法，主要用于实现相关的业务逻辑。参考案例如下： 12345678910111213141516171819202122232425262728293031323334353637public class AboutViewModel extends BaseViewModel &#123; public AboutViewModel(BaseActivity activity) &#123; super(activity); &#125; @Override public void initView() &#123; &#125; @Override protected void initData() &#123; &#125; @Override protected void startRequest() &#123; &#125; @Override protected BaseRequest getRequest() &#123; return null; &#125; @Override protected void handleResponse(SHResponse response) &#123; &#125; @Override public void onResume() &#123; super.onResume(); &#125;&#125; 创建Activity类创建AboutActivity类继承于BaseActivity，并实现需要实现的方法即可，参考案例如下： 1234567891011public class AboutActivity extends BaseActivity&lt;AboutViewModel&gt; &#123; @NonNull @Override public AboutViewModel getViewModel() &#123; return new AboutViewModel(this); &#125; @Override public int getContentViewRes() &#123; return R.layout.about_activity; &#125;&#125; 情况二：打开的页面需要直接调用一个或多个接口注意：本情况最好是只调用一个接口，以搜索页面为例！！！ 创建实体类因为需要直接调用接口，所以我们必须的先创建好实体类，例如： 12345678public class SearchResult &#123; /** * shareId : 26 */ public int shareId;&#125; 创建请求类然后就需要创建请求类了，即SearchRequest类，主要用于请求地址的拼接与请求服务器，例如： 12345678910111213141516171819202122232425public class SearchRequest extends SHGetRequest&lt;List&lt;SearchResult&gt;&gt; &#123; @Override protected Class&lt;List&lt;SearchResult&gt;&gt; getDataClass() &#123; return null; &#125; @Override protected TypeReference&lt;List&lt;SearchResult&gt;&gt; getDataTypeReference() &#123; return new TypeReference&lt;List&lt;SearchResult&gt;&gt;()&#123;&#125;; &#125; @NonNull @Override protected String getRequestUrl() &#123; return SHHost.getMainHost() + "individuation/brands"; &#125; public void start(String id, int iddd) &#123; addParam("id", id); addParam("iddd", iddd); super.start(); &#125;&#125; 创建ViewModel类全部准备完毕之后，就需要编写SearchViewModel类了，由于不清楚服务器返回的数据类型，所以我们在接受数据的时候，必须编写相对应的数据类型，如果返回的是JSON字符串类型则只需要把List去掉即可，即： 123public class SearchViewModel extends BaseViewModel&lt;SearchRequest, SHResponse&lt;SearchResult&gt;&gt; &#123; ...&#125;； 此处返回的是JSON数组类型，所以我们以集合的形式进行接收，例如： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253public class SearchViewModel extends BaseViewModel&lt;SearchRequest, SHResponse&lt;List&lt;SearchResult&gt;&gt;&gt; &#123; AllBrandRequest allBrandRequest; public SearchViewModel(BaseActivity activity) &#123; super(activity); &#125; @Override public void initView() &#123; //TODO findviewbyid , init &#125; @Override protected void initData() &#123; //TODO adapter init &#125; @Override protected void startRequest() &#123; request.start("331", 33); //TODO 其他请求， allBrandRequest = new AllBrandRequest(); allBrandRequest.setCallBack(new IRequestCallBack&lt;SHResponse&lt;AllBrandResult&gt;&gt;() &#123; @Override public void onResponseSuccess(SHResponse&lt;AllBrandResult&gt; response) &#123; &#125; &#125;); allBrandRequest.start(); &#125; @Override protected SearchRequest getRequest() &#123; return new SearchRequest(); &#125; @Override protected void handleResponse(SHResponse&lt;List&lt;SearchResult&gt;&gt; response) &#123; //TODO 处理请求结果 &#125; @Override public void onDestroy() &#123; super.onDestroy(); if (allBrandRequest != null) &#123; allBrandRequest.stop(); &#125; &#125;&#125; 创建Activity类最后就和情况一一样了，只需要创建SearchActivity类，实现相应的方法即可，例如： 123456789101112public class SearchActivity extends BaseActivity&lt;SearchViewModel&gt; &#123; @NonNull @Override public SearchViewModel getViewModel() &#123; return new SearchViewModel(this); &#125; @Override public int getContentViewRes() &#123; return R.layout.search_activity; &#125;&#125;]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[图片拼接+布局转换为图片]]></title>
      <url>http://fengqingxiuyi.xyz/ShowJoy/View/%E5%9B%BE%E7%89%87%E6%8B%BC%E6%8E%A5+%E5%B8%83%E5%B1%80%E8%BD%AC%E6%8D%A2%E4%B8%BA%E5%9B%BE%E7%89%87.html</url>
      <content type="html"><![CDATA[注：本文所属ShowJoy-View，业务需求详细描述：最近产品说要在分享的商品图中添加一些其他图片和文字，然后拼接为一张图片，再分享到微信朋友圈，于是我就一脸懵逼了，但是没办法还是得做额！ 然后整理了一下思路，主要有这么两条路线： 自己手动绘制。 将布局转换为图片。 很显然第一种方式是不合适的，无论是开发前还是开发后，成本都很大，所以果断选择了第二种方式。 一开始的时候，我没有经过大脑思考，果断的使用了getDrawingCache这个方法来解决这个业务需求，大致流程如下：（1）创建需要显示成图片的布局，代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" android:id="@+id/picmontage_root" android:layout_width="match_parent" android:layout_height="match_parent" android:orientation="vertical"&gt; &lt;RelativeLayout android:layout_width="match_parent" android:layout_height="wrap_content" android:layout_weight="1" android:background="@android:color/white"&gt; &lt;ImageView android:id="@+id/img_shop" android:layout_width="match_parent" android:layout_height="match_parent" android:layout_margin="20dp" /&gt; &lt;RelativeLayout android:layout_width="wrap_content" android:layout_height="wrap_content" android:layout_alignParentBottom="true" android:layout_centerHorizontal="true" android:layout_marginBottom="20dp"&gt; &lt;ImageView android:id="@+id/img_price" android:layout_width="wrap_content" android:layout_height="wrap_content"/&gt; &lt;TextView android:id="@+id/txt_price" android:layout_width="wrap_content" android:layout_height="wrap_content" android:layout_centerInParent="true" /&gt; &lt;/RelativeLayout&gt; &lt;/RelativeLayout&gt; &lt;LinearLayout android:layout_width="match_parent" android:layout_height="wrap_content" android:background="@android:color/white"&gt; &lt;ImageView android:id="@+id/img_qrcode" android:layout_width="wrap_content" android:layout_height="wrap_content" android:layout_margin="20dp" /&gt; &lt;LinearLayout android:layout_width="wrap_content" android:layout_height="wrap_content" android:layout_marginBottom="20dp" android:layout_marginRight="20dp" android:layout_marginTop="20dp" android:orientation="vertical"&gt; &lt;TextView android:layout_width="wrap_content" android:layout_height="wrap_content" android:text="黄老五 提子味皇式烤芙条 300g 沙琪玛 休闲办公室零食...\n" android:textColor="@android:color/black" /&gt; &lt;TextView android:layout_width="wrap_content" android:layout_height="wrap_content" android:text="长按识别二维码或扫一扫购买\n" android:textColor="@android:color/darker_gray" /&gt; &lt;TextView android:layout_width="wrap_content" android:layout_height="wrap_content" android:text="From 萌店" android:textColor="@android:color/darker_gray" /&gt; &lt;/LinearLayout&gt; &lt;/LinearLayout&gt;&lt;/LinearLayout&gt; （2）设置图片和文字信息，这里为了方便，直接把文字放到了布局中，设置图片的代码如下所示： 123456789101112131415161718private void addLinearLayout() &#123; view = View.inflate(this, R.layout.activity_picmontage, null); LinearLayout picmontageRoot = (LinearLayout) view.findViewById(R.id.picmontage_root); ImageView shopImg = (ImageView) view.findViewById(R.id.img_shop); ImageView priceImg = (ImageView) view.findViewById(R.id.img_price); TextView priceTxt = (TextView) view.findViewById(R.id.txt_price); ImageView qrcodeImg = (ImageView) view.findViewById(R.id.img_qrcode); shopImg.setImageResource(R.mipmap.shop); priceImg.setImageResource(R.mipmap.price); priceTxt.setText("$ 20.00"); priceTxt.setTextSize(20); priceTxt.setTextColor(Color.WHITE); qrcodeImg.setImageResource(R.mipmap.qrcode); addViewContent.addView(view);&#125; （3）然后就可以将布局转换成图片了，代码如下所示： 1234567891011121314151617181920212223242526272829303132private void drawingCacheShow() &#123; Bitmap cacheBitmap = convertViewToBitmap(addViewContent); //Bitmap cacheBitmap = getMagicDrawingCache(addViewContent); //addViewContent.removeView(view); if(cacheBitmap != null) &#123; Bitmap newBitmap = Bitmap.createBitmap(cacheBitmap); if (newBitmap != null) &#123; imgAddViewCache.setImageBitmap(newBitmap); &#125; else &#123; Log.i("123", "newBitmap=null"); &#125; &#125; else &#123; Log.i("123", "cacheBitmap=null"); &#125;&#125;public static Bitmap convertViewToBitmap(View view)&#123; view.measure( View.MeasureSpec.makeMeasureSpec(0, View.MeasureSpec.UNSPECIFIED), View.MeasureSpec.makeMeasureSpec(0, View.MeasureSpec.UNSPECIFIED)); view.layout(0, 0, view.getMeasuredWidth(), view.getMeasuredHeight()); view.buildDrawingCache(); Bitmap bitmap = view.getDrawingCache(); if (bitmap != null) &#123; Bitmap.Config cfg = bitmap.getConfig(); Log.d("123", "----------------------- cache.getConfig() = " + cfg); &#125; return bitmap;&#125; （4）然后发现图片不能正确显示，经过debug之后发现原来是图片过大的缘故，一脸懵逼，虽然使用了这样的压缩算法，但总是不尽如人意： 123456789101112131415161718192021222324252627282930313233343536373839404142434445private void addLinearLayout() &#123; view = View.inflate(this, R.layout.activity_picmontage, null); LinearLayout picmontageRoot = (LinearLayout) view.findViewById(R.id.picmontage_root); ImageView shopImg = (ImageView) view.findViewById(R.id.img_shop); ImageView priceImg = (ImageView) view.findViewById(R.id.img_price); TextView priceTxt = (TextView) view.findViewById(R.id.txt_price); ImageView qrcodeImg = (ImageView) view.findViewById(R.id.img_qrcode); // 压缩shop Bitmap bitmap = BitmapFactory.decodeResource(getResources(), R.mipmap.shop); shopImg.setImageBitmap(resizeBm(bitmap, 600)); priceImg.setImageResource(R.mipmap.price); priceTxt.setText("$ 20.00"); priceTxt.setTextSize(20); priceTxt.setTextColor(Color.WHITE); qrcodeImg.setImageResource(R.mipmap.qrcode); addViewContent.addView(view);&#125;private Bitmap resizeBm(Bitmap bitmap, int scaleWidth) &#123; // 原始宽高 float rawWidth = bitmap.getWidth(); float rawHeight = bitmap.getHeight(); // 新宽高 float newWidth = 0; float newHeight = 0; // 将宽度缩放到scaleWidth if(rawWidth&gt;scaleWidth) &#123; newWidth = scaleWidth; newHeight = rawHeight*(scaleWidth/rawWidth); &#125; else &#123; newWidth = rawWidth; newHeight = rawHeight; &#125; // 计算缩放比例 float widthScale = newWidth/rawWidth; float heightScale = newHeight/rawHeight; Log.i("123", "widthScale="+widthScale+", heightScale="+heightScale); // 显示 Matrix matrix = new Matrix(); matrix.postScale(widthScale,heightScale); Bitmap resizeBmp = Bitmap.createBitmap(bitmap,0,0,bitmap.getWidth(),bitmap.getHeight(),matrix,true); return resizeBmp;&#125; 之后有了大神的帮助，终于顿悟了，发现了神奇的方法：view.draw(canvas)。然后就很简单了：这里的第1步和第2步流程与上面的1、2步流程一模一样，我们直接进入第3步，我先给出主界面中的布局： 123456789101112131415161718192021222324252627282930313233343536373839&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" android:id="@+id/main_root" android:layout_width="match_parent" android:layout_height="match_parent" android:orientation="vertical"&gt; &lt;ScrollView android:layout_width="match_parent" android:layout_height="wrap_content"&gt; &lt;LinearLayout android:layout_width="match_parent" android:layout_height="wrap_content" android:orientation="vertical"&gt; &lt;Button android:layout_width="match_parent" android:layout_height="wrap_content" android:onClick="showPic" android:text="显示绘制的图片" /&gt; &lt;ImageView android:id="@+id/img" android:layout_width="wrap_content" android:layout_height="wrap_content" /&gt; &lt;LinearLayout android:id="@+id/main_content" android:visibility="invisible" android:layout_width="match_parent" android:layout_height="wrap_content" android:orientation="vertical"/&gt; &lt;/LinearLayout&gt; &lt;/ScrollView&gt;&lt;/LinearLayout&gt; （3）然后将该布局添加到主界面中，并设置为invisible，但不能设置为gone，否则不能成功渲染，同样不能生成图片了： 1mainContent.addView(v); （4）最后我们就可以在点击事件里面将布局生成图片了，代码如下： 12345678public void showPic(View view) &#123; int width = picmontageRoot.getMeasuredWidth(); int height = picmontageRoot.getMeasuredHeight(); Bitmap b = Bitmap.createBitmap(width, height, Bitmap.Config.RGB_565); Canvas canvas = new Canvas(b); picmontageRoot.draw(canvas); img.setImageBitmap(b);&#125;]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[网络请求的使用与查找]]></title>
      <url>http://fengqingxiuyi.xyz/ShowJoy/%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82/%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82%E7%9A%84%E4%BD%BF%E7%94%A8%E4%B8%8E%E6%9F%A5%E6%89%BE.html</url>
      <content type="html"><![CDATA[注：本文所属ShowJoy-网络请求，本文根据情况介绍网络请求的使用方式与查找源码过程。 情况一：网络请求的使用：由于路飞已经把网络请求封装的很好了，所以实现起来是很方便的，目前网络请求是通过volley+okhttp3+fastjson来实现的。 以GET请求而言，主要的继承机构如下： 1BaseRequest&lt;T&gt; -&gt; BaseGetRequest&lt;T&gt; -&gt; SHGetRequest&lt;T&gt; 所以当我们有新的业务需要进行网络请求时，只需要新建一个继承于SHGetRequest的子类，例如：GetShareIdRequest。然后除了要实现必要的方法外，还需要根据实际情况判断是否需要实现start方法，用于参数的拼接。例如： 12345678910111213141516171819202122232425public class GetShareIdRequest extends SHGetRequest&lt;ShareID&gt; &#123; @Override protected Class&lt;ShareID&gt; getDataClass() &#123; return ShareID.class; &#125; @Override protected TypeReference&lt;ShareID&gt; getDataTypeReference() &#123; return null; &#125; @NonNull @Override protected String getRequestUrl() &#123; return SHHost.getHost() + "/activity/share/create"; &#125; public void start(String outProductId, String activityId, String userId) &#123; addParam("outProductId", outProductId); addParam("outProductId", activityId); addParam("userId", userId); super.start(); &#125;&#125; 然后创建GetShareIdRequest的对象，并对它设置回调，实现IRequestCallBack抽象类中需要实现的方法： 12345678910111213getShareIdRequest.setCallBack(new IRequestCallBack&lt;SHResponse&lt;ShareID&gt;&gt;() &#123; @Override public void onResponseSuccess(SHResponse&lt;ShareID&gt; response) &#123; if (response.isSuccess) &#123; if (shareUrl.contains("?")) &#123; shareUrl = shareUrl + "&amp;trackId=" + response.data.shareId; &#125;else &#123; shareUrl = shareUrl + "?trackId=" + response.data.shareId; &#125; &#125; mMoreWindow = new ShareWindow(activity, title, shareTxt, shareUrl, shareImg); &#125;&#125;); 最后调用start方法，开启请求即可，即以下语句： 1getShareIdRequest.start("", activityId, UserDataManager.getUserId()); 情况二：网络请求的查找：案例：购给利商品详情页点击分享按钮时无法弹出分享弹框，提示“网络错误，请重试”。 为了知道哪里出了问题，所以我们首先需要查找到它真正的URL地址究竟是什么，在哪里。 查找URL地址过程：（1）首页我们找到点击分享按钮这个点击事件的触发位置： 1234567891011121314private void showShareDialog(final View view) &#123; if (null == shareDialog) &#123; final String shareUrl = SHHost.getMobileUrl() + "/product/" + outProductId + ".html"; if (UserDataManager.isLogin()) &#123; getShareIdRequest = new GetShareIdRequest(); ... getShareIdRequest.start(outProductId, activityId, UserDataManager.getUserId()); &#125;else &#123; shareDialog = new ShareWindow(activity, skuVo.getName(), skuVo.description, shareUrl, skuVo.getImage()); &#125; &#125;else &#123; shareDialog.show(view); &#125;&#125; 我们可以发现在第5行创建了一个GetShareIdRequest请求，然后点进去看看： 123456789101112@NonNull@Overrideprotected String getRequestUrl() &#123; return SHHost.getHost() + "/activity/share/create";&#125;public void start(String outProductId, String activityId, String userId) &#123; addParam("outProductId", outProductId); addParam("outProductId", activityId); addParam("userId", userId); super.start();&#125; 发现只是进行请求地址和参数的拼接，并没有我们需要的部分，所以继续查找其父类SHGetRequest： 123456789101112131415protected SHResponse parseResponse(SHResponse response) &#123; if(null != response.data &amp;&amp; response.data instanceof JSON) &#123; Class dataClazz = this.getDataClass(); if(null != dataClazz) &#123; response.data = JSON.toJavaObject((JSON)response.data, dataClazz); &#125; else &#123; TypeReference typeReference = this.getDataTypeReference(); if(null != typeReference) &#123; response.data = JSON.parseObject(((JSON)response.data).toJSONString(), typeReference, new Feature[0]); &#125; &#125; &#125; return response;&#125; 发现最重要的代码只是一个解析响应数据的方法，仍然与我们的需求不一致，所以依然继续查找其父类： 1234567BaseGetRequest：public BaseGetRequest() &#123;&#125;protected int getRequestMethod() &#123; return 0;&#125; 发现只有这两个方法，所以不多说了，继续前进吧，看看它的父类BaseRequest，终于不再继承了，辛苦额，答案肯定就在其中了： 代码还是比较多的，那么我们怎么查找呢，因为开始第一步的时候我们只看了它创建对象的过程： 1getShareIdRequest = new GetShareIdRequest(); 所以我们首先得找到一个创建请求的方法，即createRequest： 12345678910111213141516171819202122private Request createRequest() &#123; String url = this.getRequestUrl(); if(TextUtils.isEmpty(url)) &#123; return null; &#125; else &#123; int method = this.getRequestMethod(); Listener listener = new Listener() &#123; ... &#125;; ErrorListener errorListener = new ErrorListener() &#123; ... &#125;; Object params = this.getParams(); if(null == params) &#123; params = new HashMap(); &#125; SHNetworkLog.d("request:", url); SHNetworkLog.d("request params:", params.toString()); return 0 == method?new FastJsonRequest(method, this.getRealUrl(url, (Map)params), this.getTypeReference(), listener, errorListener):(this.multipartRequestParams.hasFile()?new FastJsonRequest(method, url, this.multipartRequestParams, this.getTypeReference(), listener, errorListener):new FastJsonRequest(method, url, (Map)params, this.getTypeReference(), listener, errorListener)); &#125;&#125; 因为我们的最终目的是查找URL地址，所以Listener监听器与我们无关，此处省略，最后发现了return语句，其中包含了URL地址，但是调用的是哪个方法呢？这个时候就需要我们使用debug技术来进行判断了！debug之后发现它调用的是前一个函数，我们点进去看看： 123public FastJsonRequest(int method, String url, TypeReference&lt;T&gt; typeReference, Listener&lt;T&gt; listener, ErrorListener errorListener) &#123; this(method, url, (Map)(new HashMap()), typeReference, listener, errorListener);&#125; 发现它接收五个参数，分别是请求方法类型（GET或POST）、请求地址，引用类型、监听器，至此我们终于发现了请求地址的存在，然后返回，继续在BaseGetRequest类中查看，发现主要代码是： 1this.getRealUrl(url, (Map)params) 再进入这个方法看看： 123456789101112131415161718private String getRealUrl(String url, Map&lt;String, String&gt; mParams) &#123; if(null == mParams) &#123; return url; &#125; else &#123; Uri uri = Uri.parse(url); Builder builder = uri.buildUpon(); Iterator realUrl = mParams.entrySet().iterator(); while(realUrl.hasNext()) &#123; Entry entry = (Entry)realUrl.next(); builder.appendQueryParameter((String)entry.getKey(), (String)entry.getValue()); &#125; String realUrl1 = builder.build().toString(); SHNetworkLog.d("RealUrl:", realUrl1); return realUrl1; &#125;&#125; 原来这是将URL和参数进行拼接的方法，最后的realUrl1即真正的请求地址。 情况二：操作流程图]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Intent统一跳转协议]]></title>
      <url>http://fengqingxiuyi.xyz/ShowJoy/Intent/Intent%E7%BB%9F%E4%B8%80%E8%B7%B3%E8%BD%AC%E5%8D%8F%E8%AE%AE.html</url>
      <content type="html"><![CDATA[注：本文所属ShowJoy-Intent，本文主要介绍如何统一Intent统一跳转协议，并实现解耦。 目的Intent统一跳转协议就是为了解决模块之间的耦合而存在的，不再以 1startActivity(new Intent(this, OtherActivity.class)); 的方式进行页面跳转，而是以路径的形式进行跳转，去除了模块之间的引用，从而解决了模块之间的耦合问题。 其中路径形式一般是以下形式： 1跳转Uri：scheme://host/path 但是因为这样形式的路径都是在Androidmanifset.xml文件中进行定义的，根据业务的需要，不一定会完整定义跳转Uri，所以有以下两种情况。 情况一：定义完整情况一：在清单文件中已经定义完整了data中的scheme、host和path后，一般不需要在Activity中接收处理，除非含有其他参数，例如gougeli://page.sh/detail?userId=123456。 Intent统一跳转协议分为以下几步： （1）在Androidmanifest.xml文件中配置intent-filter，例如： 12345678910111213&lt;activity android:name=".module.detail.DetailActivity" android:exported="true" android:screenOrientation="portrait" &gt; &lt;intent-filter&gt; &lt;action android:name="android.intent.action.VIEW"/&gt; &lt;category android:name="android.intent.category.DEFAULT"/&gt; &lt;category android:name="android.intent.category.BROWSABLE"/&gt; &lt;data android:scheme="gougeili" android:host="page.sh" android:path="/detail"/&gt; &lt;/intent-filter&gt;&lt;/activity&gt; （2）新建一个枚举类型的文件ActivityType，定义名称为Androidmanifest.xml文件中的intent-filter字段下的data字段下的android:path的值，例如： 123456789101112131415public enum ActivityType &#123; DETAIL("detail"); private final String text; ActivityType(final String text) &#123; this.text = text; &#125; @Override public String toString() &#123; return text; &#125;&#125; （3）编写SHIntent类，获取统一跳转所需的intent意图，通过之前设置的ActivityType实现路径的拼接，具体实现如下： 12345678910111213static final String SCHEME = "gougeili://";static final String HOST = "page.sh/";public static Intent getIntent(ActivityType activityType) &#123; return new Intent(Intent.ACTION_VIEW, Uri.parse(getUrl(activityType.toString())));&#125;static String getUrl(String type) &#123; StringBuilder builder = new StringBuilder(SCHEME); builder.append(HOST); builder.append(type); return builder.toString();&#125; （4）到此我们就设置好了接收方，接下来就是设置发送方了。我们可以设置一个SHJump类，编写跳转到detail的方法，参数可填写bean类，用于数据的传递。例如： 12345678public static void goToDetail(Activity activity, SkuVo skuVo) &#123; Intent intent = SHIntent.getIntent(ActivityType.DETAIL); intent.putExtra(DetailConstants.EXTRA_ID, skuVo.outProductId); intent.putExtra(DetailConstants.EXTRA_PRICE, skuVo.price); intent.putExtra(DetailConstants.EXTRA_IMAGE, skuVo.skuPicture); intent.putExtra(DetailConstants.EXTRA_TITLE, skuVo.name); activity.startActivity(intent);&#125; 当然也可以是其他的参数类型，但是你也应该发现了，如果在SHJump类中写好了，也意味着写死了，如果需要灵活的实现数据的传递，可以通过SHIntent实现，其实是一样的，只不过不封装在SHJump类中了，因为SHJump类中存放的是通用方法。 情况一：操作流程图 情况二：未定义完整情况二：在清单文件中未定义完整data中的参数，例如只定义了scheme，那么就需要在该Activity中进行接收处理，例如：gglapp://2836482321。 Intent统一跳转协议分为以下几步： （1）在Androidmanifest.xml文件中配置intent-filter，例如： 1234567891011121314151617&lt;activity android:name=".module.splash.StartActivity" android:exported="true" android:theme="@style/Theme.Activity.Start" android:screenOrientation="portrait" &gt; &lt;intent-filter&gt; &lt;action android:name="android.intent.action.MAIN" /&gt; &lt;category android:name="android.intent.category.LAUNCHER" /&gt; &lt;/intent-filter&gt; &lt;intent-filter&gt; &lt;action android:name="android.intent.action.VIEW"/&gt; &lt;category android:name="android.intent.category.DEFAULT"/&gt; &lt;category android:name="android.intent.category.BROWSABLE"/&gt; &lt;data android:scheme="gglapp"/&gt; &lt;/intent-filter&gt;&lt;/activity&gt; （2）此处并未使用统一跳转协议，所以以详细情况为例： 问：将购给利中的商品分享到微信后，用浏览器打开该链接，再点击其中的某个商品，只是跳转到客户端的首页，不能够跳转到购给利的商品详情页？ 答：使用intent接收并传递数据时，使用的intent对象出现错误，导致uri为空。 代码解析：因为从外部浏览器跳转到内部Activity，必然有一个Uri地址，再由上述清单文件中只是定义了scheme，最后根据问题得知最终目的是跳转到商品详情页，所以StartActivity必然有通过getIntent方法接收Uri地址的代码，通过搜索getIntent发现如下代码： 1234567891011121314private void skip() &#123; Intent intent = getIntent(); Uri uri = intent.getData(); Intent mainIntent = new Intent(this, MainActivity.class); Bundle bundle = new Bundle(); mainIntent.putExtra(AppConstants.EXTRA_URI, uri); ... startActivity(mainIntent); finish();&#125; 上述代码表示从浏览器接收到了Uri地址之后，并将其传递到了MainActivity这个类中。 （3）然后我们可以在MainActivity中查找相关代码，这样比较复杂，我们可以将光标移动到EXTRA_URI处，然后按option+F7，即可迅速定位到相关代码位置，代码如下： 12345678@Overrideprotected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); ... Uri uri = getIntent().getParcelableExtra(AppConstants.EXTRA_URI); UriHandler.handle(this, uri);&#125; 于是我们发现它将Uri交给了UriHandler进行处理，再到UriHandler类中进行查看： 123456789101112131415161718192021222324252627282930public static boolean handle(Activity activity, Uri uri) &#123; if (null == uri) &#123; return false; &#125; LogUtils.d("uri:", uri.toString()); String host = uri.getHost(); if (TextUtils.isEmpty(host)) &#123; return false; &#125; if (host.equals("gglappFulishe")) &#123; activity.startActivity(new Intent(activity, AddressActivity.class)); return true; &#125; else &#123; Set&lt;String&gt; params = uri.getQueryParameterNames(); Intent intent = SHIntent.getIntent(ActivityType.DETAIL); intent.putExtra(DetailConstants.EXTRA_ID, host); for (String param : params) &#123; intent.putExtra(param, uri.getQueryParameter(param)); &#125; activity.startActivity(intent); return true; &#125;&#125; 最终发现了处理Uri的详细操作，原来它是通过匹配host来进行区分处理的。 情况二：操作流程图 附另外还需要注意的是，我们定义这样形式的路径只是定义了接收方而已，而发送方是谁都可以进行发送的。]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Jenkins项目构建过程详解]]></title>
      <url>http://fengqingxiuyi.xyz/ShowJoy/Jenkins/Jenkins%E9%A1%B9%E7%9B%AE%E6%9E%84%E5%BB%BA%E8%BF%87%E7%A8%8B%E8%AF%A6%E8%A7%A3.html</url>
      <content type="html"><![CDATA[注：本文所属ShowJoy-Jenkins，本文详细介绍Jenkins项目构建的整个流程。 首页网址：网站首页地址如下所示：http://192.168.0.62:8080/ 构建项目过程： 在网页右侧选择需要进行项目构建的项目选项，如尚妆、购给利等，网址如：http://192.168.0.62:8080/view/购给利/ 点击网页左侧第一栏：新建，进行构建项目所需要的配置信息，如：Enter an item name：gougeli-1.5.3类别：构建一个自由风格的软件项目Copy from：输入字符就会自动列出可能需要的结果，如：gougeili-1.5.2 输入完毕后点击OK会进入详细的配置信息页面，网址如：http://192.168.0.62:8080/view/购给利/job/gougeili-1.5.3/configure一般需要修改的地方如下：描述、Branches to build -&gt; Branch Specifier (blank for ‘any’)中的分支名、Execute shell -&gt; Command中的分支名，其他的地方慎重处理，最后点击Apply或者保存按钮进行保存。 注意：点击Apply不会关闭本页面，点击保存会关闭页面，并跳转到：http://192.168.0.62:8080/view/购给利/job/gougeili-1.5.3/。 然后点击左侧立即构建按钮，就会开始构建，构建完成或失败后可以在左侧最下面的构建历史中详细查看相对应的信息。 具体操作流程请查看“项目构建GIF操作流程图” 操作流程图]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Mac+GitHub+Hexo+NexT（五）偏好设置+Markdown]]></title>
      <url>http://fengqingxiuyi.xyz/MGHN/Mac+GitHub+Hexo+NexT%EF%BC%88%E4%BA%94%EF%BC%89%E5%81%8F%E5%A5%BD%E8%AE%BE%E7%BD%AE+Markdown.html</url>
      <content type="html"><![CDATA[注：本文所属MGHN，上文主要讲述了NexT的偏好设置，接下来就让我们开始Hexo的偏好设置吧。 首先进行相关重要说明，请仔细阅读： 本人是在Mac搭建博客的，所以不会包含和Windows相关的内容，操作系统参数如下：MacBook Pro OS X EI Capitan 10.11.5。 因为搭建博客的过程中会经常输命令，所以： 如果文中代码区块是以$开头的话，代表的是终端默认目录，如：QingFengdeMacBook-Pro:~ qingfeng$。 如果文中代码区块是以Blog $开头的话，代表的是站点根目录，如：QingFengdeMacBook-Pro:Blog qingfeng$。 如果文中代码区块是以next $开头的话，代表的是主题根目录，如：QingFengdeMacBook-Pro:next qingfeng$。 所有输出类文字或者是提示性文字或者是重点文字都会有自带背景色。 需要掌握vim的基本知识和用法。 网站基本设置网站基本设置主要包括：标题、个性签名、用户名、语言和头像，即以下所示： 123456789# Sitetitle: # 网站标题subtitle: # 网站副标题description: # 个人描述即个性签名author: # 用户名language: # 网站语言，如：zh-Hans即为简体中文timezone: # 网站时区# 头像avatar: /images/avatar.png 搜索搜索功能对于每个网站都是很重要的，它可以帮助我们快速查找需要查找的内容，本网站也不例外，官网所推荐的搜索服务是Swiftype，但是效果不是太好，所以我们使用本地搜索功能。 首先我们需要安装search插件，在站点根目录下执行以下命令： 1Blog $ npm install hexo-generator-search --save 然后我们打开站配置文件，在其中新增search字段，具体填写内容如下所示： 123search: path: search.xml field: post 最后我们需要修改网站的url，具体修改内容如下所示： 123456# URL## If your site is put in a subdirectory, set url as &apos;http://yoursite.com/child&apos; and root as &apos;/child/&apos;url: https://fengqingxiuyi.github.io/root: /permalink: :year/:month/:day/:title/permalink_defaults: 其实就是把其中url对应的默认值修改为你的网站域名。 MarkdownHexo博客是基于Markdown来进行编写的，由于相关的编辑器也有很多，所以这里就不做太多阐述了，大家有兴趣可以去这里看看。 Mac下主要是用Mou编辑器进行编写的。界面效果如下所示： 并附上教程地址：Markdown简单的世界 附最后推荐几篇个人认为Hexo博客搭建写的比较好的文章（包括官方教程）： Hexo中文官方教程 NexT开始使用教程，注意：右上角还有其他方面的教程 不蒜子-搞定你的网站计数 Markdown简单的世界 在github上搭建blog(基于Node.js的Hexo+next) 使用Hexo + Next搭建静态博客 Hexo+Next搭建Github个人静态博客 Hexo搭建GitHub博客（一）- 环境搭建，注意：还有第二、三部分哦！ Jekyll迁移到Hexo搭建个人博客]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Mac+GitHub+Hexo+NexT（四）NexT]]></title>
      <url>http://fengqingxiuyi.xyz/MGHN/Mac+GitHub+Hexo+NexT%EF%BC%88%E5%9B%9B%EF%BC%89NexT.html</url>
      <content type="html"><![CDATA[注：本文所属MGHN，博客框架我们已经全部搭建完成了，但是大部分人都不喜欢默认的landscape主题，因此，在本文中我就讲解一下很热门的NexT主题。 首先进行相关重要说明，请仔细阅读： 本人是在Mac搭建博客的，所以不会包含和Windows相关的内容，操作系统参数如下：MacBook Pro OS X EI Capitan 10.11.5。 因为搭建博客的过程中会经常输命令，所以： 如果文中代码区块是以$开头的话，代表的是终端默认目录，如：QingFengdeMacBook-Pro:~ qingfeng$。 如果文中代码区块是以Blog $开头的话，代表的是站点根目录，如：QingFengdeMacBook-Pro:Blog qingfeng$。 如果文中代码区块是以next $开头的话，代表的是主题根目录，如：QingFengdeMacBook-Pro:next qingfeng$。 所有输出类文字或者是提示性文字或者是重点文字都会有自带背景色。 需要掌握vim的基本知识和用法。 关于NexT主题的下载安装与使用，在官方文档中已经描述的十分详细了，所以这里我就讲一些个人认为比较重要的部分。 favicon12# Put your favicon.ico into `hexo-site/source/` directory.favicon: /images/favicon.ico 显而易见，favicon的起始目录就是source下，所以对我而言：favicon的完整目录就是/Blog/source/images/favicon.ico。 RSS1234# Set rss to false to disable feed link.# Leave rss as empty to use site&apos;s feed link.# Set rss to specific value if you have burned your feed already.rss: 有需要的可以设置一下，这里我就简要阐述一下： 在站点根目录下，新建一个字段plugins，然后进行如下配置： 12plugins:- hexo-generator-feed # 插件名 然后再配置显示你站点的RSS，文件路径\atom.xml，即： 1234# Set rss to false to disable feed link.# Leave rss as empty to use site&apos;s feed link.# Set rss to specific value if you have burned your feed already.rss: \atom.xml 最后你可以使用RSS作为迁移工具，用如下命令读取其他位置的RSS： 1Blog $ hexo migrate rss &lt;source&gt; # source是本地或网络文件路径 网站创建日期12# Specify the date when the site was setupsince: 2016 一般显示在网页最底部 菜单栏设置12345678# When running the site in a subdirectory (e.g. domain.tld/blog), remove the leading slash (/archives -&gt; archives)menu: home: / # 主页 categories: /categories # 分类页（需手动创建） #about: /about # 关于页面（需手动创建） archives: /archives # 归档页 tags: /tags # 标签页（需手动创建） #commonweal: /404.html # 404页面（需手动创建） 在这里我们直接将categories和tags前面的#去掉，如果你想在首页显示关于页面和404页面的话，同样也可以将前面的#去掉。但是这样还不能让去掉#的页面正常显示，需要我们进行一些操作，请这里只介绍分类页和标签页修改。 分类页我们回到站点根目录下，然后输入命令： 1Blog $ hexo new page &quot;categories&quot; 会在source目录下新建一个categories文件夹，里面包含一个index.md文件，然后用文本编辑器打开该文件，并将其头文件修改成一下格式： 12345---title: categoriesdate: 2016-07-14 18:35:46type: &quot;categories&quot;--- 标签页修改完分类页后，继续输入命令： 1Blog $ hexo new page &quot;tags&quot; 会在source目录下新建一个tags文件夹，里面包含一个index.md文件，同样的用文本编辑器打开该文件，并将其头文件修改成一下格式： 12345---title: tagsdate: 2016-07-14 18:31:07type: &quot;tags&quot;--- 主题样式NexT主题一共有一下三种样式，分别有不同的显示效果，具体功能显示如下所示： 12345678# ---------------------------------------------------------------# Scheme Settings# ---------------------------------------------------------------# Schemes#scheme: Muse # 默认 Scheme，这是 NexT 最初的版本，黑白主调，大量留白scheme: Mist # Muse 的紧凑版本，整洁有序的单栏外观#scheme: Pisces # 双栏 Scheme，小家碧玉似的清新 字体字体的设置就看个人兴趣了，以下是我的字体设置，有兴趣的可以看一下，默认配置与我的配置只有一个不同点：它们很多都没有设置family的值。 1234567891011121314151617181920212223242526272829303132333435363738394041424344# ---------------------------------------------------------------# Font Settings# - Find fonts on Google Fonts (https://www.google.com/fonts)# - All fonts set here will have the following styles:# light, light italic, normal, normal intalic, bold, bold italic# - Be aware that setting too much fonts will cause site running slowly# - Introduce in 5.0.1# ---------------------------------------------------------------font: enable: true # Uri of fonts host. E.g. //fonts.googleapis.com (Default) host: # Global font settings used on &lt;body&gt; element. global: # external: true will load this font family from host. external: true family: Monda # Font settings for Headlines (h1, h2, h3, h4, h5, h6) # Fallback to `global` font settings. headings: external: true family: Roboto Slab # Font settings for posts # Fallback to `global` font settings. posts: external: true family: # Font settings for Logo # Fallback to `global` font settings. # The `size` option use `px` as unit logo: external: true family: Lobster Two size: 24 # Font settings for &lt;code&gt; and code blocks. codes: external: true family: PT Monos Social Links这里没有写中文标题的原因是：直接翻译过来总感觉不合适，在我看来，这边一般都是存放和自己有直接关联的地址，如：自己的博客地址，微博地址等，像我的就是这样： 123456789# Social Links# Key is the link label showing to end users.# Value is the target link (E.g. GitHub: https://github.com/iissnan)social: #LinkLabel: Link GitHub: https://github.com/fengqingxiuyi CSDN: http://blog.csdn.net/u012505400 新浪微博: http://weibo.com/sd323 # 等等 友情链接不多说了，直接上我的配置： 123456789# Blogrollslinks_title: 友情链接#links_layout: block#links_layout: inlinelinks: #Title: http://example.com/ Cribug: http://notes.cribug.com/ 郭朝的博客: http://blog.csdn.net/smartbetter/ 郭霖的专栏: http://blog.csdn.net/guolin_blog/ 代码高亮主题顾名思义，适用于将代码块区域高亮显示的，当然不同语言的代码块区域高亮规则是不一样的，它的默认主题是normal，一般有以下几个主题，我这边选择了night bright： 12345# Code Highlight theme# Available value:# normal | night | night eighties | night blue | night bright# https://github.com/chriskempson/tomorrow-themehighlight_theme: night bright 第三方服务关于多说评论和LeanCloud，这里就不做过多阐述了，大家看官方文档就可以了，点击超链接即可进入他们各自的官方网站。 这里我们主要讲述以下另外一种站点访问计数方法，即不蒜子，在这里我要对博主zhiho表示感谢，文中第6章对于此站点访问计数方法写的十分详细，虽然看起来有点小复杂，但是只要细心就不会出现奇葩问题的，所以我也就不做阐述了。 如果你有兴趣的话，你也可以看看这篇文章中对于sitemap插件，也是有很大帮助的。 网站背景如果你想要给自己的网站加一个背景图片也很简单，你只需要一下两步就行了： 首先将背景图片存放到该目录下： 1Blog $ cd themes/next/source/images/ 接着打开你的scheme所在的目录，比如我的scheme是Mist，然后编辑index.styl文件，即以下两条命令： 12Blog $ cd themes/next/source/css/_schemes/Mist(Pisces和Muse也行)/Blog $ vim index.styl 打开index.styl文件之后，在Components上面新增设置背景图片的代码，具体内容如下所示： 1234567...@import &quot;sidebar/sidebar-blogroll&quot;;body &#123; background:url(/images/back.png);&#125;// Components... 最后重新部署就可以了！ 附至此，我们已经讲解完了NexT主题的使用，如果你有其他个性化设置，欢迎留言；相信在前面讲解Hexo的时候，大家早就迫不及待的修改了一些Hexo中的个性化配置了吧，接下来我们来详细的配置一下。]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Mac+GitHub+Hexo+NexT（三）Hexo]]></title>
      <url>http://fengqingxiuyi.xyz/MGHN/Mac+GitHub+Hexo+NexT%EF%BC%88%E4%B8%89%EF%BC%89Hexo.html</url>
      <content type="html"><![CDATA[注：本文所属MGHN，上文我们学会了如何安装Git和Node.js，接下来我们就需要开始真正的搭建Hexo博客框架了。 首先进行相关重要说明，请仔细阅读： 本人是在Mac搭建博客的，所以不会包含和Windows相关的内容，操作系统参数如下：MacBook Pro OS X EI Capitan 10.11.5。 因为搭建博客的过程中会经常输命令，所以： 如果文中代码区块是以$开头的话，代表的是终端默认目录，如：QingFengdeMacBook-Pro:~ qingfeng$。 所有输出类文字或者是提示性文字或者是重点文字都会有自带背景色。 需要掌握vim的基本知识和用法。 安装Hexo安装npm安装Hexo需要使用npm插件，由于我使用的Mac电脑，所以一般都是自带npm 的，如果你没有的话，请自行下载安装，此处不做阐述。 安装Hexo下载安装打开终端后，直接输入命令： 1$ npm install hexo-cli -g 如果出现权限不足之类的错误，可以使用sudo提升权限，则新命令如下： 1$ sudo npm install hexo-cli -g 校检安装Hexo安装完成之后，也需要判断是否安装成功，继续输入命令： 1$ hexo -v 会出现一系列信息，如果每一行都显示正确的版本号信息，则表明安装正确，如下图所示： 搭建博客初始化Hexo首先选择一个目录用于存放和博客相关的文件，如果没有中意的目录，可以创建，比如我创建的名为Blog的文件夹，然后进入该目录下，输入命令： 1Blog $ hexo init 用于初始化Hexo。全部完成以后会出现一些文件或文件夹，目录结构如下所示： 12345678910根目录 |----_config.yml # 全局配置文件 |----node_modules # 插件安装位置 |----package.json # Hexo框架参数 |----scaffolds # 包含新建文章的文件头模板 |----scripts # 脚本目录，JavaScript文件会自动执行 |----source # 保存新建的文章及相关资源 |----_drafts # 保存临时文件 |----_posts # 保存新建的文章，md文件会被编译成html文件 |----themes # 网站主题 预览博客继续输入命令： 1Blog $ hexo server 当出现Hexo is running at http://localhost:4000/. Press Ctrl+C to stop.这样的提示消息时，我们就可以在浏览器中打开http://localhost:4000/，用于访问自己的博客了。按Ctrl+C即可停止server服务。 新建文章预览好博客之后，我们来写一篇文章吧！那么，怎么写呢？很简单，我们按Ctrl+C停止了Hexo的server服务后，接着输入命令： 1Blog $ hexo new &quot;Hello World&quot; 于是我们就创建了一篇名为Hello World的文章，并且终端也会告诉我们它的存储位置，如：INFO Created: /Volumes/MAIN/qingfeng/Blog/source/_posts/Hello-World.md。 然后我们用文本编辑器打开该文件之后，会发现其中包含着这样一个文件头信息： 123456---title: Hello World # 文章标题即文件名date: 2016-07-17 11:36:39 # 日期tags: # 标签，值为[value1, value2, ...]的格式---# 正文，需要用MarkDown语言编写 生成静态网页继续输入命令： 1Blog $ hexo generate 即可生成静态网页。 部署到GitHub安装自动部署插件部署到GitHub即意味着将本地文件上传到GitHub网站中，所以显然是需要工具来实现的。在这里就介绍一下自动部署到GitHub上的插件，我们只需要输入一下命令： 1Blog $ npm install hexo-deployer-git --save 即可实现下载安装，有些博客中该命令是没有最后的--save这一部分的，我这里这样写主要是为了防止出现一些不必要的错误。 编辑全局配置文件打开全局配置文件下载安装成功之后，我们需要修改一下全局配置文件，输入一下命令： 1Blog $ vim _config.yml 即可编辑该文件，目前我们将 1234# Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy: type: 修改为 123456# Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy: type: git # 因为Hexo版本大于3.0，所以填git；否则填github repository: # 你的仓库地址 branch: # 你工程的分支名 例如下图所示： 查看仓库地址进入你的GitHub官网即可查看，如我的GitHub地址，打开后，点击页面右边中部的绿色按钮，名称为Clone or download，即可复制仓库地址，HTTPS和SSH两者皆可。 如果仓库地址填写为SSH地址，则必须要先配置好SSH key，可以在Mac+GitHub+Hexo+NexT —— GitHub一文中学习如何配置。 注意点 type、repository、branch必须并列对齐，切前面只能有两个空格符。 每个冒号后面都必须要有一个空格符（链接地址中的冒号除外）。 部署输入命令： 1Blog $ hexo deploy 即可进行部署操作，如果输出内容为ERROR Deployer not found: git，则表明你的全局配置文件填写错误，或者是之前安装自动化部署插件时，所用的命令后面没有添加-- save，或者是其他原因，需要仔细排查。 浏览查看如果成功部署到了GitHub之上，我们就可以在浏览器中查看我们自己的博客了，在浏览器中输入你的GitHub仓库名即可查看，如：https://fengqingxiuyi.github.io/，如果显示正确，并且与你在本地预览时的别效果一模一样，则表明部署成功！如果显示错误，比如：显示404。 打开网页https://github.com/fengqingxiuyi/fengqingxiuyi.github.io/settings 如果你的Repository name，并不是按照name.github.io的格式，其中：除了大小写可以不同之外，name必须和Github’s Username一模一样；如果和前面所述规则不同，请即刻修改Repository name，否则会出现各种问题。 在网页左侧点击Options选项，然后向下滚动到GitHub Pages子模块处，可以在Source发现GitHub Pages is currently disabled.的字样，具体表现为在Select source下拉菜单中默认选择的是None，这里我们选择master branch，然后点击Save按钮。 第2步完成之后，会自动刷新页面，如果在页面顶部出现GitHub Pages source saved.的提示，则表明保存成功。继续向下滚动到GitHub Pages子模块处，可以发现提示Your site is published at https://fengqingxiuyi.github.io/，然后直接点击该链接即可访问你的专属博客。 命令简写1234hexo n == hexo newhexo g == hexo generatehexo s == hexo serverhexo d == hexo deploy 附至此，我们已经学会了博客的搭建与使用，接下来我们将要讲解如何使用NexT主题，美化我们的博客，当然你也可以使用其他主题美化，这里列举了一些好看的Hexo主题。]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Mac+GitHub+Hexo+NexT（二）Git+Node.js]]></title>
      <url>http://fengqingxiuyi.xyz/MGHN/Mac+GitHub+Hexo+NexT%EF%BC%88%E4%BA%8C%EF%BC%89Git+Node.js.html</url>
      <content type="html"><![CDATA[注：本文所属MGHN，上文我们主要讲了如何创建GitHub账号和配置SSH，接下我们就来学习一下怎么安装Git和Node.js吧！ 首先还是进行相关重要说明，请仔细阅读： 本人是在Mac搭建博客的，所以不会包含和Windows相关的内容，操作系统参数如下：MacBook Pro OS X EI Capitan 10.11.5。 因为搭建博客的过程中会经常输命令，所以： 如果文中代码区块是以$开头的话，代表的是终端默认目录，如：QingFengdeMacBook-Pro:~ qingfeng$。 所有输出类文字或者是提示性文字或者是重点文字都会有自带背景色。 接下来开始正文阐述： 安装Git什么是Git我们每安装一个软件都应该了解它是什么，能干什么。这里简要阐述一下： Git是目前世界上最先进的分布式版本控制系统（没有之一）。 Git有什么特点？简单来说就是：高端大气上档次！ 附上廖雪峰的Git经典入门教程：Git入门教程 安装途径与过程安装Git的方式有很多种，我们即可以从官网下载，也可以使用其他方式安装，这里我们使用Homebrew来进行安装。 安装Homebrew安装Homebrew十分简单，我们只需要在打开终端之后，直接输入命令： 1$ /usr/bin/ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)” 然后等待它下载安装即可。 安装GitHomebrew安装完成之后，继续输入命令： 1$ brew install git 就会自动下载最新的Git进行安装。 安装校检安装完成之后，如何知道Git是否安装成功了呢？很简单，我们继续输入命令： 1$ git --verison 如果正确输出版本号信息，则表明Git安装正确，反之则表明安装失败，如果操作无误的话，请尝试其他途径。 安装Node.js下载安装进入Node.js的官网，然后下载需要的版本就可以了，如官方推荐版本。下载完成之后，双击安装包一步一步进行傻瓜式安装即可。 安装校检跟安装Git一样，我们也需要判断Node.js是否安装正确，同样十分简单，在终端输入命令： 1$ node -v 如果正确输出版本号信息，则表明Node.js安装正确。 附至此，想必大家已经学会怎么安装Git和Node.js了吧，接下来让我们开始Hexo的正式征途吧。]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Mac+GitHub+Hexo+NexT（一）GitHub]]></title>
      <url>http://fengqingxiuyi.xyz/MGHN/Mac+GitHub+Hexo+NexT%EF%BC%88%E4%B8%80%EF%BC%89GitHub.html</url>
      <content type="html"><![CDATA[注：本文所属MGHN，无意中发现了一篇博客，感觉好高大上的样纸，然后发现大家都在用这个搭建博客，我也算是out了，于是自己搭着也玩了玩。网上的搭建教程各式各样，不一定有适合自己的，或多或少都需要改动，下面就讲解一下我的博客搭建之旅。 首先进行相关重要说明，请仔细阅读： 本人是在Mac搭建博客的，所以不会包含和Windows相关的内容，操作系统参数如下：MacBook Pro OS X EI Capitan 10.11.5。 因为搭建博客的过程中会经常输命令，所以： 如果文中代码区块是以$开头的话，代表的是终端默认目录，如：QingFengdeMacBook-Pro:~ qingfeng$。 所有输出类文字或者是提示性文字或者是重点文字都会有自带背景色。 由于内容比较多，在这里我就分章节进行讲解，本文将要讲解的是GitHub的创建和SSH的配置。 GitHub的创建创建GitHub账号Step1 Set up a personal account首先在浏览器中输入网址：https://github.com/join?source=header-home，然后填写用户名、邮箱、密码，注意：该邮箱地址在之后的SSH配置中有重要作用，最后点击Create an account按钮，界面如下图所示： Step2 Choose your plan默认选择即可，直接点击Continue按钮，进入下一步进行邮箱验证，界面如下图所示： Step3 Tailor your experinece登录自己设置的邮箱，点击验证邮箱之类的按钮后会进入该网页，如果在其左上角有Your email was verified.这样的文案表明邮箱验证成功。 配置GitHub相关信息接下来就可以进行创建工程、偏好设置等工作了： 创建工程如图所示： 如果你从未使用过GitHub，可以点击Read the guide按钮学习如何创建工程并使用。 如果你知道如何创建GitHub工程的话，那就简单了，我们直接点击Start a project按钮就可以开始工程的创建，当然也可以从该网页进入。依次填写仓库名、描述信息、初始化README文件，最后点击Create repository按钮，就成功创建一个工程了。但是因为该工程是为了给我们搭建博客用的，所以有以下几个注意点： 仓库名必须为name.github.io这样的格式，需要注意的是：除了大小写可以不同之外，name必须和Github’s Username一模一样；还有据说后面的io也可以是com，这个我就不清楚了，有兴趣的可以尝试一下。 描述信息和是否初始化README文件完全看个人兴趣，但是我的建议是需要的，因为这样能直截了当的明白这个工程是干嘛用的。 例如下图所示： 偏好设置如果你熟悉GitHub，则可以进行一些偏好设置，即个性化设置，如上传头像。这些都是非常简单的，所示就不做阐述了，我们直接进入正题——配置SSH。 配置SSH 打开终端，输入命令： 1$ ssh -T git@github.com 如果输出内容是Permission denied (publickey).，则表明我们尚未在GitHub中正确配置SSH，反之则表明配置成功，直接跳过这一部分即可。 继续输入命令： 1$ ssh-keygen -C &quot;Your primary GitHub email address” 切记必须修改命令中的邮箱地址，该邮箱地址即为你注册GitHub时所填写的邮箱地址。输入成功之后会依行出现如下图所示提示： 分别表示为文件名、密码和确认密码，输入正确后会给出重要的配置信息。 继续输入命令： 1$ cat ~/.ssh/key&apos;s filename.pub | pbcopy 该命令中pub文件的文件名即为上一步中设置的文件名，由于该命令中包含pbcopy关键字，所以该命令可以将pub文件中的内容直接复制到剪切板中，以防之后再网页中配置SSH信息时发生不必要的错误。 打开配置SSH的网页，点击右上角的New SSH key按钮，如下图所示： 然后将pub文件中的内容粘贴到Key表示的文本框中，然后在Title表示的文本框中随便命名一个名字，最后点击Add SSH key按钮即可添加SSH key。 虽然已经成功添加了SSH key，但是这并不代表着SSH配置成功了，我们继续在终端输入命令： 1$ ssh -T git@github.com 如果输出内容包含You&#39;ve successfully authenticated, but GitHub does not provide shell access.则表明SSH配置成功；如果出现错误信息，可以继续输入该命令： 1$ ssh -Tv git@github.com 进行诊断与调试。 最后附上配置SSH的官方教程，还是很详细的。 附至此，我们已经完成了GitHub的创建和SSH的配置，接下来就让我们来学习一下怎么安装Git和Node.js吧。]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Mou]]></title>
      <url>http://fengqingxiuyi.xyz/MarkDown/Mou.html</url>
      <content type="html"><![CDATA[注：本文所属MarkDown，本文直接引用Mou的快速开始使用文档进行说明。 Mou OverviewMou, the missing Markdown editor for web developers. SyntaxStrong and Emphasizestrong or strong ( Cmd + B ) emphasize or emphasize ( Cmd + I ) Sometimes I want a lot of text to be bold.Like, seriously, a LOT of text Blockquotes Right angle brackets &gt; are used for block quotes. Links and EmailAn email &#x65;&#120;&#97;&#x6d;&#112;&#108;&#x65;&#x40;&#x65;&#120;&#97;&#109;&#112;&#x6c;&#101;&#x2e;&#99;&#111;&#x6d; link. Simple inline link http://chenluois.com, another inline link Smaller, one more inline link with title Resize. A reference style link. Input id, then anywhere in the doc, define the link with corresponding id: Titles ( or called tool tips ) in the links are optional. ImagesAn inline image , title is optional. A reference style image. Inline code and Block codeInline code are surround by backtick key. To create a block code: Indent each line by at least 1 tab, or 4 spaces. var Mou = exactlyTheAppIwant; Ordered ListsOrdered lists are created using “1.” + Space: Ordered list item Ordered list item Ordered list item Unordered ListsUnordered list are created using “*” + Space: Unordered list item Unordered list item Unordered list item Or using “-“ + Space: Unordered list item Unordered list item Unordered list item Hard LinebreakEnd a line with two or more spaces will create a hard linebreak, called &lt;br /&gt; in HTML. ( Control + Return )Above line ended with 2 spaces. Horizontal RulesThree or more asterisks or dashes: HeadersSetext-style: This is H1This is H2atx-style: This is H1This is H2This is H3This is H4This is H5This is H6Extra SyntaxFootnotesFootnotes work mostly like reference-style links. A footnote is made of two things: a marker in the text that will become a superscript number; a footnote definition that will be placed in a list of footnotes at the end of the document. A footnote looks like this: That’s some text with a footnote.[^1] [^1]: And that’s the footnote. StrikethroughWrap with 2 tilde characters: Strikethrough Fenced Code BlocksStart with a line containing 3 or more backticks, and ends with the first line with the same number of backticks: 123Fenced code blocks are like Stardard Markdown’s regular codeblocks, except that they’re not indented and instead rely ona start and end fence lines to delimit the code block. TablesA simple table looks like this: First Header Second Header Third Header Content Cell Content Cell Content Cell Content Cell Content Cell Content Cell If you wish, you can add a leading and tailing pipe to each line of the table: First Header Second Header Third Header Content Cell Content Cell Content Cell Content Cell Content Cell Content Cell Specify alignment for each column by adding colons to separator lines: First Header Second Header Third Header Left Center Right Left Center Right ShortcutsView Toggle live preview: Shift + Cmd + I Toggle Words Counter: Shift + Cmd + W Toggle Transparent: Shift + Cmd + T Toggle Floating: Shift + Cmd + F Left/Right = 1/1: Cmd + 0 Left/Right = 3/1: Cmd + + Left/Right = 1/3: Cmd + - Toggle Writing orientation: Cmd + L Toggle fullscreen: Control + Cmd + F Actions Copy HTML: Option + Cmd + C Strong: Select text, Cmd + B Emphasize: Select text, Cmd + I Inline Code: Select text, Cmd + K Strikethrough: Select text, Cmd + U Link: Select text, Control + Shift + L Image: Select text, Control + Shift + I Select Word: Control + Option + W Select Line: Shift + Cmd + L Select All: Cmd + A Deselect All: Cmd + D Convert to Uppercase: Select text, Control + U Convert to Lowercase: Select text, Control + Shift + U Convert to Titlecase: Select text, Control + Option + U Convert to List: Select lines, Control + L Convert to Blockquote: Select lines, Control + Q Convert to H1: Cmd + 1 Convert to H2: Cmd + 2 Convert to H3: Cmd + 3 Convert to H4: Cmd + 4 Convert to H5: Cmd + 5 Convert to H6: Cmd + 6 Convert Spaces to Tabs: Control + [ Convert Tabs to Spaces: Control + ] Insert Current Date: Control + Shift + 1 Insert Current Time: Control + Shift + 2 Insert entity &lt;: Control + Shift + , Insert entity &gt;: Control + Shift + . Insert entity &amp;: Control + Shift + 7 Insert entity Space: Control + Shift + Space Insert Scriptogr.am Header: Control + Shift + G Shift Line Left: Select lines, Cmd + [ Shift Line Right: Select lines, Cmd + ] New Line: Cmd + Return Comment: Cmd + / Hard Linebreak: Control + Return Edit Auto complete current word: Esc Find: Cmd + F Close find bar: Esc Post Post on Scriptogr.am: Control + Shift + S Post on Tumblr: Control + Shift + T Export Export HTML: Option + Cmd + E Export PDF: Option + Cmd + P And more?Don’t forget to check Preferences, lots of useful options are there. Follow @Mou on Twitter for the latest news. For feedback, use the menu Help - Send Feedback]]></content>
    </entry>
    
  
  
</search>
